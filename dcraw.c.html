<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Enscript Output</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<A NAME="file1">
<H1>dcraw.c</H1>

<PRE>
<I><FONT COLOR="#B22222">/*
   dcraw.c -- Dave Coffin's raw photo decoder
   Copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net

   This is a command-line ANSI C program to convert raw photos from
   any digital camera on any computer running any operating system.

   No license is required to download and use dcraw.c.  However,
   to lawfully redistribute dcraw, you must either (a) offer, at
   no extra charge, full source code* for all executable files
   containing RESTRICTED functions, (b) distribute this code under
   the GPL Version 2 or later, (c) remove all RESTRICTED functions,
   re-implement them, or copy them from an earlier, unrestricted
   Revision of dcraw.c, or (d) purchase a license from the author.

   The functions that process Foveon images have been RESTRICTED
   since Revision 1.237.  All other code remains free for all uses.

   *If you have not modified dcraw.c in any way, a link to my
   homepage qualifies as &quot;full source code&quot;.

   $Revision: 1.478 $
   $Date: 2018/06/01 20:36:25 $
 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">DCRAW_VERSION</FONT> <B><FONT COLOR="#BC8F8F">&quot;9.28&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_GNU_SOURCE</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_GNU_SOURCE</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_USE_MATH_DEFINES</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctype.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;errno.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fcntl.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;float.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;math.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;setjmp.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdio.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdlib.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;time.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/types.h&gt;</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">DJGPP</FONT>) || <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">__MINGW32__</FONT>)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">fseeko</FONT> fseek
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ftello</FONT> ftell
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">fgetc</FONT> getc_unlocked
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">__CYGWIN__</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;io.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">WIN32</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;sys/utime.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;winsock2.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">comment</FONT>(<FONT COLOR="#B8860B">lib</FONT>, <B><FONT COLOR="#BC8F8F">&quot;ws2_32.lib&quot;</FONT></B>)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">snprintf</FONT> _snprintf
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">strcasecmp</FONT> stricmp
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">strncasecmp</FONT> strnicmp
<B><FONT COLOR="#228B22">typedef</FONT></B> __int64 INT64;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> __int64 UINT64;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;unistd.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;utime.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;netinet/in.h&gt;</FONT></B>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> INT64;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> UINT64;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NODEPS</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">NO_JASPER</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">NO_JPEG</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_JASPER</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;jasper/jasper.h&gt;</FONT></B>	<I><FONT COLOR="#B22222">/* Decode Red camera movies */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_JPEG</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;jpeglib.h&gt;</FONT></B>		<I><FONT COLOR="#B22222">/* Decode compressed Kodak DC120 photos */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>				<I><FONT COLOR="#B22222">/* and Adobe Lossy DNGs */</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;lcms2.h&gt;</FONT></B>		<I><FONT COLOR="#B22222">/* Support color profiles */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">LOCALEDIR</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;libintl.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">_</FONT></B>(String) gettext(String)
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">_</FONT></B>(String) (String)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> !<B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">uchar</FONT>)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">uchar</FONT> unsigned char
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> !<B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">ushort</FONT>)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ushort</FONT> unsigned short
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">/*
   All global variables are defined here, and all functions that
   access them are prefixed with &quot;CLASS&quot;.  For thread-safety, all
   non-const static local variables except cbrt[] must be declared
   &quot;thread_local&quot;.
 */</FONT></I>
FILE *ifp, *ofp;
<B><FONT COLOR="#228B22">short</FONT></B> order;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *ifname;
<B><FONT COLOR="#228B22">char</FONT></B> *meta_data, xtrans[6][6], xtrans_abs[6][6];
<B><FONT COLOR="#228B22">char</FONT></B> cdesc[5], desc[512], make[64], model[64], model2[64], artist[64];
<B><FONT COLOR="#228B22">float</FONT></B> flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;
time_t timestamp;
off_t strip_offset, data_offset;
off_t thumb_offset, meta_offset, profile_offset;
<B><FONT COLOR="#228B22">unsigned</FONT></B> shot_order, kodak_cbpp, exif_cfa, unique_id;
<B><FONT COLOR="#228B22">unsigned</FONT></B> thumb_length, meta_length, profile_length;
<B><FONT COLOR="#228B22">unsigned</FONT></B> thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;
<B><FONT COLOR="#228B22">unsigned</FONT></B> tiff_nifds, tiff_samples, tiff_bps, tiff_compress;
<B><FONT COLOR="#228B22">unsigned</FONT></B> black, maximum, mix_green, raw_color, zero_is_bad;
<B><FONT COLOR="#228B22">unsigned</FONT></B> zero_after_ff, is_raw, dng_version, is_foveon, data_error;
<B><FONT COLOR="#228B22">unsigned</FONT></B> tile_width, tile_length, gpsdata[32], load_flags;
<B><FONT COLOR="#228B22">unsigned</FONT></B> flip, tiff_flip, filters, colors;
ushort raw_height, raw_width, height, width, top_margin, left_margin;
ushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;
ushort *raw_image, (*image)[4], cblack[4102];
ushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];
<B><FONT COLOR="#228B22">double</FONT></B> pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };
<B><FONT COLOR="#228B22">float</FONT></B> bright=1, user_mul[4]={0,0,0,0}, threshold=0;
<B><FONT COLOR="#228B22">int</FONT></B> mask[8][4];
<B><FONT COLOR="#228B22">int</FONT></B> half_size=0, four_color_rgb=0, document_mode=0, highlight=0;
<B><FONT COLOR="#228B22">int</FONT></B> verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=1;
<B><FONT COLOR="#228B22">int</FONT></B> output_color=1, output_bps=8, output_tiff=0, med_passes=0;
<B><FONT COLOR="#228B22">int</FONT></B> no_auto_bright=0;
<B><FONT COLOR="#228B22">unsigned</FONT></B> greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };
<B><FONT COLOR="#228B22">float</FONT></B> cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xyz_rgb[3][3] = {			<I><FONT COLOR="#B22222">/* XYZ from RGB */</FONT></I>
  { 0.412453, 0.357580, 0.180423 },
  { 0.212671, 0.715160, 0.072169 },
  { 0.019334, 0.119193, 0.950227 } };
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> d65_white[3] = { 0.950456, 1, 1.088754 };
<B><FONT COLOR="#228B22">int</FONT></B> histogram[4][0x2000];
<B><FONT COLOR="#0000FF">void</FONT></B> (*write_thumb)(), (*write_fun)();
<B><FONT COLOR="#0000FF">void</FONT></B> (*load_raw)(), (*thumb_load_raw)();
jmp_buf failure;

<B><FONT COLOR="#228B22">struct</FONT></B> decode {
  <B><FONT COLOR="#228B22">struct</FONT></B> decode *branch[2];
  <B><FONT COLOR="#228B22">int</FONT></B> leaf;
} first_decode[2048], *second_decode, *free_decode;

<B><FONT COLOR="#228B22">struct</FONT></B> tiff_ifd {
  <B><FONT COLOR="#228B22">int</FONT></B> width, height, bps, comp, phint, offset, flip, samples, bytes;
  <B><FONT COLOR="#228B22">int</FONT></B> tile_width, tile_length;
  <B><FONT COLOR="#228B22">float</FONT></B> shutter;
} tiff_ifd[10];

<B><FONT COLOR="#228B22">struct</FONT></B> ph1 {
  <B><FONT COLOR="#228B22">int</FONT></B> format, key_off, tag_21a;
  <B><FONT COLOR="#228B22">int</FONT></B> black, split_col, black_col, split_row, black_row;
  <B><FONT COLOR="#228B22">float</FONT></B> tag_210;
} ph1;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">CLASS</FONT>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">FORC</FONT></B>(cnt) for (c=0; c &lt; cnt; c++)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FORC3</FONT> FORC(3)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FORC4</FONT> FORC(4)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FORCC</FONT> FORC(colors)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SQR</FONT></B>(x) ((x)*(x))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ABS</FONT></B>(x) (((int)(x) ^ ((int)(x) &gt;&gt; 31)) - ((int)(x) &gt;&gt; 31))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MIN</FONT></B>(a,b) ((a) &lt; (b) ? (a) : (b))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MAX</FONT></B>(a,b) ((a) &gt; (b) ? (a) : (b))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">LIM</FONT></B>(x,min,max) MAX(min,MIN(x,max))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ULIM</FONT></B>(x,y,z) ((y) &lt; (z) ? LIM(x,y,z) : LIM(x,z,y))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CLIP</FONT></B>(x) LIM((int)(x),0,65535)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">SWAP</FONT></B>(a,b) { a=a+b; b=a-b; a=a-b; }

<I><FONT COLOR="#B22222">/*
   In order to inline this calculation, I make the risky
   assumption that all filter patterns can be described
   by a repeating pattern of eight rows and two columns

   Do not use the FC or BAYER macros with the Leaf CatchLight,
   because its pattern is 16x16, not 2x8.

   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2

	PowerShot 600	PowerShot A50	PowerShot Pro70	Pro90 &amp; G1
	0xe1e4e1e4:	0x1b4e4b1e:	0x1e4b4e1b:	0xb4b4b4b4:

	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5
	0 G M G M G M	0 C Y C Y C Y	0 Y C Y C Y C	0 G M G M G M
	1 C Y C Y C Y	1 M G M G M G	1 M G M G M G	1 Y C Y C Y C
	2 M G M G M G	2 Y C Y C Y C	2 C Y C Y C Y
	3 C Y C Y C Y	3 G M G M G M	3 G M G M G M
			4 C Y C Y C Y	4 Y C Y C Y C
	PowerShot A5	5 G M G M G M	5 G M G M G M
	0x1e4e1e4e:	6 Y C Y C Y C	6 C Y C Y C Y
			7 M G M G M G	7 M G M G M G
	  0 1 2 3 4 5
	0 C Y C Y C Y
	1 G M G M G M
	2 C Y C Y C Y
	3 M G M G M G

   All RGB cameras use one of these Bayer grids:

	0x16161616:	0x61616161:	0x49494949:	0x94949494:

	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5
	0 B G B G B G	0 G R G R G R	0 G B G B G B	0 R G R G R G
	1 G R G R G R	1 B G B G B G	1 R G R G R G	1 G B G B G B
	2 B G B G B G	2 G R G R G R	2 G B G B G B	2 R G R G R G
	3 G R G R G R	3 B G B G B G	3 R G R G R G	3 G B G B G B
 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">RAW</FONT></B>(row,col) \
	raw_image[(row)*raw_width+(col)]

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">FC</FONT></B>(row,col) \
	(filters &gt;&gt; ((((row) &lt;&lt; 1 &amp; 14) + ((col) &amp; 1)) &lt;&lt; 1) &amp; 3)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">BAYER</FONT></B>(row,col) \
	image[((row) &gt;&gt; shrink)*iwidth + ((col) &gt;&gt; shrink)][FC(row,col)]

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">BAYER2</FONT></B>(row,col) \
	image[((row) &gt;&gt; shrink)*iwidth + ((col) &gt;&gt; shrink)][fcol(row,col)]

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">fcol</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">int</FONT></B> col)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> filter[16][16] =
  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },
    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },
    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },
    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },
    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },
    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },
    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },
    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },
    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },
    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },
    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },
    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },
    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },
    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },
    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },
    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };

  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 1) <B><FONT COLOR="#A020F0">return</FONT></B> filter[(row+top_margin)&amp;15][(col+left_margin)&amp;15];
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) <B><FONT COLOR="#A020F0">return</FONT></B> xtrans[(row+6) % 6][(col+6) % 6];
  <B><FONT COLOR="#A020F0">return</FONT></B> FC(row,col);
}

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">__GLIBC__</FONT>
<B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">my_memmem</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> *haystack, size_t haystacklen,
	      <B><FONT COLOR="#228B22">char</FONT></B> *needle, size_t needlelen)
{
  <B><FONT COLOR="#228B22">char</FONT></B> *c;
  <B><FONT COLOR="#A020F0">for</FONT></B> (c = haystack; c &lt;= haystack + haystacklen - needlelen; c++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (c, needle, needlelen))
      <B><FONT COLOR="#A020F0">return</FONT></B> c;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">memmem</FONT> my_memmem
<B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">my_strcasestr</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B> *haystack, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *needle)
{
  <B><FONT COLOR="#228B22">char</FONT></B> *c;
  <B><FONT COLOR="#A020F0">for</FONT></B> (c = haystack; *c; c++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncasecmp(c, needle, strlen(needle)))
      <B><FONT COLOR="#A020F0">return</FONT></B> c;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">strcasestr</FONT> my_strcasestr
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">merror</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B> *ptr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *where)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (ptr) <B><FONT COLOR="#A020F0">return</FONT></B>;
  fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: Out of memory in %s\n&quot;</FONT></B>), ifname, where);
  longjmp (failure, 1);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">derror</FONT></B>()
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (!data_error) {
    fprintf (stderr, <B><FONT COLOR="#BC8F8F">&quot;%s: &quot;</FONT></B>, ifname);
    <B><FONT COLOR="#A020F0">if</FONT></B> (feof(ifp))
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Unexpected end of file\n&quot;</FONT></B>));
    <B><FONT COLOR="#A020F0">else</FONT></B>
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Corrupt data near 0x%llx\n&quot;</FONT></B>), (INT64) ftello(ifp));
  }
  data_error++;
}

ushort CLASS <B><FONT COLOR="#0000FF">sget2</FONT></B> (uchar *s)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (order == 0x4949)		<I><FONT COLOR="#B22222">/* &quot;II&quot; means little-endian */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> s[0] | s[1] &lt;&lt; 8;
  <B><FONT COLOR="#A020F0">else</FONT></B>				<I><FONT COLOR="#B22222">/* &quot;MM&quot; means big-endian */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> s[0] &lt;&lt; 8 | s[1];
}

ushort CLASS <B><FONT COLOR="#0000FF">get2</FONT></B>()
{
  uchar str[2] = { 0xff,0xff };
  fread (str, 1, 2, ifp);
  <B><FONT COLOR="#A020F0">return</FONT></B> sget2(str);
}

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">sget4</FONT></B> (uchar *s)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (order == 0x4949)
    <B><FONT COLOR="#A020F0">return</FONT></B> s[0] | s[1] &lt;&lt; 8 | s[2] &lt;&lt; 16 | s[3] &lt;&lt; 24;
  <B><FONT COLOR="#A020F0">else</FONT></B>
    <B><FONT COLOR="#A020F0">return</FONT></B> s[0] &lt;&lt; 24 | s[1] &lt;&lt; 16 | s[2] &lt;&lt; 8 | s[3];
}
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">sget4</FONT></B>(s) sget4((uchar *)s)

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">get4</FONT></B>()
{
  uchar str[4] = { 0xff,0xff,0xff,0xff };
  fread (str, 1, 4, ifp);
  <B><FONT COLOR="#A020F0">return</FONT></B> sget4(str);
}

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">getint</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> type)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> type == 3 ? get2() : get4();
}

<B><FONT COLOR="#228B22">float</FONT></B> CLASS <B><FONT COLOR="#0000FF">int_to_float</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i)
{
  <B><FONT COLOR="#228B22">union</FONT></B> { <B><FONT COLOR="#228B22">int</FONT></B> i; <B><FONT COLOR="#228B22">float</FONT></B> f; } u;
  u.i = i;
  <B><FONT COLOR="#A020F0">return</FONT></B> u.f;
}

<B><FONT COLOR="#228B22">double</FONT></B> CLASS <B><FONT COLOR="#0000FF">getreal</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> type)
{
  <B><FONT COLOR="#228B22">union</FONT></B> { <B><FONT COLOR="#228B22">char</FONT></B> c[8]; <B><FONT COLOR="#228B22">double</FONT></B> d; } u;
  <B><FONT COLOR="#228B22">int</FONT></B> i, rev;

  <B><FONT COLOR="#A020F0">switch</FONT></B> (type) {
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B>) get2();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">4</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">5</FONT></B>:  u.d = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
      <B><FONT COLOR="#A020F0">return</FONT></B> u.d / (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">8</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B>) get2();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">9</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> (<B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">10</FONT></B>: u.d = (<B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
      <B><FONT COLOR="#A020F0">return</FONT></B> u.d / (<B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) get4();
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">11</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> int_to_float (get4());
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">12</FONT></B>:
      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
	u.c[i ^ rev] = fgetc(ifp);
      <B><FONT COLOR="#A020F0">return</FONT></B> u.d;
    <B><FONT COLOR="#5F9EA0">default</FONT></B>: <B><FONT COLOR="#A020F0">return</FONT></B> fgetc(ifp);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">read_shorts</FONT></B> (ushort *pixel, <B><FONT COLOR="#228B22">int</FONT></B> count)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, 2, count, ifp) &lt; count) derror();
  <B><FONT COLOR="#A020F0">if</FONT></B> ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
    swab (pixel, pixel, count*2);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">cubic_spline</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> *x_, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> *y_, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len)
{
  <B><FONT COLOR="#228B22">float</FONT></B> **A, *b, *c, *d, *x, *y;
  <B><FONT COLOR="#228B22">int</FONT></B> i, j;

  A = (<B><FONT COLOR="#228B22">float</FONT></B> **) calloc (((2*len + 4)*<B><FONT COLOR="#A020F0">sizeof</FONT></B> **A + <B><FONT COLOR="#A020F0">sizeof</FONT></B> *A), 2*len);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!A) <B><FONT COLOR="#A020F0">return</FONT></B>;
  A[0] = (<B><FONT COLOR="#228B22">float</FONT></B> *) (A + 2*len);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 1; i &lt; 2*len; i++)
    A[i] = A[0] + 2*len*i;
  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; len; i++) {
    x[i] = x_[i] / 65535.0;
    y[i] = y_[i] / 65535.0;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = len-1; i &gt; 0; i--) {
    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);
    d[i-1] = x[i] - x[i-1];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 1; i &lt; len-1; i++) {
    A[i][i] = 2 * (d[i-1] + d[i]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 1) {
      A[i][i-1] = d[i-1];
      A[i-1][i] = d[i-1];
    }
    A[i][len-1] = 6 * (b[i+1] - b[i]);
  }
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 1; i &lt; len-2; i++) {
    <B><FONT COLOR="#228B22">float</FONT></B> v = A[i+1][i] / A[i][i];
    <B><FONT COLOR="#A020F0">for</FONT></B>(j = 1; j &lt;= len-1; j++)
      A[i+1][j] -= v * A[i][j];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = len-2; i &gt; 0; i--) {
    <B><FONT COLOR="#228B22">float</FONT></B> acc = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(j = i; j &lt;= len-2; j++)
      acc += A[i][j]*c[j];
    c[i] = (A[i][len-1] - acc) / A[i][i];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 0x10000; i++) {
    <B><FONT COLOR="#228B22">float</FONT></B> x_out = (<B><FONT COLOR="#228B22">float</FONT></B>)(i / 65535.0);
    <B><FONT COLOR="#228B22">float</FONT></B> y_out = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (j = 0; j &lt; len-1; j++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (x[j] &lt;= x_out &amp;&amp; x_out &lt;= x[j+1]) {
	<B><FONT COLOR="#228B22">float</FONT></B> v = x_out - x[j];
	y_out = y[j] +
	  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v
	   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;
      }
    }
    curve[i] = y_out &lt; 0.0 ? 0 : (y_out &gt;= 1.0 ? 65535 :
		(ushort)(y_out * 65535.0 + 0.5));
  }
  free (A);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_fixed_wb</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> temp)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> mul[4][5] = {
    {  667, 358,397,565,452 },
    {  731, 390,367,499,517 },
    { 1119, 396,348,448,537 },
    { 1399, 485,431,508,688 } };
  <B><FONT COLOR="#228B22">int</FONT></B> lo, hi, i;
  <B><FONT COLOR="#228B22">float</FONT></B> frac=0;

  <B><FONT COLOR="#A020F0">for</FONT></B> (lo=4; --lo; )
    <B><FONT COLOR="#A020F0">if</FONT></B> (*mul[lo] &lt;= temp) <B><FONT COLOR="#A020F0">break</FONT></B>;
  <B><FONT COLOR="#A020F0">for</FONT></B> (hi=0; hi &lt; 3; hi++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (*mul[hi] &gt;= temp) <B><FONT COLOR="#A020F0">break</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (lo != hi)
    frac = (<B><FONT COLOR="#228B22">float</FONT></B>) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=1; i &lt; 5; i++)
    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);
}

<I><FONT COLOR="#B22222">/* Return values:  0 = white  1 = near white  2 = not white */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_color</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> ratio[2], <B><FONT COLOR="#228B22">int</FONT></B> mar)
{
  <B><FONT COLOR="#228B22">int</FONT></B> clipped=0, target, miss;

  <B><FONT COLOR="#A020F0">if</FONT></B> (flash_used) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ratio[1] &lt; -104)
      { ratio[1] = -104; clipped = 1; }
    <B><FONT COLOR="#A020F0">if</FONT></B> (ratio[1] &gt;   12)
      { ratio[1] =   12; clipped = 1; }
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ratio[1] &lt; -264 || ratio[1] &gt; 461) <B><FONT COLOR="#A020F0">return</FONT></B> 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ratio[1] &lt; -50)
      { ratio[1] = -50; clipped = 1; }
    <B><FONT COLOR="#A020F0">if</FONT></B> (ratio[1] &gt; 307)
      { ratio[1] = 307; clipped = 1; }
  }
  target = flash_used || ratio[1] &lt; 197
	? -38 - (398 * ratio[1] &gt;&gt; 10)
	: -123 + (48 * ratio[1] &gt;&gt; 10);
  <B><FONT COLOR="#A020F0">if</FONT></B> (target - mar &lt;= ratio[0] &amp;&amp;
      target + 20  &gt;= ratio[0] &amp;&amp; !clipped) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  miss = target - ratio[0];
  <B><FONT COLOR="#A020F0">if</FONT></B> (abs(miss) &gt;= mar*4) <B><FONT COLOR="#A020F0">return</FONT></B> 2;
  <B><FONT COLOR="#A020F0">if</FONT></B> (miss &lt; -20) miss = -20;
  <B><FONT COLOR="#A020F0">if</FONT></B> (miss &gt; mar) miss = mar;
  ratio[0] = target - miss;
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_auto_wb</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> mar, row, col, i, j, st, count[] = { 0,0 };
  <B><FONT COLOR="#228B22">int</FONT></B> test[8], total[2][8], ratio[2][2], stat[2];

  memset (&amp;total, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> total);
  i = canon_ev + 0.5;
  <B><FONT COLOR="#A020F0">if</FONT></B>      (i &lt; 10) mar = 150;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 12) mar = 20;
  <B><FONT COLOR="#A020F0">else</FONT></B> mar = 280 - 20 * i;
  <B><FONT COLOR="#A020F0">if</FONT></B> (flash_used) mar = 80;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=14; row &lt; height-14; row+=4)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=10; col &lt; width; col+=2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
	test[(i &amp; 4) + FC(row+(i &gt;&gt; 1),col+(i &amp; 1))] =
		    BAYER(row+(i &gt;&gt; 1),col+(i &amp; 1));
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (test[i] &lt; 150 || test[i] &gt; 1500) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (abs(test[i] - test[i+4]) &gt; 50) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 4; j+=2)
	  ratio[i][j &gt;&gt; 1] = ((test[i*4+j+1]-test[i*4+j]) &lt;&lt; 10) / test[i*4+j];
	stat[i] = canon_600_color (ratio[i], mar);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> ((st = stat[0] | stat[1]) &gt; 1) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (stat[i])
	  <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 2; j++)
	    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) &gt;&gt; 10;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
	total[st][i] += test[i];
      count[st]++;
<B><FONT COLOR="#5F9EA0">next</FONT></B>: ;
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (count[0] | count[1]) {
    st = count[0]*200 &lt; count[1];
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_coeff</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> table[6][12] = {
    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },
    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },
    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },
    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },
    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },
    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };
  <B><FONT COLOR="#228B22">int</FONT></B> t=0, i, c;
  <B><FONT COLOR="#228B22">float</FONT></B> mc, yc;

  mc = pre_mul[1] / pre_mul[2];
  yc = pre_mul[3] / pre_mul[2];
  <B><FONT COLOR="#A020F0">if</FONT></B> (mc &gt; 1 &amp;&amp; mc &lt;= 1.28 &amp;&amp; yc &lt; 0.8789) t=1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (mc &gt; 1.28 &amp;&amp; mc &lt;= 2) {
    <B><FONT COLOR="#A020F0">if</FONT></B>  (yc &lt; 0.8789) t=3;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (yc &lt;= 2) t=4;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (flash_used) t=5;
  <B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = i=0; i &lt; 3; i++)
    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_load_raw</FONT></B>()
{
  uchar  data[1120], *dp;
  ushort *pix;
  <B><FONT COLOR="#228B22">int</FONT></B> irow, row;

  <B><FONT COLOR="#A020F0">for</FONT></B> (irow=row=0; irow &lt; height; irow++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (data, 1, 1120, ifp) &lt; 1120) derror();
    pix = raw_image + row*raw_width;
    <B><FONT COLOR="#A020F0">for</FONT></B> (dp=data; dp &lt; data+1120;  dp+=10, pix+=8) {
      pix[0] = (dp[0] &lt;&lt; 2) + (dp[1] &gt;&gt; 6    );
      pix[1] = (dp[2] &lt;&lt; 2) + (dp[1] &gt;&gt; 4 &amp; 3);
      pix[2] = (dp[3] &lt;&lt; 2) + (dp[1] &gt;&gt; 2 &amp; 3);
      pix[3] = (dp[4] &lt;&lt; 2) + (dp[1]      &amp; 3);
      pix[4] = (dp[5] &lt;&lt; 2) + (dp[9]      &amp; 3);
      pix[5] = (dp[6] &lt;&lt; 2) + (dp[9] &gt;&gt; 2 &amp; 3);
      pix[6] = (dp[7] &lt;&lt; 2) + (dp[9] &gt;&gt; 4 &amp; 3);
      pix[7] = (dp[8] &lt;&lt; 2) + (dp[9] &gt;&gt; 6    );
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((row+=2) &gt; height) row = 1;
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_600_correct</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, val;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> mul[4][2] =
  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((val = BAYER(row,col) - black) &lt; 0) val = 0;
      val = val * mul[row &amp; 3][col &amp; 1] &gt;&gt; 9;
      BAYER(row,col) = val;
    }
  canon_600_fixed_wb(1311);
  canon_600_auto_wb();
  canon_600_coeff();
  maximum = (0x3ff - black) * 1109 &gt;&gt; 9;
  black = 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_s2is</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> row;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 100; row++) {
    fseek (ifp, row*3340 + 3284, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (getc(ifp) &gt; 15) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">getbithuff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> nbits, ushort *huff)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> bitbuf=0;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> vbits=0, reset=0;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> c;

  <B><FONT COLOR="#A020F0">if</FONT></B> (nbits &gt; 25) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (nbits &lt; 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> bitbuf = vbits = reset = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (nbits == 0 || vbits &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">while</FONT></B> (!reset &amp;&amp; vbits &lt; nbits &amp;&amp; (c = fgetc(ifp)) != EOF &amp;&amp;
    !(reset = zero_after_ff &amp;&amp; c == 0xff &amp;&amp; fgetc(ifp))) {
    bitbuf = (bitbuf &lt;&lt; 8) + (uchar) c;
    vbits += 8;
  }
  c = bitbuf &lt;&lt; (32-vbits) &gt;&gt; (32-nbits);
  <B><FONT COLOR="#A020F0">if</FONT></B> (huff) {
    vbits -= huff[c] &gt;&gt; 8;
    c = (uchar) huff[c];
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    vbits -= nbits;
  <B><FONT COLOR="#A020F0">if</FONT></B> (vbits &lt; 0) derror();
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">getbits</FONT></B>(n) getbithuff(n,0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">gethuff</FONT></B>(h) getbithuff(*h,h+1)

<I><FONT COLOR="#B22222">/*
   Construct a decode tree according the specification in *source.
   The first 16 bytes specify how many codes should be 1-bit, 2-bit
   3-bit, etc.  Bytes after that are the leaf values.

   For example, if the source is

    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },

   then the code is

	00		0x04
	010		0x03
	011		0x05
	100		0x06
	101		0x02
	1100		0x07
	1101		0x01
	11100		0x08
	11101		0x09
	11110		0x00
	111110		0x0a
	1111110		0x0b
	1111111		0xff
 */</FONT></I>
ushort * CLASS <B><FONT COLOR="#0000FF">make_decoder_ref</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> uchar **source)
{
  <B><FONT COLOR="#228B22">int</FONT></B> max, len, h, i, j;
  <B><FONT COLOR="#228B22">const</FONT></B> uchar *count;
  ushort *huff;

  count = (*source += 16) - 17;
  <B><FONT COLOR="#A020F0">for</FONT></B> (max=16; max &amp;&amp; !count[max]; max--);
  huff = (ushort *) calloc (1 + (1 &lt;&lt; max), <B><FONT COLOR="#A020F0">sizeof</FONT></B> *huff);
  merror (huff, <B><FONT COLOR="#BC8F8F">&quot;make_decoder()&quot;</FONT></B>);
  huff[0] = max;
  <B><FONT COLOR="#A020F0">for</FONT></B> (h=len=1; len &lt;= max; len++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; count[len]; i++, ++*source)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 1 &lt;&lt; (max-len); j++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (h &lt;= 1 &lt;&lt; max)
	  huff[h++] = len &lt;&lt; 8 | **source;
  <B><FONT COLOR="#A020F0">return</FONT></B> huff;
}

ushort * CLASS <B><FONT COLOR="#0000FF">make_decoder</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> uchar *source)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> make_decoder_ref (&amp;source);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">crw_init_tables</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> table, ushort *huff[2])
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar first_tree[3][29] = {
    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,
      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },
    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,
      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar second_tree[3][180] = {
    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,
      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,
      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,
      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,
      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,
      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,
      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,
      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,
      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,
      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,
      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,
      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,
      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,
      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,
      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },
    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,
      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,
      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,
      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,
      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,
      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,
      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,
      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,
      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,
      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,
      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,
      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,
      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,
      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,
      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },
    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,
      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,
      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,
      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,
      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,
      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,
      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,
      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,
      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,
      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,
      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,
      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,
      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,
      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,
      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }
  };
  <B><FONT COLOR="#A020F0">if</FONT></B> (table &gt; 2) table = 2;
  huff[0] = make_decoder ( first_tree[table]);
  huff[1] = make_decoder (second_tree[table]);
}

<I><FONT COLOR="#B22222">/*
   Return 0 if the image starts with compressed data,
   1 if it starts with uncompressed low-order bits.

   In Canon compressed data, 0xff is always followed by 0x00.
 */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_has_lowbits</FONT></B>()
{
  uchar test[0x4000];
  <B><FONT COLOR="#228B22">int</FONT></B> ret=1, i;

  fseek (ifp, 0, SEEK_SET);
  fread (test, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> test, ifp);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=540; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> test - 1; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (test[i] == 0xff) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (test[i+1]) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
      ret=0;
    }
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_load_raw</FONT></B>()
{
  ushort *pixel, *prow, *huff[2];
  <B><FONT COLOR="#228B22">int</FONT></B> nblocks, lowbits, i, c, row, r, save, val;
  <B><FONT COLOR="#228B22">int</FONT></B> block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];

  crw_init_tables (tiff_compress, huff);
  lowbits = canon_has_lowbits();
  <B><FONT COLOR="#A020F0">if</FONT></B> (!lowbits) maximum = 0x3ff;
  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);
  zero_after_ff = 1;
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row+=8) {
    pixel = raw_image + row*raw_width;
    nblocks = MIN (8, raw_height-row) * raw_width &gt;&gt; 6;
    <B><FONT COLOR="#A020F0">for</FONT></B> (block=0; block &lt; nblocks; block++) {
      memset (diffbuf, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> diffbuf);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 64; i++ ) {
	leaf = gethuff(huff[i &gt; 0]);
	<B><FONT COLOR="#A020F0">if</FONT></B> (leaf == 0 &amp;&amp; i) <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">if</FONT></B> (leaf == 0xff) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	i  += leaf &gt;&gt; 4;
	len = leaf &amp; 15;
	<B><FONT COLOR="#A020F0">if</FONT></B> (len == 0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	diff = getbits(len);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((diff &amp; (1 &lt;&lt; (len-1))) == 0)
	  diff -= (1 &lt;&lt; len) - 1;
	<B><FONT COLOR="#A020F0">if</FONT></B> (i &lt; 64) diffbuf[i] = diff;
      }
      diffbuf[0] += carry;
      carry = diffbuf[0];
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 64; i++ ) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (pnum++ % raw_width == 0)
	  base[0] = base[1] = 512;
	<B><FONT COLOR="#A020F0">if</FONT></B> ((pixel[(block &lt;&lt; 6) + i] = base[i &amp; 1] += diffbuf[i]) &gt;&gt; 10)
	  derror();
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (lowbits) {
      save = ftell(ifp);
      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);
      <B><FONT COLOR="#A020F0">for</FONT></B> (prow=pixel, i=0; i &lt; raw_width*2; i++) {
	c = fgetc(ifp);
	<B><FONT COLOR="#A020F0">for</FONT></B> (r=0; r &lt; 8; r+=2, prow++) {
	  val = (*prow &lt;&lt; 2) + ((c &gt;&gt; r) &amp; 3);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 2672 &amp;&amp; val &lt; 512) val += 2;
	  *prow = val;
	}
      }
      fseek (ifp, save, SEEK_SET);
    }
  }
  FORC(2) free (huff[c]);
}

<B><FONT COLOR="#228B22">struct</FONT></B> jhead {
  <B><FONT COLOR="#228B22">int</FONT></B> algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];
  ushort quant[64], idct[64], *huff[20], *free[20], *row;
};

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">ljpeg_start</FONT></B> (<B><FONT COLOR="#228B22">struct</FONT></B> jhead *jh, <B><FONT COLOR="#228B22">int</FONT></B> info_only)
{
  ushort c, tag, len;
  uchar data[0x10000];
  <B><FONT COLOR="#228B22">const</FONT></B> uchar *dp;

  memset (jh, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *jh);
  jh-&gt;restart = INT_MAX;
  <B><FONT COLOR="#A020F0">if</FONT></B> ((fgetc(ifp),fgetc(ifp)) != 0xd8) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">do</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!fread (data, 2, 2, ifp)) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    tag =  data[0] &lt;&lt; 8 | data[1];
    len = (data[2] &lt;&lt; 8 | data[3]) - 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag &lt;= 0xff00) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    fread (data, 1, len, ifp);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffc3</FONT></B>:
	jh-&gt;sraw = ((data[7] &gt;&gt; 4) * (data[7] &amp; 15) - 1) &amp; 3;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffc1</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffc0</FONT></B>:
	jh-&gt;algo = tag &amp; 0xff;
	jh-&gt;bits = data[0];
	jh-&gt;high = data[1] &lt;&lt; 8 | data[2];
	jh-&gt;wide = data[3] &lt;&lt; 8 | data[4];
	jh-&gt;clrs = data[5] + jh-&gt;sraw;
	<B><FONT COLOR="#A020F0">if</FONT></B> (len == 9 &amp;&amp; !dng_version) getc(ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffc4</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (info_only) <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">for</FONT></B> (dp = data; dp &lt; data+len &amp;&amp; !((c = *dp++) &amp; -20); )
	  jh-&gt;free[c] = jh-&gt;huff[c] = make_decoder_ref (&amp;dp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffda</FONT></B>:
	jh-&gt;psv = data[1+data[0]*2];
	jh-&gt;bits -= data[3+data[0]*2] &amp; 15;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffdb</FONT></B>:
	FORC(64) jh-&gt;quant[c] = data[c*2+1] &lt;&lt; 8 | data[c*2+2];
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xffdd</FONT></B>:
	jh-&gt;restart = data[0] &lt;&lt; 8 | data[1];
    }
  } <B><FONT COLOR="#A020F0">while</FONT></B> (tag != 0xffda);
  <B><FONT COLOR="#A020F0">if</FONT></B> (jh-&gt;bits &gt; 16 || jh-&gt;clrs &gt; 6 ||
     !jh-&gt;bits || !jh-&gt;high || !jh-&gt;wide || !jh-&gt;clrs) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (info_only) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!jh-&gt;huff[0]) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  FORC(19) <B><FONT COLOR="#A020F0">if</FONT></B> (!jh-&gt;huff[c+1]) jh-&gt;huff[c+1] = jh-&gt;huff[c];
  <B><FONT COLOR="#A020F0">if</FONT></B> (jh-&gt;sraw) {
    FORC(4)        jh-&gt;huff[2+c] = jh-&gt;huff[1];
    FORC(jh-&gt;sraw) jh-&gt;huff[1+c] = jh-&gt;huff[0];
  }
  jh-&gt;row = (ushort *) calloc (jh-&gt;wide*jh-&gt;clrs, 4);
  merror (jh-&gt;row, <B><FONT COLOR="#BC8F8F">&quot;ljpeg_start()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">return</FONT></B> zero_after_ff = 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ljpeg_end</FONT></B> (<B><FONT COLOR="#228B22">struct</FONT></B> jhead *jh)
{
  <B><FONT COLOR="#228B22">int</FONT></B> c;
  FORC4 <B><FONT COLOR="#A020F0">if</FONT></B> (jh-&gt;free[c]) free (jh-&gt;free[c]);
  free (jh-&gt;row);
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">ljpeg_diff</FONT></B> (ushort *huff)
{
  <B><FONT COLOR="#228B22">int</FONT></B> len, diff;

  len = gethuff(huff);
  <B><FONT COLOR="#A020F0">if</FONT></B> (len == 16 &amp;&amp; (!dng_version || dng_version &gt;= 0x1010000))
    <B><FONT COLOR="#A020F0">return</FONT></B> -32768;
  diff = getbits(len);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((diff &amp; (1 &lt;&lt; (len-1))) == 0)
    diff -= (1 &lt;&lt; len) - 1;
  <B><FONT COLOR="#A020F0">return</FONT></B> diff;
}

ushort * CLASS <B><FONT COLOR="#0000FF">ljpeg_row</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> jrow, <B><FONT COLOR="#228B22">struct</FONT></B> jhead *jh)
{
  <B><FONT COLOR="#228B22">int</FONT></B> col, c, diff, pred, spred=0;
  ushort mark=0, *row[3];

  <B><FONT COLOR="#A020F0">if</FONT></B> (jrow * jh-&gt;wide % jh-&gt;restart == 0) {
    FORC(6) jh-&gt;vpred[c] = 1 &lt;&lt; (jh-&gt;bits-1);
    <B><FONT COLOR="#A020F0">if</FONT></B> (jrow) {
      fseek (ifp, -2, SEEK_CUR);
      <B><FONT COLOR="#A020F0">do</FONT></B> mark = (mark &lt;&lt; 8) + (c = fgetc(ifp));
      <B><FONT COLOR="#A020F0">while</FONT></B> (c != EOF &amp;&amp; mark &gt;&gt; 4 != 0xffd);
    }
    getbits(-1);
  }
  FORC3 row[c] = jh-&gt;row + jh-&gt;wide*jh-&gt;clrs*((jrow+c) &amp; 1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; jh-&gt;wide; col++)
    FORC(jh-&gt;clrs) {
      diff = ljpeg_diff (jh-&gt;huff[c]);
      <B><FONT COLOR="#A020F0">if</FONT></B> (jh-&gt;sraw &amp;&amp; c &lt;= jh-&gt;sraw &amp;&amp; (col | c))
		    pred = spred;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (col) pred = row[0][-jh-&gt;clrs];
      <B><FONT COLOR="#A020F0">else</FONT></B>	    pred = (jh-&gt;vpred[c] += diff) - diff;
      <B><FONT COLOR="#A020F0">if</FONT></B> (jrow &amp;&amp; col) <B><FONT COLOR="#A020F0">switch</FONT></B> (jh-&gt;psv) {
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:	<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: pred = row[1][0];					<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>: pred = row[1][-jh-&gt;clrs];				<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">4</FONT></B>: pred = pred +   row[1][0] - row[1][-jh-&gt;clrs];		<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">5</FONT></B>: pred = pred + ((row[1][0] - row[1][-jh-&gt;clrs]) &gt;&gt; 1);	<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>: pred = row[1][0] + ((pred - row[1][-jh-&gt;clrs]) &gt;&gt; 1);	<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">7</FONT></B>: pred = (pred + row[1][0]) &gt;&gt; 1;				<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#5F9EA0">default</FONT></B>: pred = 0;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> ((**row = pred + diff) &gt;&gt; jh-&gt;bits) derror();
      <B><FONT COLOR="#A020F0">if</FONT></B> (c &lt;= jh-&gt;sraw) spred = **row;
      row[0]++; row[1]++;
    }
  <B><FONT COLOR="#A020F0">return</FONT></B> row[2];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">lossless_jpeg_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;
  ushort *rp;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!ljpeg_start (&amp;jh, 0)) <B><FONT COLOR="#A020F0">return</FONT></B>;
  jwide = jh.wide * jh.clrs;

  <B><FONT COLOR="#A020F0">for</FONT></B> (jrow=0; jrow &lt; jh.high; jrow++) {
    rp = ljpeg_row (jrow, &amp;jh);
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags &amp; 1)
      row = jrow &amp; 1 ? height-1-jrow/2 : jrow/2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (jcol=0; jcol &lt; jwide; jcol++) {
      val = curve[*rp++];
      <B><FONT COLOR="#A020F0">if</FONT></B> (cr2_slice[0]) {
	jidx = jrow*jwide + jcol;
	i = jidx / (cr2_slice[1]*raw_height);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((j = i &gt;= cr2_slice[0]))
		 i  = cr2_slice[0];
	jidx -= i * (cr2_slice[1]*raw_height);
	row = jidx / cr2_slice[1+j];
	col = jidx % cr2_slice[1+j] + i*cr2_slice[1];
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 3984 &amp;&amp; (col -= 2) &lt; 0)
	col += (row--,raw_width);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) row &lt; raw_height) RAW(row,col) = val;
      <B><FONT COLOR="#A020F0">if</FONT></B> (++col &gt;= raw_width)
	col = (row++,0);
    }
  }
  ljpeg_end (&amp;jh);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_sraw_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;
  <B><FONT COLOR="#228B22">short</FONT></B> *rp=0, (*ip)[4];
  <B><FONT COLOR="#228B22">int</FONT></B> jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;
  <B><FONT COLOR="#228B22">int</FONT></B> v[3]={0,0,0}, ver, hue;
  <B><FONT COLOR="#228B22">char</FONT></B> *cp;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!ljpeg_start (&amp;jh, 0) || jh.clrs &lt; 4) <B><FONT COLOR="#A020F0">return</FONT></B>;
  jwide = (jh.wide &gt;&gt;= 1) * jh.clrs;

  <B><FONT COLOR="#A020F0">for</FONT></B> (ecol=slice=0; slice &lt;= cr2_slice[0]; slice++) {
    scol = ecol;
    ecol += cr2_slice[1] * 2 / jh.clrs;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!cr2_slice[0] || ecol &gt; raw_width-1) ecol = raw_width &amp; -2;
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row += (jh.clrs &gt;&gt; 1) - 1) {
      ip = (<B><FONT COLOR="#228B22">short</FONT></B> (*)[4]) image + row*width;
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=scol; col &lt; ecol; col+=2, jcol+=jh.clrs) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((jcol %= jwide) == 0)
	  rp = (<B><FONT COLOR="#228B22">short</FONT></B> *) ljpeg_row (jrow++, &amp;jh);
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &gt;= width) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	FORC (jh.clrs-2)
	  ip[col + (c &gt;&gt; 1)*width + (c &amp; 1)][0] = rp[jcol+c];
	ip[col][1] = rp[jcol+jh.clrs-2] - 16384;
	ip[col][2] = rp[jcol+jh.clrs-1] - 16384;
      }
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (cp=model2; *cp &amp;&amp; !isdigit(*cp); cp++);
  sscanf (cp, <B><FONT COLOR="#BC8F8F">&quot;%d.%d.%d&quot;</FONT></B>, v, v+1, v+2);
  ver = (v[0]*1000 + v[1])*1000 + v[2];
  hue = (jh.sraw+1) &lt;&lt; 2;
  <B><FONT COLOR="#A020F0">if</FONT></B> (unique_id &gt;= 0x80000281 || (unique_id == 0x80000218 &amp;&amp; ver &gt; 1000006))
    hue = jh.sraw &lt;&lt; 1;
  ip = (<B><FONT COLOR="#228B22">short</FONT></B> (*)[4]) image;
  rp = ip[0];
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++, ip+=width) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (row &amp; (jh.sraw &gt;&gt; 1))
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col+=2)
	<B><FONT COLOR="#A020F0">for</FONT></B> (c=1; c &lt; 3; c++)
	  <B><FONT COLOR="#A020F0">if</FONT></B> (row == height-1)
	       ip[col][c] =  ip[col-width][c];
	  <B><FONT COLOR="#A020F0">else</FONT></B> ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) &gt;&gt; 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=1; col &lt; width; col+=2)
      <B><FONT COLOR="#A020F0">for</FONT></B> (c=1; c &lt; 3; c++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (col == width-1)
	     ip[col][c] =  ip[col-1][c];
	<B><FONT COLOR="#A020F0">else</FONT></B> ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) &gt;&gt; 1;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> ( ; rp &lt; ip[0]; rp+=4) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (unique_id == 0x80000218 ||
	unique_id == 0x80000250 ||
	unique_id == 0x80000261 ||
	unique_id == 0x80000281 ||
	unique_id == 0x80000287) {
      rp[1] = (rp[1] &lt;&lt; 2) + hue;
      rp[2] = (rp[2] &lt;&lt; 2) + hue;
      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) &gt;&gt; 14);
      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) &gt;&gt; 14);
      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) &gt;&gt; 14);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">if</FONT></B> (unique_id &lt; 0x80000218) rp[0] -= 512;
      pix[0] = rp[0] + rp[2];
      pix[2] = rp[0] + rp[1];
      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] &lt;&lt; 11)) &gt;&gt; 12);
    }
    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] &gt;&gt; 10);
  }
  ljpeg_end (&amp;jh);
  maximum = 0x3fff;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">adobe_copy_pixel</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> row, <B><FONT COLOR="#228B22">unsigned</FONT></B> col, ushort **rp)
{
  <B><FONT COLOR="#228B22">int</FONT></B> c;

  <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples == 2 &amp;&amp; shot_select) (*rp)++;
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_image) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; raw_height &amp;&amp; col &lt; raw_width)
      RAW(row,col) = curve[**rp];
    *rp += tiff_samples;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; height &amp;&amp; col &lt; width)
      FORC(tiff_samples)
	image[row*width+col][c] = curve[(*rp)[c]];
    *rp += tiff_samples;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples == 2 &amp;&amp; shot_select) (*rp)--;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ljpeg_idct</FONT></B> (<B><FONT COLOR="#228B22">struct</FONT></B> jhead *jh)
{
  <B><FONT COLOR="#228B22">int</FONT></B> c, i, j, len, skip, coef;
  <B><FONT COLOR="#228B22">float</FONT></B> work[3][8][8];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> cs[106] = { 0 };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar zigzag[80] =
  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,
    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,
    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,
    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };

  <B><FONT COLOR="#A020F0">if</FONT></B> (!cs[0])
    FORC(106) cs[c] = cos((c &amp; 31)*M_PI/16)/2;
  memset (work, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> work);
  work[0][0][0] = jh-&gt;vpred[0] += ljpeg_diff (jh-&gt;huff[0]) * jh-&gt;quant[0];
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=1; i &lt; 64; i++ ) {
    len = gethuff (jh-&gt;huff[16]);
    i += skip = len &gt;&gt; 4;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(len &amp;= 15) &amp;&amp; skip &lt; 15) <B><FONT COLOR="#A020F0">break</FONT></B>;
    coef = getbits(len);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((coef &amp; (1 &lt;&lt; (len-1))) == 0)
      coef -= (1 &lt;&lt; len) - 1;
    ((<B><FONT COLOR="#228B22">float</FONT></B> *)work)[zigzag[i]] = coef * jh-&gt;quant[i];
  }
  FORC(8) work[0][0][c] *= M_SQRT1_2;
  FORC(8) work[0][c][0] *= M_SQRT1_2;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 8; j++)
      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 8; j++)
      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];

  FORC(64) jh-&gt;idct[c] = CLIP(((<B><FONT COLOR="#228B22">float</FONT></B> *)work[2])[c]+0.5);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">lossless_dng_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;
  ushort *rp;

  <B><FONT COLOR="#A020F0">while</FONT></B> (trow &lt; raw_height) {
    save = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tile_length &lt; INT_MAX)
      fseek (ifp, get4(), SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!ljpeg_start (&amp;jh, 0)) <B><FONT COLOR="#A020F0">break</FONT></B>;
    jwide = jh.wide;
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters) jwide *= jh.clrs;
    jwide /= MIN (is_raw, tiff_samples);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (jh.algo) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xc1</FONT></B>:
	jh.vpred[0] = 16384;
	getbits(-1);
	<B><FONT COLOR="#A020F0">for</FONT></B> (jrow=0; jrow+7 &lt; jh.high; jrow += 8) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (jcol=0; jcol+7 &lt; jh.wide; jcol += 8) {
	    ljpeg_idct (&amp;jh);
	    rp = jh.idct;
	    row = trow + jcol/tile_width + jrow*2;
	    col = tcol + jcol%tile_width;
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 16; i+=2)
	      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 8; j++)
		adobe_copy_pixel (row+i, col+j, &amp;rp);
	  }
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xc3</FONT></B>:
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=col=jrow=0; jrow &lt; jh.high; jrow++) {
	  rp = ljpeg_row (jrow, &amp;jh);
	  <B><FONT COLOR="#A020F0">for</FONT></B> (jcol=0; jcol &lt; jwide; jcol++) {
	    adobe_copy_pixel (trow+row, tcol+col, &amp;rp);
	    <B><FONT COLOR="#A020F0">if</FONT></B> (++col &gt;= tile_width || col &gt;= raw_width)
	      row += 1 + (col = 0);
	  }
	}
    }
    fseek (ifp, save+4, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tcol += tile_width) &gt;= raw_width)
      trow += tile_length + (tcol = 0);
    ljpeg_end (&amp;jh);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">packed_dng_load_raw</FONT></B>()
{
  ushort *pixel, *rp;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col;

  pixel = (ushort *) calloc (raw_width, tiff_samples*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;packed_dng_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_bps == 16)
      read_shorts (pixel, raw_width * tiff_samples);
    <B><FONT COLOR="#A020F0">else</FONT></B> {
      getbits(-1);
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width * tiff_samples; col++)
	pixel[col] = getbits(tiff_bps);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (rp=pixel, col=0; col &lt; raw_width; col++)
      adobe_copy_pixel (row, col, &amp;rp);
  }
  free (pixel);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">pentax_load_raw</FONT></B>()
{
  ushort bit[2][15], huff[4097];
  <B><FONT COLOR="#228B22">int</FONT></B> dep, row, col, diff, c, i;
  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];

  fseek (ifp, meta_offset, SEEK_SET);
  dep = (get2() + 12) &amp; 15;
  fseek (ifp, 12, SEEK_CUR);
  FORC(dep) bit[0][c] = get2();
  FORC(dep) bit[1][c] = fgetc(ifp);
  FORC(dep)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=bit[0][c]; i &lt;= ((bit[0][c]+(4096 &gt;&gt; bit[1][c])-1) &amp; 4095); )
      huff[++i] = bit[1][c] &lt;&lt; 8 | c;
  huff[0] = 12;
  fseek (ifp, data_offset, SEEK_SET);
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      diff = ljpeg_diff (huff);
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) hpred[col] = vpred[row &amp; 1][col] += diff;
      <B><FONT COLOR="#A020F0">else</FONT></B>	   hpred[col &amp; 1] += diff;
      RAW(row,col) = hpred[col &amp; 1];
      <B><FONT COLOR="#A020F0">if</FONT></B> (hpred[col &amp; 1] &gt;&gt; tiff_bps) derror();
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">nikon_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar nikon_tree[][32] = {
    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	<I><FONT COLOR="#B22222">/* 12-bit lossy */</FONT></I>
      5,4,3,6,2,7,1,0,8,9,11,10,12 },
    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	<I><FONT COLOR="#B22222">/* 12-bit lossy after split */</FONT></I>
      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },
    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  <I><FONT COLOR="#B22222">/* 12-bit lossless */</FONT></I>
      5,4,6,3,7,2,8,1,9,0,10,11,12 },
    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	<I><FONT COLOR="#B22222">/* 14-bit lossy */</FONT></I>
      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },
    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	<I><FONT COLOR="#B22222">/* 14-bit lossy after split */</FONT></I>
      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },
    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	<I><FONT COLOR="#B22222">/* 14-bit lossless */</FONT></I>
      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };
  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;
  <B><FONT COLOR="#228B22">int</FONT></B> i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;

  fseek (ifp, meta_offset, SEEK_SET);
  ver0 = fgetc(ifp);
  ver1 = fgetc(ifp);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver0 == 0x49 || ver1 == 0x58)
    fseek (ifp, 2110, SEEK_CUR);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver0 == 0x46) tree = 2;
  <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_bps == 14) tree += 3;
  read_shorts (vpred[0], 4);
  max = 1 &lt;&lt; tiff_bps &amp; 0x7fff;
  <B><FONT COLOR="#A020F0">if</FONT></B> ((csize = get2()) &gt; 1)
    step = max / (csize-1);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver0 == 0x44 &amp;&amp; ver1 == 0x20 &amp;&amp; step &gt; 0) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; csize; i++)
      curve[i*step] = get2();
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; max; i++)
      curve[i] = ( curve[i-i%step]*(step-i%step) +
		   curve[i-i%step+step]*(i%step) ) / step;
    fseek (ifp, meta_offset+562, SEEK_SET);
    split = get2();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (ver0 != 0x46 &amp;&amp; csize &lt;= 0x4001)
    read_shorts (curve, max=csize);
  <B><FONT COLOR="#A020F0">while</FONT></B> (curve[max-2] == curve[max-1]) max--;
  huff = make_decoder (nikon_tree[tree]);
  fseek (ifp, data_offset, SEEK_SET);
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (min=row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (split &amp;&amp; row == split) {
      free (huff);
      huff = make_decoder (nikon_tree[tree+1]);
      max += (min = 16) &lt;&lt; 1;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      i = gethuff(huff);
      len = i &amp; 15;
      shl = i &gt;&gt; 4;
      diff = ((getbits(len-shl) &lt;&lt; 1) + 1) &lt;&lt; shl &gt;&gt; 1;
      <B><FONT COLOR="#A020F0">if</FONT></B> ((diff &amp; (1 &lt;&lt; (len-1))) == 0)
	diff -= (1 &lt;&lt; len) - !shl;
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) hpred[col] = vpred[row &amp; 1][col] += diff;
      <B><FONT COLOR="#A020F0">else</FONT></B>	   hpred[col &amp; 1] += diff;
      <B><FONT COLOR="#A020F0">if</FONT></B> ((ushort)(hpred[col &amp; 1] + min) &gt;= max) derror();
      RAW(row,col) = curve[LIM((<B><FONT COLOR="#228B22">short</FONT></B>)hpred[col &amp; 1],0,0x3fff)];
    }
  }
  free (huff);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">nikon_yuv_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, yuv[4], rgb[3], b, c;
  UINT64 bitbuf=0;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!(b = col &amp; 1)) {
	bitbuf = 0;
	FORC(6) bitbuf |= (UINT64) fgetc(ifp) &lt;&lt; c*8;
	FORC(4) yuv[c] = (bitbuf &gt;&gt; c*12 &amp; 0xfff) - (c &gt;&gt; 1 &lt;&lt; 11);
      }
      rgb[0] = yuv[b] + 1.370705*yuv[3];
      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];
      rgb[2] = yuv[b] + 1.732446*yuv[2];
      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cam_mul[c];
    }
}

<I><FONT COLOR="#B22222">/*
   Returns 1 for a Coolpix 995, 0 for anything else.
 */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">nikon_e995</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, histo[256];
  <B><FONT COLOR="#228B22">const</FONT></B> uchar often[] = { 0x00, 0x55, 0xaa, 0xff };

  memset (histo, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> histo);
  fseek (ifp, -2000, SEEK_END);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2000; i++)
    histo[fgetc(ifp)]++;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (histo[often[i]] &lt; 200)
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">/*
   Returns 1 for a Coolpix 2100, 0 for anything else.
 */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">nikon_e2100</FONT></B>()
{
  uchar t[12];
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  fseek (ifp, 0, SEEK_SET);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 1024; i++) {
    fread (t, 1, 12, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (((t[2] &amp; t[4] &amp; t[7] &amp; t[9]) &gt;&gt; 4
	&amp; t[1] &amp; t[6] &amp; t[8] &amp; t[11] &amp; 3) != 3)
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">nikon_3700</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> bits, i;
  uchar dp[24];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> {
    <B><FONT COLOR="#228B22">int</FONT></B> bits;
    <B><FONT COLOR="#228B22">char</FONT></B> make[12], model[15];
  } table[] = {
    { 0x00, <B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>,  <B><FONT COLOR="#BC8F8F">&quot;Optio 33WR&quot;</FONT></B> },
    { 0x03, <B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,   <B><FONT COLOR="#BC8F8F">&quot;E3200&quot;</FONT></B> },
    { 0x32, <B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,   <B><FONT COLOR="#BC8F8F">&quot;E3700&quot;</FONT></B> },
    { 0x33, <B><FONT COLOR="#BC8F8F">&quot;Olympus&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;C740UZ&quot;</FONT></B> } };

  fseek (ifp, 3072, SEEK_SET);
  fread (dp, 1, 24, ifp);
  bits = (dp[8] &amp; 3) &lt;&lt; 4 | (dp[20] &amp; 3);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> table / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *table; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (bits == table[i].bits) {
      strcpy (make,  table[i].make );
      strcpy (model, table[i].model);
    }
}

<I><FONT COLOR="#B22222">/*
   Separates a Minolta DiMAGE Z2 from a Nikon E4300.
 */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">minolta_z2</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, nz;
  <B><FONT COLOR="#228B22">char</FONT></B> tail[424];

  fseek (ifp, -<B><FONT COLOR="#A020F0">sizeof</FONT></B> tail, SEEK_END);
  fread (tail, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> tail, ifp);
  <B><FONT COLOR="#A020F0">for</FONT></B> (nz=i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> tail; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (tail[i]) nz++;
  <B><FONT COLOR="#A020F0">return</FONT></B> nz &gt; 20;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">jpeg_thumb</FONT></B>();

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ppm_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">char</FONT></B> *thumb;
  thumb_length = thumb_width*thumb_height*3;
  thumb = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (thumb_length);
  merror (thumb, <B><FONT COLOR="#BC8F8F">&quot;ppm_thumb()&quot;</FONT></B>);
  fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P6\n%d %d\n255\n&quot;</FONT></B>, thumb_width, thumb_height);
  fread  (thumb, 1, thumb_length, ifp);
  fwrite (thumb, 1, thumb_length, ofp);
  free (thumb);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ppm16_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#228B22">char</FONT></B> *thumb;
  thumb_length = thumb_width*thumb_height*3;
  thumb = (<B><FONT COLOR="#228B22">char</FONT></B> *) calloc (thumb_length, 2);
  merror (thumb, <B><FONT COLOR="#BC8F8F">&quot;ppm16_thumb()&quot;</FONT></B>);
  read_shorts ((ushort *) thumb, thumb_length);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; thumb_length; i++)
    thumb[i] = ((ushort *) thumb)[i] &gt;&gt; 8;
  fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P6\n%d %d\n255\n&quot;</FONT></B>, thumb_width, thumb_height);
  fwrite (thumb, 1, thumb_length, ofp);
  free (thumb);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">layer_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, c;
  <B><FONT COLOR="#228B22">char</FONT></B> *thumb, map[][4] = { <B><FONT COLOR="#BC8F8F">&quot;012&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;102&quot;</FONT></B> };

  colors = thumb_misc &gt;&gt; 5 &amp; 7;
  thumb_length = thumb_width*thumb_height;
  thumb = (<B><FONT COLOR="#228B22">char</FONT></B> *) calloc (colors, thumb_length);
  merror (thumb, <B><FONT COLOR="#BC8F8F">&quot;layer_thumb()&quot;</FONT></B>);
  fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P%d\n%d %d\n255\n&quot;</FONT></B>,
	5 + (colors &gt;&gt; 1), thumb_width, thumb_height);
  fread (thumb, thumb_length, colors, ifp);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; thumb_length; i++)
    FORCC putc (thumb[i+thumb_length*(map[thumb_misc &gt;&gt; 8][c]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>)], ofp);
  free (thumb);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">rollei_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i;
  ushort *thumb;

  thumb_length = thumb_width * thumb_height;
  thumb = (ushort *) calloc (thumb_length, 2);
  merror (thumb, <B><FONT COLOR="#BC8F8F">&quot;rollei_thumb()&quot;</FONT></B>);
  fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P6\n%d %d\n255\n&quot;</FONT></B>, thumb_width, thumb_height);
  read_shorts (thumb, thumb_length);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; thumb_length; i++) {
    putc (thumb[i] &lt;&lt; 3, ofp);
    putc (thumb[i] &gt;&gt; 5  &lt;&lt; 2, ofp);
    putc (thumb[i] &gt;&gt; 11 &lt;&lt; 3, ofp);
  }
  free (thumb);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">rollei_load_raw</FONT></B>()
{
  uchar pixel[10];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> iten=0, isix, i, buffer=0, todo[16];

  isix = raw_width * raw_height * 5 / 8;
  <B><FONT COLOR="#A020F0">while</FONT></B> (fread (pixel, 1, 10, ifp) == 10) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 10; i+=2) {
      todo[i]   = iten++;
      todo[i+1] = pixel[i] &lt;&lt; 8 | pixel[i+1];
      buffer    = pixel[i] &gt;&gt; 2 | buffer &lt;&lt; 6;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (   ; i &lt; 16; i+=2) {
      todo[i]   = isix++;
      todo[i+1] = buffer &gt;&gt; (14-i)*5;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 16; i+=2)
      raw_image[todo[i]] = (todo[i+1] &amp; 0x3ff);
  }
  maximum = 0x3ff;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">raw</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> row, <B><FONT COLOR="#228B22">unsigned</FONT></B> col)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> (row &lt; raw_height &amp;&amp; col &lt; raw_width) ? RAW(row,col) : 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">phase_one_flat_field</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> is_float, <B><FONT COLOR="#228B22">int</FONT></B> nc)
{
  ushort head[8];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> wide, high, y, x, c, rend, cend, row, col;
  <B><FONT COLOR="#228B22">float</FONT></B> *mrow, num, mult[4];

  read_shorts (head, 8);
  <B><FONT COLOR="#A020F0">if</FONT></B> (head[2] * head[3] * head[4] * head[5] == 0) <B><FONT COLOR="#A020F0">return</FONT></B>;
  wide = head[2] / head[4] + (head[2] % head[4] != 0);
  high = head[3] / head[5] + (head[3] % head[5] != 0);
  mrow = (<B><FONT COLOR="#228B22">float</FONT></B> *) calloc (nc*wide, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *mrow);
  merror (mrow, <B><FONT COLOR="#BC8F8F">&quot;phase_one_flat_field()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (y=0; y &lt; high; y++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (x=0; x &lt; wide; x++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; nc; c+=2) {
	num = is_float ? getreal(11) : get2()/32768.0;
	<B><FONT COLOR="#A020F0">if</FONT></B> (y==0) mrow[c*wide+x] = num;
	<B><FONT COLOR="#A020F0">else</FONT></B> mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> (y==0) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    rend = head[1] + y*head[5];
    <B><FONT COLOR="#A020F0">for</FONT></B> (row = rend-head[5];
	 row &lt; raw_height &amp;&amp; row &lt; rend &amp;&amp;
	 row &lt; head[1]+head[3]-head[5]; row++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (x=1; x &lt; wide; x++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; nc; c+=2) {
	  mult[c] = mrow[c*wide+x-1];
	  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];
	}
	cend = head[0] + x*head[4];
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = cend-head[4];
	     col &lt; raw_width &amp;&amp;
	     col &lt; cend &amp;&amp; col &lt; head[0]+head[2]-head[4]; col++) {
	  c = nc &gt; 2 ? FC(row-top_margin,col-left_margin) : 0;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!(c &amp; 1)) {
	    c = RAW(row,col) * mult[c];
	    RAW(row,col) = LIM(c,0,65535);
	  }
	  <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; nc; c+=2)
	    mult[c] += mult[c+1];
	}
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (x=0; x &lt; wide; x++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; nc; c+=2)
	  mrow[c*wide+x] += mrow[(c+1)*wide+x];
    }
  }
  free (mrow);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">phase_one_correct</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, data, save, col, row, type;
  <B><FONT COLOR="#228B22">int</FONT></B> len, i, j, k, cip, val[4], dev[4], sum, max;
  <B><FONT COLOR="#228B22">int</FONT></B> head[9], diff, mindiff=INT_MAX, off_412=0;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> dir[12][2] =
    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},
      {-2,-2}, {-2,2}, {2,-2}, {2,2} };
  <B><FONT COLOR="#228B22">float</FONT></B> poly[8], num, cfrac, frac, mult[2], *yval[2];
  ushort *xval[2];
  <B><FONT COLOR="#228B22">int</FONT></B> qmult_applied = 0, qlin_applied = 0;

  <B><FONT COLOR="#A020F0">if</FONT></B> (half_size || !meta_length) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Phase One correction...\n&quot;</FONT></B>));
  fseek (ifp, meta_offset, SEEK_SET);
  order = get2();
  fseek (ifp, 6, SEEK_CUR);
  fseek (ifp, meta_offset+get4(), SEEK_SET);
  entries = get4();  get4();
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tag  = get4();
    len  = get4();
    data = get4();
    save = ftell(ifp);
    fseek (ifp, meta_offset+data, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x419) {				<I><FONT COLOR="#B22222">/* Polynomial curve */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (get4(), i=0; i &lt; 8; i++)
	poly[i] = getreal(11);
      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 0x10000; i++) {
	num = (poly[5]*i + poly[3])*i + poly[1];
	curve[i] = LIM(num,0,65535);
      } <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">apply</FONT></B>;				<I><FONT COLOR="#B22222">/* apply to right half */</FONT></I>
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x41a) {			<I><FONT COLOR="#B22222">/* Polynomial curve */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	poly[i] = getreal(11);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 0x10000; i++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (num=0, j=4; j--; )
	  num = num * i + poly[j];
	curve[i] = LIM(num+i,0,65535);
      } apply:					<I><FONT COLOR="#B22222">/* apply to whole image */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = (tag &amp; 1)*ph1.split_col; col &lt; raw_width; col++)
	  RAW(row,col) = curve[RAW(row,col)];
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x400) {			<I><FONT COLOR="#B22222">/* Sensor defects */</FONT></I>
      <B><FONT COLOR="#A020F0">while</FONT></B> ((len -= 8) &gt;= 0) {
	col  = get2();
	row  = get2();
	type = get2(); get2();
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &gt;= raw_width) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	<B><FONT COLOR="#A020F0">if</FONT></B> (type == 131 || type == 137)		<I><FONT COLOR="#B22222">/* Bad column */</FONT></I>
	  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (FC(row-top_margin,col-left_margin) == 1) {
	      <B><FONT COLOR="#A020F0">for</FONT></B> (sum=i=0; i &lt; 4; i++)
		sum += val[i] = raw (row+dir[i][0], col+dir[i][1]);
	      <B><FONT COLOR="#A020F0">for</FONT></B> (max=i=0; i &lt; 4; i++) {
		dev[i] = abs((val[i] &lt;&lt; 2) - sum);
		<B><FONT COLOR="#A020F0">if</FONT></B> (dev[max] &lt; dev[i]) max = i;
	      }
	      RAW(row,col) = (sum - val[max])/3.0 + 0.5;
	    } <B><FONT COLOR="#A020F0">else</FONT></B> {
	      <B><FONT COLOR="#A020F0">for</FONT></B> (sum=0, i=8; i &lt; 12; i++)
		sum += raw (row+dir[i][0], col+dir[i][1]);
	      RAW(row,col) = 0.5 + sum * 0.0732233 +
		(raw(row,col-2) + raw(row,col+2)) * 0.3535534;
	    }
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (type == 129) {			<I><FONT COLOR="#B22222">/* Bad pixel */</FONT></I>
	  <B><FONT COLOR="#A020F0">if</FONT></B> (row &gt;= raw_height) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  j = (FC(row-top_margin,col-left_margin) != 1) * 4;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (sum=0, i=j; i &lt; j+8; i++)
	    sum += raw (row+dir[i][0], col+dir[i][1]);
	  RAW(row,col) = (sum + 4) &gt;&gt; 3;
	}
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x401) {			<I><FONT COLOR="#B22222">/* All-color flat fields */</FONT></I>
      phase_one_flat_field (1, 2);
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x416 || tag == 0x410) {
      phase_one_flat_field (0, 2);
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x40b) {			<I><FONT COLOR="#B22222">/* Red+blue flat field */</FONT></I>
      phase_one_flat_field (0, 4);
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x412) {
      fseek (ifp, 36, SEEK_CUR);
      diff = abs (get2() - ph1.tag_21a);
      <B><FONT COLOR="#A020F0">if</FONT></B> (mindiff &gt; diff) {
	mindiff = diff;
	off_412 = ftell(ifp) - 38;
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x41f &amp;&amp; !qlin_applied) { <I><FONT COLOR="#B22222">/* Quadrant linearization */</FONT></I>
      ushort lc[2][2][16], ref[16];
      <B><FONT COLOR="#228B22">int</FONT></B> qr, qc;
      <B><FONT COLOR="#A020F0">for</FONT></B> (qr = 0; qr &lt; 2; qr++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (qc = 0; qc &lt; 2; qc++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 16; i++)
	    lc[qr][qc][i] = get4();
      <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 16; i++) {
	<B><FONT COLOR="#228B22">int</FONT></B> v = 0;
	<B><FONT COLOR="#A020F0">for</FONT></B> (qr = 0; qr &lt; 2; qr++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (qc = 0; qc &lt; 2; qc++)
	    v += lc[qr][qc][i];
	ref[i] = (v + 2) &gt;&gt; 2;
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (qr = 0; qr &lt; 2; qr++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (qc = 0; qc &lt; 2; qc++) {
	  <B><FONT COLOR="#228B22">int</FONT></B> cx[19], cf[19];
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 16; i++) {
	    cx[1+i] = lc[qr][qc][i];
	    cf[1+i] = ref[i];
	  }
	  cx[0] = cf[0] = 0;
	  cx[17] = cf[17] = ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) ref[15] * 65535) / lc[qr][qc][15];
	  cx[18] = cf[18] = 65535;
	  cubic_spline(cx, cf, 19);
	  <B><FONT COLOR="#A020F0">for</FONT></B> (row = (qr ? ph1.split_row : 0);
	       row &lt; (qr ? raw_height : ph1.split_row); row++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (col = (qc ? ph1.split_col : 0);
		 col &lt; (qc ? raw_width : ph1.split_col); col++)
	      RAW(row,col) = curve[RAW(row,col)];
	}
      }
      qlin_applied = 1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x41e &amp;&amp; !qmult_applied) { <I><FONT COLOR="#B22222">/* Quadrant multipliers */</FONT></I>
      <B><FONT COLOR="#228B22">float</FONT></B> qmult[2][2] = { { 1, 1 }, { 1, 1 } };
      get4(); get4(); get4(); get4();
      qmult[0][0] = 1.0 + getreal(11);
      get4(); get4(); get4(); get4(); get4();
      qmult[0][1] = 1.0 + getreal(11);
      get4(); get4(); get4();
      qmult[1][0] = 1.0 + getreal(11);
      get4(); get4(); get4();
      qmult[1][1] = 1.0 + getreal(11);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
	  i = qmult[row &gt;= ph1.split_row][col &gt;= ph1.split_col] * RAW(row,col);
	  RAW(row,col) = LIM(i,0,65535);
	}
      qmult_applied = 1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x431 &amp;&amp; !qmult_applied) { <I><FONT COLOR="#B22222">/* Quadrant combined */</FONT></I>
      ushort lc[2][2][7], ref[7];
      <B><FONT COLOR="#228B22">int</FONT></B> qr, qc;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 7; i++)
	ref[i] = get4();
      <B><FONT COLOR="#A020F0">for</FONT></B> (qr = 0; qr &lt; 2; qr++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (qc = 0; qc &lt; 2; qc++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 7; i++)
	    lc[qr][qc][i] = get4();
      <B><FONT COLOR="#A020F0">for</FONT></B> (qr = 0; qr &lt; 2; qr++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (qc = 0; qc &lt; 2; qc++) {
	  <B><FONT COLOR="#228B22">int</FONT></B> cx[9], cf[9];
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; 7; i++) {
	    cx[1+i] = ref[i];
	    cf[1+i] = ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) ref[i] * lc[qr][qc][i]) / 10000;
	  }
	  cx[0] = cf[0] = 0;
	  cx[8] = cf[8] = 65535;
	  cubic_spline(cx, cf, 9);
	  <B><FONT COLOR="#A020F0">for</FONT></B> (row = (qr ? ph1.split_row : 0);
	       row &lt; (qr ? raw_height : ph1.split_row); row++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (col = (qc ? ph1.split_col : 0);
		 col &lt; (qc ? raw_width : ph1.split_col); col++)
	      RAW(row,col) = curve[RAW(row,col)];
	}
      }
      qmult_applied = 1;
      qlin_applied = 1;
    }
    fseek (ifp, save, SEEK_SET);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (off_412) {
    fseek (ifp, off_412, SEEK_SET);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 9; i++) head[i] = get4() &amp; 0x7fff;
    yval[0] = (<B><FONT COLOR="#228B22">float</FONT></B> *) calloc (head[1]*head[3] + head[2]*head[4], 6);
    merror (yval[0], <B><FONT COLOR="#BC8F8F">&quot;phase_one_correct()&quot;</FONT></B>);
    yval[1] = (<B><FONT COLOR="#228B22">float</FONT></B>  *) (yval[0] + head[1]*head[3]);
    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);
    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);
    get2();
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; head[i+1]*head[i+3]; j++)
	yval[i][j] = getreal(11);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; head[i+1]*head[i+3]; j++)
	xval[i][j] = get2();
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
	cfrac = (<B><FONT COLOR="#228B22">float</FONT></B>) col * head[3] / raw_width;
	cfrac -= cip = cfrac;
	num = RAW(row,col) * 0.5;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=cip; i &lt; cip+2; i++) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (k=j=0; j &lt; head[1]; j++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (num &lt; xval[0][k = head[1]*i+j]) <B><FONT COLOR="#A020F0">break</FONT></B>;
	  frac = (j == 0 || j == head[1]) ? 0 :
		(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);
	  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);
	}
	i = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;
	RAW(row,col) = LIM(i,0,65535);
      }
    free (yval[0]);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">phase_one_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> a, b, i;
  ushort akey, bkey, mask;

  fseek (ifp, ph1.key_off, SEEK_SET);
  akey = get2();
  bkey = get2();
  mask = ph1.format == 1 ? 0x5555:0x1354;
  fseek (ifp, data_offset, SEEK_SET);
  read_shorts (raw_image, raw_width*raw_height);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ph1.format)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; raw_width*raw_height; i+=2) {
      a = raw_image[i+0] ^ akey;
      b = raw_image[i+1] ^ bkey;
      raw_image[i+0] = (a &amp; mask) | (b &amp; ~mask);
      raw_image[i+1] = (b &amp; mask) | (a &amp; ~mask);
    }
}

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">ph1_bithuff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> nbits, ushort *huff)
{
  <B><FONT COLOR="#228B22">static</FONT></B> UINT64 bitbuf=0;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> vbits=0;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> c;

  <B><FONT COLOR="#A020F0">if</FONT></B> (nbits == -1)
    <B><FONT COLOR="#A020F0">return</FONT></B> bitbuf = vbits = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (nbits == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (vbits &lt; nbits) {
    bitbuf = bitbuf &lt;&lt; 32 | get4();
    vbits += 32;
  }
  c = bitbuf &lt;&lt; (64-vbits) &gt;&gt; (64-nbits);
  <B><FONT COLOR="#A020F0">if</FONT></B> (huff) {
    vbits -= huff[c] &gt;&gt; 8;
    <B><FONT COLOR="#A020F0">return</FONT></B> (uchar) huff[c];
  }
  vbits -= nbits;
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
}
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ph1_bits</FONT></B>(n) ph1_bithuff(n,0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ph1_huff</FONT></B>(h) ph1_bithuff(*h,h+1)

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">phase_one_load_raw_c</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> length[] = { 8,7,6,9,11,10,5,12,14,13 };
  <B><FONT COLOR="#228B22">int</FONT></B> *offset, len[2], pred[2], row, col, i, j;
  ushort *pixel;
  <B><FONT COLOR="#228B22">short</FONT></B> (*cblack)[2], (*rblack)[2];

  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;phase_one_load_raw_c()&quot;</FONT></B>);
  offset = (<B><FONT COLOR="#228B22">int</FONT></B> *) (pixel + raw_width);
  fseek (ifp, strip_offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    offset[row] = get4();
  cblack = (<B><FONT COLOR="#228B22">short</FONT></B> (*)[2]) (offset + raw_height);
  fseek (ifp, ph1.black_col, SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ph1.black_col)
    read_shorts ((ushort *) cblack[0], raw_height*2);
  rblack = cblack + raw_height;
  fseek (ifp, ph1.black_row, SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ph1.black_row)
    read_shorts ((ushort *) rblack[0], raw_width*2);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 256; i++)
    curve[i] = i*i / 3.969 + 0.5;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    fseek (ifp, data_offset + offset[row], SEEK_SET);
    ph1_bits(-1);
    pred[0] = pred[1] = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &gt;= (raw_width &amp; -8))
	len[0] = len[1] = 14;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((col &amp; 7) == 0)
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 5 &amp;&amp; !ph1_bits(1); j++);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (j--) len[i] = length[j*2 + ph1_bits(1)];
	}
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i = len[col &amp; 1]) == 14)
	pixel[col] = pred[col &amp; 1] = ph1_bits(16);
      <B><FONT COLOR="#A020F0">else</FONT></B>
	pixel[col] = pred[col &amp; 1] += ph1_bits(i) + 1 - (1 &lt;&lt; (i - 1));
      <B><FONT COLOR="#A020F0">if</FONT></B> (pred[col &amp; 1] &gt;&gt; 16) derror();
      <B><FONT COLOR="#A020F0">if</FONT></B> (ph1.format == 5 &amp;&amp; pixel[col] &lt; 256)
	pixel[col] = curve[pixel[col]];
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      i = (pixel[col] &lt;&lt; 2*(ph1.format != 8)) - ph1.black
	+ cblack[row][col &gt;= ph1.split_col]
	+ rblack[col][row &gt;= ph1.split_row];
      <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 0) RAW(row,col) = i;
    }
  }
  free (pixel);
  maximum = 0xfffc - ph1.black;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">hasselblad_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;
  <B><FONT COLOR="#228B22">int</FONT></B> shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> upix, urow, ucol;
  ushort *ip;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!ljpeg_start (&amp;jh, 0)) <B><FONT COLOR="#A020F0">return</FONT></B>;
  order = 0x4949;
  ph1_bits(-1);
  back[4] = (<B><FONT COLOR="#228B22">int</FONT></B> *) calloc (raw_width, 3*<B><FONT COLOR="#A020F0">sizeof</FONT></B> **back);
  merror (back[4], <B><FONT COLOR="#BC8F8F">&quot;hasselblad_load_raw()&quot;</FONT></B>);
  FORC3 back[c] = back[4] + c*raw_width;
  cblack[6] &gt;&gt;= sh = tiff_samples &gt; 1;
  shot = LIM(shot_select, 1, tiff_samples) - 1;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    FORC4 back[(c+3) &amp; 3] = back[c];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col+=2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (s=0; s &lt; tiff_samples*2; s+=2) {
	FORC(2) len[c] = ph1_huff(jh.huff[0]);
	FORC(2) {
	  diff[s+c] = ph1_bits(len[c]);
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((diff[s+c] &amp; (1 &lt;&lt; (len[c]-1))) == 0)
	    diff[s+c] -= (1 &lt;&lt; len[c]) - 1;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (diff[s+c] == 65535) diff[s+c] = -32768;
	}
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (s=col; s &lt; col+2; s++) {
	pred = 0x8000 + load_flags;
	<B><FONT COLOR="#A020F0">if</FONT></B> (col) pred = back[2][s-2];
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &amp;&amp; row &gt; 1) <B><FONT COLOR="#A020F0">switch</FONT></B> (jh.psv) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">11</FONT></B>: pred += back[0][s]/2 - back[0][s-2]/2;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	f = (row &amp; 1)*3 ^ ((col+s) &amp; 1);
	FORC (tiff_samples) {
	  pred += diff[(s &amp; 1)*tiff_samples+c];
	  upix = pred &gt;&gt; sh &amp; 0xffff;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_image &amp;&amp; c == shot)
	    RAW(row,s) = upix;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (image) {
	    urow = row-top_margin  + (c &amp; 1);
	    ucol = col-left_margin - ((c &gt;&gt; 1) &amp; 1);
	    ip = &amp;image[urow*width+ucol][f];
	    <B><FONT COLOR="#A020F0">if</FONT></B> (urow &lt; height &amp;&amp; ucol &lt; width)
	      *ip = c &lt; 4 ? upix : (*ip + upix) &gt;&gt; 1;
	  }
	}
	back[2][s] = pred;
      }
    }
  }
  free (back[4]);
  ljpeg_end (&amp;jh);
  <B><FONT COLOR="#A020F0">if</FONT></B> (image) mix_green = 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">leaf_hdr_load_raw</FONT></B>()
{
  ushort *pixel=0;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> tile=0, r, c, row, col;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!filters) {
    pixel = (ushort *) calloc (raw_width, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
    merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;leaf_hdr_load_raw()&quot;</FONT></B>);
  }
  FORC(tiff_samples)
    <B><FONT COLOR="#A020F0">for</FONT></B> (r=0; r &lt; raw_height; r++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (r % tile_length == 0) {
	fseek (ifp, data_offset + 4*tile++, SEEK_SET);
	fseek (ifp, get4(), SEEK_SET);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (filters &amp;&amp; c != shot_select) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (filters) pixel = raw_image + r*raw_width;
      read_shorts (pixel, raw_width);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!filters &amp;&amp; (row = r - top_margin) &lt; height)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
	  image[row*width+col][c] = pixel[col+left_margin];
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!filters) {
    maximum = 0xffff;
    raw_color = 1;
    free (pixel);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">unpacked_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, bits=0;

  <B><FONT COLOR="#A020F0">while</FONT></B> (1 &lt;&lt; ++bits &lt; maximum);
  read_shorts (raw_image, raw_width*raw_height);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++)
      <B><FONT COLOR="#A020F0">if</FONT></B> ((RAW(row,col) &gt;&gt;= load_flags) &gt;&gt; bits
	&amp;&amp; (<B><FONT COLOR="#228B22">unsigned</FONT></B>) (row-top_margin) &lt; height
	&amp;&amp; (<B><FONT COLOR="#228B22">unsigned</FONT></B>) (col-left_margin) &lt; width) derror();
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">sinar_4shot_load_raw</FONT></B>()
{
  ushort *pixel;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> shot, row, col, r, c;

  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_image) {
    shot = LIM (shot_select, 1, 4) - 1;
    fseek (ifp, data_offset + shot*4, SEEK_SET);
    fseek (ifp, get4(), SEEK_SET);
    unpacked_load_raw();
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  pixel = (ushort *) calloc (raw_width, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;sinar_4shot_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (shot=0; shot &lt; 4; shot++) {
    fseek (ifp, data_offset + shot*4, SEEK_SET);
    fseek (ifp, get4(), SEEK_SET);
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
      read_shorts (pixel, raw_width);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((r = row-top_margin - (shot &gt;&gt; 1 &amp; 1)) &gt;= height) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((c = col-left_margin - (shot &amp; 1)) &gt;= width) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	image[r*width+c][(row &amp; 1)*3 ^ (~col &amp; 1)] = pixel[col];
      }
    }
  }
  free (pixel);
  mix_green = 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">imacon_full_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!image) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      read_shorts (image[row*width+col], 3);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">packed_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;
  UINT64 bitbuf=0;

  bwide = raw_width * tiff_bps / 8;
  bwide += bwide &amp; load_flags &gt;&gt; 9;
  rbits = bwide * 8 - raw_width * tiff_bps;
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags &amp; 1) bwide = bwide * 16 / 15;
  bite = 8 + (load_flags &amp; 56);
  half = (raw_height+1) &gt;&gt; 1;
  <B><FONT COLOR="#A020F0">for</FONT></B> (irow=0; irow &lt; raw_height; irow++) {
    row = irow;
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags &amp; 2 &amp;&amp;
	(row = irow % half * 2 + irow / half) == 1 &amp;&amp;
	load_flags &amp; 4) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (vbits=0, tiff_compress)
	fseek (ifp, data_offset - (-half*bwide &amp; -2048), SEEK_SET);
      <B><FONT COLOR="#A020F0">else</FONT></B> {
	fseek (ifp, 0, SEEK_END);
	fseek (ifp, ftell(ifp) &gt;&gt; 3 &lt;&lt; 2, SEEK_SET);
      }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (vbits -= tiff_bps; vbits &lt; 0; vbits += bite) {
	bitbuf &lt;&lt;= bite;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; bite; i+=8)
	  bitbuf |= ((UINT64) fgetc(ifp) &lt;&lt; i);
      }
      val = bitbuf &lt;&lt; (64-tiff_bps-vbits) &gt;&gt; (64-tiff_bps);
      RAW(row,col ^ (load_flags &gt;&gt; 6 &amp; 3)) = val;
      <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags &amp; 1 &amp;&amp; (col % 10) == 9 &amp;&amp; fgetc(ifp) &amp;&amp;
	row &lt; height+top_margin &amp;&amp; col &lt; width+left_margin) derror();
    }
    vbits -= rbits;
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">nokia_load_raw</FONT></B>()
{
  uchar  *data,  *dp;
  <B><FONT COLOR="#228B22">int</FONT></B> rev, dwide, row, col, c;
  <B><FONT COLOR="#228B22">double</FONT></B> sum[]={0,0};

  rev = 3 * (order == 0x4949);
  dwide = (raw_width * 5 + 1) / 4;
  data = (uchar *) malloc (dwide*2);
  merror (data, <B><FONT COLOR="#BC8F8F">&quot;nokia_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (data+dwide, 1, dwide, ifp) &lt; dwide) derror();
    FORC(dwide) data[c] = data[dwide+(c ^ rev)];
    <B><FONT COLOR="#A020F0">for</FONT></B> (dp=data, col=0; col &lt; raw_width; dp+=5, col+=4)
      FORC4 RAW(row,col+c) = (dp[c] &lt;&lt; 2) | (dp[4] &gt;&gt; (c &lt;&lt; 1) &amp; 3);
  }
  free (data);
  maximum = 0x3ff;
  <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;OmniVision&quot;</FONT></B>)) <B><FONT COLOR="#A020F0">return</FONT></B>;
  row = raw_height/2;
  FORC(width-1) {
    sum[ c &amp; 1] += SQR(RAW(row,c)-RAW(row+1,c+1));
    sum[~c &amp; 1] += SQR(RAW(row+1,c)-RAW(row,c+1));
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (sum[1] &gt; sum[0]) filters = 0x4b4b4b4b;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_rmf_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, bits, orow, ocol, c;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width-2; col+=3) {
      bits = get4();
      FORC3 {
	orow = row;
	<B><FONT COLOR="#A020F0">if</FONT></B> ((ocol = col+c-4) &lt; 0) {
	  ocol += raw_width;
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((orow -= 2) &lt; 0)
	    orow += raw_height;
	}
	RAW(orow,ocol) = curve[bits &gt;&gt; (10*c+2) &amp; 0x3ff];
      }
    }
  maximum = curve[0x3ff];
}

<B><FONT COLOR="#228B22">unsigned</FONT></B> CLASS <B><FONT COLOR="#0000FF">pana_bits</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> nbits)
{
  <B><FONT COLOR="#228B22">static</FONT></B> uchar buf[0x4000];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> vbits;
  <B><FONT COLOR="#228B22">int</FONT></B> byte;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!nbits) <B><FONT COLOR="#A020F0">return</FONT></B> vbits=0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!vbits) {
    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);
    fread (buf, 1, load_flags, ifp);
  }
  vbits = (vbits - nbits) &amp; 0x1ffff;
  byte = vbits &gt;&gt; 3 ^ 0x3ff0;
  <B><FONT COLOR="#A020F0">return</FONT></B> (buf[byte] | buf[byte+1] &lt;&lt; 8) &gt;&gt; (vbits &amp; 7) &amp; ~(-1 &lt;&lt; nbits);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">panasonic_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, i, j, sh=0, pred[2], nonz[2];

  pana_bits(0);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i = col % 14) == 0)
	pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
      <B><FONT COLOR="#A020F0">if</FONT></B> (i % 3 == 2) sh = 4 &gt;&gt; (3 - pana_bits(2));
      <B><FONT COLOR="#A020F0">if</FONT></B> (nonz[i &amp; 1]) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((j = pana_bits(8))) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((pred[i &amp; 1] -= 0x80 &lt;&lt; sh) &lt; 0 || sh == 4)
	       pred[i &amp; 1] &amp;= ~(-1 &lt;&lt; sh);
	  pred[i &amp; 1] += j &lt;&lt; sh;
	}
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((nonz[i &amp; 1] = pana_bits(8)) || i &gt; 11)
	pred[i &amp; 1] = nonz[i &amp; 1] &lt;&lt; 4 | pana_bits(4);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((RAW(row,col) = pred[col &amp; 1]) &gt; 4098 &amp;&amp; col &lt; width) derror();
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">olympus_load_raw</FONT></B>()
{
  ushort huff[4096];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, nbits, sign, low, high, i, c, w, n, nw;
  <B><FONT COLOR="#228B22">int</FONT></B> acarry[2][3], *carry, pred, diff;

  huff[n=0] = 0xc0c;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=12; i--; )
    FORC(2048 &gt;&gt; i) huff[++n] = (i+1) &lt;&lt; 8 | i;
  fseek (ifp, 7, SEEK_CUR);
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    memset (acarry, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> acarry);
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      carry = acarry[col &amp; 1];
      i = 2 * (carry[2] &lt; 3);
      <B><FONT COLOR="#A020F0">for</FONT></B> (nbits=2+i; (ushort) carry[0] &gt;&gt; (nbits+i); nbits++);
      low = (sign = getbits(3)) &amp; 3;
      sign = sign &lt;&lt; 29 &gt;&gt; 31;
      <B><FONT COLOR="#A020F0">if</FONT></B> ((high = getbithuff(12,huff)) == 12)
	high = getbits(16-nbits) &gt;&gt; 1;
      carry[0] = (high &lt;&lt; nbits) | getbits(nbits);
      diff = (carry[0] ^ sign) + carry[1];
      carry[1] = (diff*3 + carry[1]) &gt;&gt; 5;
      carry[2] = carry[0] &gt; 16 ? 0 : carry[2]+1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &gt;= width) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; 2 &amp;&amp; col &lt; 2) pred = 0;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; 2) pred = RAW(row,col-2);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) pred = RAW(row-2,col);
      <B><FONT COLOR="#A020F0">else</FONT></B> {
	w  = RAW(row,col-2);
	n  = RAW(row-2,col);
	nw = RAW(row-2,col-2);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((w &lt; nw &amp;&amp; nw &lt; n) || (n &lt; nw &amp;&amp; nw &lt; w)) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (ABS(w-nw) &gt; 32 || ABS(n-nw) &gt; 32)
	    pred = w + n - nw;
	  <B><FONT COLOR="#A020F0">else</FONT></B> pred = (w + n) &gt;&gt; 1;
	} <B><FONT COLOR="#A020F0">else</FONT></B> pred = ABS(w-nw) &gt; ABS(n-nw) ? w : n;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> ((RAW(row,col) = pred + ((diff &lt;&lt; 2) | low)) &gt;&gt; 12) derror();
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">canon_crx_load_raw</FONT></B>()
{
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">fuji_xtrans_load_raw</FONT></B>()
{
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">minolta_rd175_load_raw</FONT></B>()
{
  uchar pixel[768];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> irow, box, row, col;

  <B><FONT COLOR="#A020F0">for</FONT></B> (irow=0; irow &lt; 1481; irow++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, 1, 768, ifp) &lt; 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box &lt; 12) ? box | 1 : (box-12)*2);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (irow) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1477</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1479</FONT></B>: <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1476</FONT></B>: row = 984; <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1480</FONT></B>: row = 985; <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1478</FONT></B>: row = 985; box = 1;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((box &lt; 12) &amp;&amp; (box &amp; 1)) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; 1533; col++, row ^= 1)
	<B><FONT COLOR="#A020F0">if</FONT></B> (col != 1) RAW(row,col) = (col+1) &amp; 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] &lt;&lt; 1;
      RAW(row,1)    = pixel[1]   &lt;&lt; 1;
      RAW(row,1533) = pixel[765] &lt;&lt; 1;
    } <B><FONT COLOR="#A020F0">else</FONT></B>
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=row &amp; 1; col &lt; 1534; col+=2)
	RAW(row,col) = pixel[col/2] &lt;&lt; 1;
  }
  maximum = 0xff &lt;&lt; 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">quicktake_100_load_raw</FONT></B>()
{
  uchar pixel[484][644];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> gstep[16] =
  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> rstep[6][4] =
  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },
    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> curve[256] =
  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,
    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,
    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,
    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,
    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,
    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,
    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,
    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,
    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,
    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,
    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,
    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };
  <B><FONT COLOR="#228B22">int</FONT></B> rb, row, col, sharp, val=0;

  getbits(-1);
  memset (pixel, 0x80, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pixel);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height+2; row++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2+(row &amp; 1); col &lt; width+2; col+=2) {
      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +
		pixel[row][col-2]) &gt;&gt; 2) + gstep[getbits(4)];
      pixel[row][col] = val = LIM(val,0,255);
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 4)
	pixel[row][col-2] = pixel[row+1][~row &amp; 1] = val;
      <B><FONT COLOR="#A020F0">if</FONT></B> (row == 2)
	pixel[row-1][col+1] = pixel[row-1][col+3] = val;
    }
    pixel[row][col] = val;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (rb=0; rb &lt; 2; rb++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=2+rb; row &lt; height+2; row+=2)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=3-(row &amp; 1); col &lt; width+2; col+=2) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; 4 || col &lt; 4) sharp = 2;
	<B><FONT COLOR="#A020F0">else</FONT></B> {
	  val = ABS(pixel[row-2][col] - pixel[row][col-2])
	      + ABS(pixel[row-2][col] - pixel[row-2][col-2])
	      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);
	  sharp = val &lt;  4 ? 0 : val &lt;  8 ? 1 : val &lt; 16 ? 2 :
		  val &lt; 32 ? 3 : val &lt; 48 ? 4 : 5;
	}
	val = ((pixel[row-2][col] + pixel[row][col-2]) &gt;&gt; 1)
	      + rstep[sharp][getbits(2)];
	pixel[row][col] = val = LIM(val,0,255);
	<B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; 4) pixel[row-2][col+2] = val;
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 4) pixel[row+2][col-2] = val;
      }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height+2; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=3-(row &amp; 1); col &lt; width+2; col+=2) {
      val = ((pixel[row][col-1] + (pixel[row][col] &lt;&lt; 2) +
	      pixel[row][col+1]) &gt;&gt; 1) - 0x100;
      pixel[row][col] = LIM(val,0,255);
    }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      RAW(row,col) = curve[pixel[row+2][col+2]];
  maximum = 0x3ff;
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">radc_token</FONT></B>(tree) ((signed char) getbithuff(8,huff[tree]))

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FORYX</FONT> for (y=1; y &lt; 3; y++) for (x=col+1; x &gt;= col; x--)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">PREDICTOR</FONT> (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \
: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_radc_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> src[] = {
    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,
    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,
    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,
    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,
    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,
    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,
    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,
    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,
    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,
    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,
    1,0, 2,2, 2,-2,
    1,-3, 1,3,
    2,-17, 2,-5, 2,5, 2,17,
    2,-7, 2,2, 2,9, 2,18,
    2,-18, 2,-9, 2,-2, 2,7,
    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,
    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,
    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37
  };
  ushort huff[19][256];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;
  <B><FONT COLOR="#228B22">short</FONT></B> last[3] = { 16,16,16 }, mul[3], buf[3][3][386];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> ushort pt[] =
    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=2; i &lt; 12; i+=2)
    <B><FONT COLOR="#A020F0">for</FONT></B> (c=pt[i-2]; c &lt;= pt[i]; c++)
      curve[c] = (<B><FONT COLOR="#228B22">float</FONT></B>)
	(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;
  <B><FONT COLOR="#A020F0">for</FONT></B> (s=i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> src; i+=2)
    FORC(256 &gt;&gt; src[i])
      ((ushort *)huff)[s++] = src[i] &lt;&lt; 8 | (uchar) src[i+1];
  s = kodak_cbpp == 243 ? 2 : 3;
  FORC(256) huff[18][c] = (8-s) &lt;&lt; 8 | c &gt;&gt; s &lt;&lt; s | 1 &lt;&lt; (s-1);
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(buf)/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">short</FONT></B>); i++)
    ((<B><FONT COLOR="#228B22">short</FONT></B> *)buf)[i] = 2048;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row+=4) {
    FORC3 mul[c] = getbits(6);
    FORC3 {
      val = ((0x1000000/last[c] + 0x7ff) &gt;&gt; 12) * mul[c];
      s = val &gt; 65564 ? 10:12;
      x = ~(-1 &lt;&lt; (s-1));
      val &lt;&lt;= 12-s;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(buf[0])/<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">short</FONT></B>); i++)
	((<B><FONT COLOR="#228B22">short</FONT></B> *)buf[c])[i] = (((<B><FONT COLOR="#228B22">short</FONT></B> *)buf[c])[i] * val + x) &gt;&gt; s;
      last[c] = mul[c];
      <B><FONT COLOR="#A020F0">for</FONT></B> (r=0; r &lt;= !c; r++) {
	buf[c][1][width/2] = buf[c][2][width/2] = mul[c] &lt;&lt; 7;
	<B><FONT COLOR="#A020F0">for</FONT></B> (tree=1, col=width/2; col &gt; 0; ) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((tree = radc_token(tree))) {
	    col -= 2;
	    <B><FONT COLOR="#A020F0">if</FONT></B> (tree == 8)
	      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];
	    <B><FONT COLOR="#A020F0">else</FONT></B>
	      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;
	  } <B><FONT COLOR="#A020F0">else</FONT></B>
	    <B><FONT COLOR="#A020F0">do</FONT></B> {
	      nreps = (col &gt; 2) ? radc_token(9) + 1 : 1;
	      <B><FONT COLOR="#A020F0">for</FONT></B> (rep=0; rep &lt; 8 &amp;&amp; rep &lt; nreps &amp;&amp; col &gt; 0; rep++) {
		col -= 2;
		FORYX buf[c][y][x] = PREDICTOR;
		<B><FONT COLOR="#A020F0">if</FONT></B> (rep &amp; 1) {
		  step = radc_token(10) &lt;&lt; 4;
		  FORYX buf[c][y][x] += step;
		}
	      }
	    } <B><FONT COLOR="#A020F0">while</FONT></B> (nreps == 9);
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (y=0; y &lt; 2; y++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (x=0; x &lt; width/2; x++) {
	    val = (buf[c][y+1][x] &lt;&lt; 4) / mul[c];
	    <B><FONT COLOR="#A020F0">if</FONT></B> (val &lt; 0) val = 0;
	    <B><FONT COLOR="#A020F0">if</FONT></B> (c) RAW(row+y*2+c-1,x*2+2-c) = val;
	    <B><FONT COLOR="#A020F0">else</FONT></B>   RAW(row+r*2+y,x*2+y) = val;
	  }
	memcpy (buf[c][0]+!c, buf[c][2], <B><FONT COLOR="#A020F0">sizeof</FONT></B> buf[c][0]-2*!c);
      }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (y=row; y &lt; row+4; y++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (x=0; x &lt; width; x++)
	<B><FONT COLOR="#A020F0">if</FONT></B> ((x+y) &amp; 1) {
	  r = x ? x-1 : x+1;
	  s = x+1 &lt; width ? x+1 : x-1;
	  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (val &lt; 0) val = 0;
	  RAW(y,x) = val;
	}
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; height*width; i++)
    raw_image[i] = curve[raw_image[i]];
  maximum = 0x3fff;
}

#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">FORYX</FONT>
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">PREDICTOR</FONT>

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NO_JPEG</FONT>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_jpeg_load_raw</FONT></B>() {}
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">lossy_dng_load_raw</FONT></B>() {}
#<B><FONT COLOR="#5F9EA0">else</FONT></B>

<B><FONT COLOR="#0000FF">METHODDEF</FONT></B>(boolean)
<B><FONT COLOR="#0000FF">fill_input_buffer</FONT></B> (j_decompress_ptr cinfo)
{
  <B><FONT COLOR="#228B22">static</FONT></B> uchar jpeg_buffer[4096];
  size_t nbytes;

  nbytes = fread (jpeg_buffer, 1, 4096, ifp);
  swab (jpeg_buffer, jpeg_buffer, nbytes);
  cinfo-&gt;src-&gt;next_input_byte = jpeg_buffer;
  cinfo-&gt;src-&gt;bytes_in_buffer = nbytes;
  <B><FONT COLOR="#A020F0">return</FONT></B> TRUE;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_jpeg_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> jpeg_decompress_struct cinfo;
  <B><FONT COLOR="#228B22">struct</FONT></B> jpeg_error_mgr jerr;
  JSAMPARRAY buf;
  JSAMPLE (*pixel)[3];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col;

  cinfo.err = jpeg_std_error (&amp;jerr);
  jpeg_create_decompress (&amp;cinfo);
  jpeg_stdio_src (&amp;cinfo, ifp);
  cinfo.src-&gt;fill_input_buffer = fill_input_buffer;
  jpeg_read_header (&amp;cinfo, TRUE);
  jpeg_start_decompress (&amp;cinfo);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((cinfo.output_width      != width  ) ||
      (cinfo.output_height*2   != height ) ||
      (cinfo.output_components != 3      )) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: incorrect JPEG dimensions\n&quot;</FONT></B>), ifname);
    jpeg_destroy_decompress (&amp;cinfo);
    longjmp (failure, 3);
  }
  buf = (*cinfo.mem-&gt;alloc_sarray)
		((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, width*3, 1);

  <B><FONT COLOR="#A020F0">while</FONT></B> (cinfo.output_scanline &lt; cinfo.output_height) {
    row = cinfo.output_scanline * 2;
    jpeg_read_scanlines (&amp;cinfo, buf, 1);
    pixel = (JSAMPLE (*)[3]) buf[0];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col+=2) {
      RAW(row+0,col+0) = pixel[col+0][1] &lt;&lt; 1;
      RAW(row+1,col+1) = pixel[col+1][1] &lt;&lt; 1;
      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];
      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];
    }
  }
  jpeg_finish_decompress (&amp;cinfo);
  jpeg_destroy_decompress (&amp;cinfo);
  maximum = 0xff &lt;&lt; 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">gamma_curve</FONT></B> (<B><FONT COLOR="#228B22">double</FONT></B> pwr, <B><FONT COLOR="#228B22">double</FONT></B> ts, <B><FONT COLOR="#228B22">int</FONT></B> mode, <B><FONT COLOR="#228B22">int</FONT></B> imax);

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">lossy_dng_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> jpeg_decompress_struct cinfo;
  <B><FONT COLOR="#228B22">struct</FONT></B> jpeg_error_mgr jerr;
  JSAMPARRAY buf;
  JSAMPLE (*pixel)[3];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> sorder=order, ntags, opcode, deg, i, j, c;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> save=data_offset-4, trow=0, tcol=0, row, col;
  ushort cur[3][256];
  <B><FONT COLOR="#228B22">double</FONT></B> coeff[9], tot;

  <B><FONT COLOR="#A020F0">if</FONT></B> (meta_offset) {
    fseek (ifp, meta_offset, SEEK_SET);
    order = 0x4d4d;
    ntags = get4();
    <B><FONT COLOR="#A020F0">while</FONT></B> (ntags--) {
      opcode = get4(); get4(); get4();
      <B><FONT COLOR="#A020F0">if</FONT></B> (opcode != 8)
      { fseek (ifp, get4(), SEEK_CUR); <B><FONT COLOR="#A020F0">continue</FONT></B>; }
      fseek (ifp, 20, SEEK_CUR);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((c = get4()) &gt; 2) <B><FONT COLOR="#A020F0">break</FONT></B>;
      fseek (ifp, 12, SEEK_CUR);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((deg = get4()) &gt; 8) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt;= deg &amp;&amp; i &lt; 9; i++)
	coeff[i] = getreal(12);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 256; i++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (tot=j=0; j &lt;= deg; j++)
	  tot += coeff[j] * pow(i/255.0, j);
	cur[c][i] = tot*0xffff;
      }
    }
    order = sorder;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    gamma_curve (1/2.4, 12.92, 1, 255);
    FORC3 memcpy (cur[c], curve, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cur[0]);
  }
  cinfo.err = jpeg_std_error (&amp;jerr);
  jpeg_create_decompress (&amp;cinfo);
  <B><FONT COLOR="#A020F0">while</FONT></B> (trow &lt; raw_height) {
    fseek (ifp, save+=4, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tile_length &lt; INT_MAX)
      fseek (ifp, get4(), SEEK_SET);
    jpeg_stdio_src (&amp;cinfo, ifp);
    jpeg_read_header (&amp;cinfo, TRUE);
    jpeg_start_decompress (&amp;cinfo);
    buf = (*cinfo.mem-&gt;alloc_sarray)
	((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);
    <B><FONT COLOR="#A020F0">while</FONT></B> (cinfo.output_scanline &lt; cinfo.output_height &amp;&amp;
	(row = trow + cinfo.output_scanline) &lt; height) {
      jpeg_read_scanlines (&amp;cinfo, buf, 1);
      pixel = (JSAMPLE (*)[3]) buf[0];
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; cinfo.output_width &amp;&amp; tcol+col &lt; width; col++) {
	FORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];
      }
    }
    jpeg_abort_decompress (&amp;cinfo);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tcol += tile_width) &gt;= raw_width)
      trow += tile_length + (tcol = 0);
  }
  jpeg_destroy_decompress (&amp;cinfo);
  maximum = 0xffff;
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_dc120_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> mul[4] = { 162, 192, 187,  92 };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> add[4] = {   0, 636, 424, 212 };
  uchar pixel[848];
  <B><FONT COLOR="#228B22">int</FONT></B> row, shift, col;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, 1, 848, ifp) &lt; 848) derror();
    shift = row * mul[row &amp; 3] + add[row &amp; 3];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      RAW(row,col) = (ushort) pixel[(col + shift) % 848];
  }
  maximum = 0xff;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">eight_bit_load_raw</FONT></B>()
{
  uchar *pixel;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> row, col;

  pixel = (uchar *) calloc (raw_width, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;eight_bit_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, 1, raw_width, ifp) &lt; raw_width) derror();
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++)
      RAW(row,col) = curve[pixel[col]];
  }
  free (pixel);
  maximum = curve[0xff];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_c330_load_raw</FONT></B>()
{
  uchar *pixel;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, y, cb, cr, rgb[3], c;

  pixel = (uchar *) calloc (raw_width, 2*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;kodak_c330_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, raw_width, 2, ifp) &lt; 2) derror();
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags &amp;&amp; (row &amp; 31) == 31)
      fseek (ifp, raw_width*32, SEEK_CUR);
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      y  = pixel[col*2];
      cb = pixel[(col*2 &amp; -4) | 1] - 128;
      cr = pixel[(col*2 &amp; -4) | 3] - 128;
      rgb[1] = y - ((cb + cr + 2) &gt;&gt; 2);
      rgb[2] = rgb[1] + cb;
      rgb[0] = rgb[1] + cr;
      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
    }
  }
  free (pixel);
  maximum = curve[0xff];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_c603_load_raw</FONT></B>()
{
  uchar *pixel;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, y, cb, cr, rgb[3], c;

  pixel = (uchar *) calloc (raw_width, 3*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;kodak_c603_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (~row &amp; 1)
      <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, raw_width, 3, ifp) &lt; 3) derror();
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      y  = pixel[width*2*(row &amp; 1) + col];
      cb = pixel[width + (col &amp; -2)]   - 128;
      cr = pixel[width + (col &amp; -2)+1] - 128;
      rgb[1] = y - ((cb + cr + 2) &gt;&gt; 2);
      rgb[2] = rgb[1] + cb;
      rgb[0] = rgb[1] + cr;
      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
    }
  }
  free (pixel);
  maximum = curve[0xff];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_262_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar kodak_tree[2][26] =
  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },
    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };
  ushort *huff[2];
  uchar *pixel;
  <B><FONT COLOR="#228B22">int</FONT></B> *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;

  FORC(2) huff[c] = make_decoder (kodak_tree[c]);
  ns = (raw_height+63) &gt;&gt; 5;
  pixel = (uchar *) malloc (raw_width*32 + ns*4);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;kodak_262_load_raw()&quot;</FONT></B>);
  strip = (<B><FONT COLOR="#228B22">int</FONT></B> *) (pixel + raw_width*32);
  order = 0x4d4d;
  FORC(ns) strip[c] = get4();
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> ((row &amp; 31) == 0) {
      fseek (ifp, strip[row &gt;&gt; 5], SEEK_SET);
      getbits(-1);
      pi = 0;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      chess = (row + col) &amp; 1;
      pi1 = chess ? pi-2           : pi-raw_width-1;
      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt;= chess) pi1 = -1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (pi1 &lt; 0) pi1 = pi2;
      <B><FONT COLOR="#A020F0">if</FONT></B> (pi2 &lt; 0) pi2 = pi1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (pi1 &lt; 0 &amp;&amp; col &gt; 1) pi1 = pi2 = pi-2;
      pred = (pi1 &lt; 0) ? 0 : (pixel[pi1] + pixel[pi2]) &gt;&gt; 1;
      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);
      <B><FONT COLOR="#A020F0">if</FONT></B> (val &gt;&gt; 8) derror();
      val = curve[pixel[pi++]];
      RAW(row,col) = val;
    }
  }
  free (pixel);
  FORC(2) free (huff[c]);
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_65000_decode</FONT></B> (<B><FONT COLOR="#228B22">short</FONT></B> *out, <B><FONT COLOR="#228B22">int</FONT></B> bsize)
{
  uchar c, blen[768];
  ushort raw[6];
  INT64 bitbuf=0;
  <B><FONT COLOR="#228B22">int</FONT></B> save, bits=0, i, j, len, diff;

  save = ftell(ifp);
  bsize = (bsize + 3) &amp; -4;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; bsize; i+=2) {
    c = fgetc(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((blen[i  ] = c &amp; 15) &gt; 12 ||
	(blen[i+1] = c &gt;&gt; 4) &gt; 12 ) {
      fseek (ifp, save, SEEK_SET);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; bsize; i+=8) {
	read_shorts (raw, 6);
	out[i  ] = raw[0] &gt;&gt; 12 &lt;&lt; 8 | raw[2] &gt;&gt; 12 &lt;&lt; 4 | raw[4] &gt;&gt; 12;
	out[i+1] = raw[1] &gt;&gt; 12 &lt;&lt; 8 | raw[3] &gt;&gt; 12 &lt;&lt; 4 | raw[5] &gt;&gt; 12;
	<B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 6; j++)
	  out[i+2+j] = raw[j] &amp; 0xfff;
      }
      <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> ((bsize &amp; 7) == 4) {
    bitbuf  = fgetc(ifp) &lt;&lt; 8;
    bitbuf += fgetc(ifp);
    bits = 16;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; bsize; i++) {
    len = blen[i];
    <B><FONT COLOR="#A020F0">if</FONT></B> (bits &lt; len) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 32; j+=8)
	bitbuf += (INT64) fgetc(ifp) &lt;&lt; (bits+(j^8));
      bits += 32;
    }
    diff = bitbuf &amp; (0xffff &gt;&gt; (16-len));
    bitbuf &gt;&gt;= len;
    bits -= len;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((diff &amp; (1 &lt;&lt; (len-1))) == 0)
      diff -= (1 &lt;&lt; len) - 1;
    out[i] = diff;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_65000_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">short</FONT></B> buf[256];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, len, pred[2], ret, i;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col+=256) {
      pred[0] = pred[1] = 0;
      len = MIN (256, width-col);
      ret = kodak_65000_decode (buf, len);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; len; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> ((RAW(row,col+i) =	curve[ret ? buf[i] :
		(pred[i &amp; 1] += buf[i])]) &gt;&gt; 12) derror();
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_ycbcr_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">short</FONT></B> buf[384], *bp;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];
  ushort *ip;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!image) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row+=2)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col+=128) {
      len = MIN (128, width-col);
      kodak_65000_decode (buf, len*3);
      y[0][1] = y[1][1] = cb = cr = 0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (bp=buf, i=0; i &lt; len; i+=2, bp+=2) {
	cb += bp[4];
	cr += bp[5];
	rgb[1] = -((cb + cr + 2) &gt;&gt; 2);
	rgb[2] = rgb[1] + cb;
	rgb[0] = rgb[1] + cr;
	<B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 2; j++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (k=0; k &lt; 2; k++) {
	    <B><FONT COLOR="#A020F0">if</FONT></B> ((y[j][k] = y[j][k^1] + *bp++) &gt;&gt; 10) derror();
	    ip = image[(row+j)*width + col+i+k];
	    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];
	  }
      }
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_rgb_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">short</FONT></B> buf[768], *bp;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, len, c, i, rgb[3];
  ushort *ip=image[0];

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col+=256) {
      len = MIN (256, width-col);
      kodak_65000_decode (buf, len*3);
      memset (rgb, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> rgb);
      <B><FONT COLOR="#A020F0">for</FONT></B> (bp=buf, i=0; i &lt; len; i++, ip+=4)
	FORC3 <B><FONT COLOR="#A020F0">if</FONT></B> ((ip[c] = rgb[c] += *bp++) &gt;&gt; 12) derror();
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">kodak_thumb_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col;
  colors = thumb_misc &gt;&gt; 5;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      read_shorts (image[row*width+col], colors);
  maximum = (1 &lt;&lt; (thumb_misc &amp; 31)) - 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">sony_decrypt</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> *data, <B><FONT COLOR="#228B22">int</FONT></B> len, <B><FONT COLOR="#228B22">int</FONT></B> start, <B><FONT COLOR="#228B22">int</FONT></B> key)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> pad[128], p;

  <B><FONT COLOR="#A020F0">if</FONT></B> (start) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=0; p &lt; 4; p++)
      pad[p] = key = key * 48828125 + 1;
    pad[3] = pad[3] &lt;&lt; 1 | (pad[0]^pad[2]) &gt;&gt; 31;
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=4; p &lt; 127; p++)
      pad[p] = (pad[p-4]^pad[p-2]) &lt;&lt; 1 | (pad[p-3]^pad[p-1]) &gt;&gt; 31;
    <B><FONT COLOR="#A020F0">for</FONT></B> (p=0; p &lt; 127; p++)
      pad[p] = htonl(pad[p]);
  }
  <B><FONT COLOR="#A020F0">while</FONT></B> (len-- &amp;&amp; p++)
    *data++ ^= pad[(p-1) &amp; 127] = pad[p &amp; 127] ^ pad[(p+64) &amp; 127];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">sony_load_raw</FONT></B>()
{
  uchar head[40];
  ushort *pixel;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, key, row, col;

  fseek (ifp, 200896, SEEK_SET);
  fseek (ifp, (<B><FONT COLOR="#228B22">unsigned</FONT></B>) fgetc(ifp)*4 - 1, SEEK_CUR);
  order = 0x4d4d;
  key = get4();
  fseek (ifp, 164600, SEEK_SET);
  fread (head, 1, 40, ifp);
  sony_decrypt ((<B><FONT COLOR="#228B22">unsigned</FONT></B> *) head, 10, 1, key);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=26; i-- &gt; 22; )
    key = key &lt;&lt; 8 | head[i];
  fseek (ifp, data_offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    pixel = raw_image + row*raw_width;
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread (pixel, 2, raw_width, ifp) &lt; raw_width) derror();
    sony_decrypt ((<B><FONT COLOR="#228B22">unsigned</FONT></B> *) pixel, raw_width/2, !row, key);
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++)
      <B><FONT COLOR="#A020F0">if</FONT></B> ((pixel[col] = ntohs(pixel[col])) &gt;&gt; 14) derror();
  }
  maximum = 0x3ff0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">sony_arw_load_raw</FONT></B>()
{
  ushort huff[32770];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> ushort tab[18] =
  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };
  <B><FONT COLOR="#228B22">int</FONT></B> i, c, n, col, row, sum=0;

  huff[0] = 15;
  <B><FONT COLOR="#A020F0">for</FONT></B> (n=i=0; i &lt; 18; i++)
    FORC(32768 &gt;&gt; (tab[i] &gt;&gt; 8)) huff[++n] = tab[i];
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (col = raw_width; col--; )
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height+1; row+=2) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (row == raw_height) row = 1;
      <B><FONT COLOR="#A020F0">if</FONT></B> ((sum += ljpeg_diff(huff)) &gt;&gt; 12) derror();
      <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; height) RAW(row,col) = sum;
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">sony_arw2_load_raw</FONT></B>()
{
  uchar *data, *dp;
  ushort pix[16];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, val, max, min, imax, imin, sh, bit, i;

  data = (uchar *) malloc (raw_width+1);
  merror (data, <B><FONT COLOR="#BC8F8F">&quot;sony_arw2_load_raw()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    fread (data, 1, raw_width, ifp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (dp=data, col=0; col &lt; raw_width-30; dp+=16) {
      max = 0x7ff &amp; (val = sget4(dp));
      min = 0x7ff &amp; val &gt;&gt; 11;
      imax = 0x0f &amp; val &gt;&gt; 22;
      imin = 0x0f &amp; val &gt;&gt; 26;
      <B><FONT COLOR="#A020F0">for</FONT></B> (sh=0; sh &lt; 4 &amp;&amp; 0x80 &lt;&lt; sh &lt;= max-min; sh++);
      <B><FONT COLOR="#A020F0">for</FONT></B> (bit=30, i=0; i &lt; 16; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B>      (i == imax) pix[i] = max;
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (i == imin) pix[i] = min;
	<B><FONT COLOR="#A020F0">else</FONT></B> {
	  pix[i] = ((sget2(dp+(bit &gt;&gt; 3)) &gt;&gt; (bit &amp; 7) &amp; 0x7f) &lt;&lt; sh) + min;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (pix[i] &gt; 0x7ff) pix[i] = 0x7ff;
	  bit += 7;
	}
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 16; i++, col+=2)
	RAW(row,col) = curve[pix[i] &lt;&lt; 1] &gt;&gt; 2;
      col -= col &amp; 1 ? 1:31;
    }
  }
  free (data);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">samsung_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, c, i, dir, op[4], len[4];

  order = 0x4949;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    fseek (ifp, strip_offset+row*4, SEEK_SET);
    fseek (ifp, data_offset+get4(), SEEK_SET);
    ph1_bits(-1);
    FORC4 len[c] = row &lt; 2 ? 7:4;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col+=16) {
      dir = ph1_bits(1);
      FORC4 op[c] = ph1_bits(2);
      FORC4 <B><FONT COLOR="#A020F0">switch</FONT></B> (op[c]) {
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>: len[c] = ph1_bits(4);	<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: len[c]--;		<B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>: len[c]++;
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 16; c+=2) {
	i = len[((c &amp; 1) &lt;&lt; 1) | (c &gt;&gt; 3)];
	RAW(row,col+c) = ((<B><FONT COLOR="#228B22">signed</FONT></B>) ph1_bits(i) &lt;&lt; (32-i) &gt;&gt; (32-i)) +
	  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);
	<B><FONT COLOR="#A020F0">if</FONT></B> (c == 14) c = -1;
      }
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height-1; row+=2)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width-1; col+=2)
      SWAP (RAW(row,col+1), RAW(row+1,col));
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">samsung2_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> ushort tab[14] =
  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,
    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };
  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];
  <B><FONT COLOR="#228B22">int</FONT></B> i, c, n, row, col, diff;

  huff[0] = 10;
  <B><FONT COLOR="#A020F0">for</FONT></B> (n=i=0; i &lt; 14; i++)
    FORC(1024 &gt;&gt; (tab[i] &gt;&gt; 8)) huff[++n] = tab[i];
  getbits(-1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; raw_width; col++) {
      diff = ljpeg_diff (huff);
      <B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) hpred[col] = vpred[row &amp; 1][col] += diff;
      <B><FONT COLOR="#A020F0">else</FONT></B>	   hpred[col &amp; 1] += diff;
      RAW(row,col) = hpred[col &amp; 1];
      <B><FONT COLOR="#A020F0">if</FONT></B> (hpred[col &amp; 1] &gt;&gt; tiff_bps) derror();
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">samsung3_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> opt, init, mag, pmode, row, tab, col, pred, diff, i, c;
  ushort lent[3][2], len[4], *prow[2];

  order = 0x4949;
  fseek (ifp, 9, SEEK_CUR);
  opt = fgetc(ifp);
  init = (get2(),get2());
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height; row++) {
    fseek (ifp, (data_offset-ftell(ifp)) &amp; 15, SEEK_CUR);
    ph1_bits(-1);
    mag = 0; pmode = 7;
    FORC(6) ((ushort *)lent)[c] = row &lt; 2 ? 7:4;
    prow[ row &amp; 1] = &amp;RAW(row-1,1-((row &amp; 1) &lt;&lt; 1));	<I><FONT COLOR="#B22222">// green
</FONT></I>    prow[~row &amp; 1] = &amp;RAW(row-2,0);			<I><FONT COLOR="#B22222">// red and blue
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (tab=0; tab+15 &lt; raw_width; tab+=16) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (~opt &amp; 4 &amp;&amp; !(tab &amp; 63)) {
	i = ph1_bits(2);
	mag = i &lt; 3 ? mag-<B><FONT COLOR="#BC8F8F">'2'</FONT></B>+<B><FONT COLOR="#BC8F8F">&quot;204&quot;</FONT></B>[i] : ph1_bits(12);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (opt &amp; 2)
	pmode = 7 - 4*ph1_bits(1);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!ph1_bits(1))
	pmode = ph1_bits(3);
      <B><FONT COLOR="#A020F0">if</FONT></B> (opt &amp; 1 || !ph1_bits(1)) {
	FORC4 len[c] = ph1_bits(2);
	FORC4 {
	  i = ((row &amp; 1) &lt;&lt; 1 | (c &amp; 1)) % 3;
	  len[c] = len[c] &lt; 3 ? lent[i][0]-<B><FONT COLOR="#BC8F8F">'1'</FONT></B>+<B><FONT COLOR="#BC8F8F">&quot;120&quot;</FONT></B>[len[c]] : ph1_bits(4);
	  lent[i][0] = lent[i][1];
	  lent[i][1] = len[c];
	}
      }
      FORC(16) {
	col = tab + (((c &amp; 7) &lt;&lt; 1)^(c &gt;&gt; 3)^(row &amp; 1));
	pred = (pmode == 7 || row &lt; 2)
	     ? (tab ? RAW(row,tab-2+(col &amp; 1)) : init)
	     : (prow[col &amp; 1][col-<B><FONT COLOR="#BC8F8F">'4'</FONT></B>+<B><FONT COLOR="#BC8F8F">&quot;0224468&quot;</FONT></B>[pmode]] +
		prow[col &amp; 1][col-<B><FONT COLOR="#BC8F8F">'4'</FONT></B>+<B><FONT COLOR="#BC8F8F">&quot;0244668&quot;</FONT></B>[pmode]] + 1) &gt;&gt; 1;
	diff = ph1_bits (i = len[c &gt;&gt; 2]);
	<B><FONT COLOR="#A020F0">if</FONT></B> (diff &gt;&gt; (i-1)) diff -= 1 &lt;&lt; i;
	diff = diff * (mag*2+1) + mag;
	RAW(row,col) = pred + diff;
      }
    }
  }
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">HOLE</FONT></B>(row) ((holes &gt;&gt; (((row) - raw_height) &amp; 7)) &amp; 1)

<I><FONT COLOR="#B22222">/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">smal_decode_segment</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> seg[2][2], <B><FONT COLOR="#228B22">int</FONT></B> holes)
{
  uchar hist[3][13] = {
    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },
    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },
    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };
  <B><FONT COLOR="#228B22">int</FONT></B> low, high=0xff, carry=0, nbits=8;
  <B><FONT COLOR="#228B22">int</FONT></B> pix, s, count, bin, next, i, sym[3];
  uchar diff, pred[]={0,0};
  ushort data=0, range=0;

  fseek (ifp, seg[0][1]+1, SEEK_SET);
  getbits(-1);
  <B><FONT COLOR="#A020F0">if</FONT></B> (seg[1][0] &gt; raw_width*raw_height)
      seg[1][0] = raw_width*raw_height;
  <B><FONT COLOR="#A020F0">for</FONT></B> (pix=seg[0][0]; pix &lt; seg[1][0]; pix++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (s=0; s &lt; 3; s++) {
      data = data &lt;&lt; nbits | getbits(nbits);
      <B><FONT COLOR="#A020F0">if</FONT></B> (carry &lt; 0)
	carry = (nbits += carry+1) &lt; 1 ? nbits-1 : 0;
      <B><FONT COLOR="#A020F0">while</FONT></B> (--nbits &gt;= 0)
	<B><FONT COLOR="#A020F0">if</FONT></B> ((data &gt;&gt; nbits &amp; 0xff) == 0xff) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (nbits &gt; 0)
	  data = ((data &amp; ((1 &lt;&lt; (nbits-1)) - 1)) &lt;&lt; 1) |
	((data + (((data &amp; (1 &lt;&lt; (nbits-1)))) &lt;&lt; 1)) &amp; (-1 &lt;&lt; nbits));
      <B><FONT COLOR="#A020F0">if</FONT></B> (nbits &gt;= 0) {
	data += getbits(1);
	carry = nbits - 8;
      }
      count = ((((data-range+1) &amp; 0xffff) &lt;&lt; 2) - 1) / (high &gt;&gt; 4);
      <B><FONT COLOR="#A020F0">for</FONT></B> (bin=0; hist[s][bin+5] &gt; count; bin++);
		low = hist[s][bin+5] * (high &gt;&gt; 4) &gt;&gt; 2;
      <B><FONT COLOR="#A020F0">if</FONT></B> (bin) high = hist[s][bin+4] * (high &gt;&gt; 4) &gt;&gt; 2;
      high -= low;
      <B><FONT COLOR="#A020F0">for</FONT></B> (nbits=0; high &lt;&lt; nbits &lt; 128; nbits++);
      range = (range+low) &lt;&lt; nbits;
      high &lt;&lt;= nbits;
      next = hist[s][1];
      <B><FONT COLOR="#A020F0">if</FONT></B> (++hist[s][2] &gt; hist[s][3]) {
	next = (next+1) &amp; hist[s][0];
	hist[s][3] = (hist[s][next+4] - hist[s][next+5]) &gt;&gt; 2;
	hist[s][2] = 1;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] &gt; 1) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (bin &lt; hist[s][1])
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i=bin; i &lt; hist[s][1]; i++) hist[s][i+5]--;
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (next &lt;= bin)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i=hist[s][1]; i &lt; bin; i++) hist[s][i+5]++;
      }
      hist[s][1] = next;
      sym[s] = bin;
    }
    diff = sym[2] &lt;&lt; 5 | sym[1] &lt;&lt; 2 | (sym[0] &amp; 3);
    <B><FONT COLOR="#A020F0">if</FONT></B> (sym[0] &amp; 4)
      diff = diff ? -diff : 0x80;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ftell(ifp) + 12 &gt;= seg[1][1])
      diff = 0;
    raw_image[pix] = pred[pix &amp; 1] += diff;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(pix &amp; 1) &amp;&amp; HOLE(pix / raw_width)) pix += 2;
  }
  maximum = 0xff;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">smal_v6_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> seg[2][2];

  fseek (ifp, 16, SEEK_SET);
  seg[0][0] = 0;
  seg[0][1] = get2();
  seg[1][0] = raw_width * raw_height;
  seg[1][1] = INT_MAX;
  smal_decode_segment (seg, 0);
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">median4</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> *p)
{
  <B><FONT COLOR="#228B22">int</FONT></B> min, max, sum, i;

  min = max = sum = p[0];
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=1; i &lt; 4; i++) {
    sum += p[i];
    <B><FONT COLOR="#A020F0">if</FONT></B> (min &gt; p[i]) min = p[i];
    <B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; p[i]) max = p[i];
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> (sum - min - max) &gt;&gt; 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">fill_holes</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> holes)
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, val[4];

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height-2; row++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!HOLE(row)) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=1; col &lt; width-1; col+=4) {
      val[0] = RAW(row-1,col-1);
      val[1] = RAW(row-1,col+1);
      val[2] = RAW(row+1,col-1);
      val[3] = RAW(row+1,col+1);
      RAW(row,col) = median4(val);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col+=4)
      <B><FONT COLOR="#A020F0">if</FONT></B> (HOLE(row-2) || HOLE(row+2))
	RAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) &gt;&gt; 1;
      <B><FONT COLOR="#A020F0">else</FONT></B> {
	val[0] = RAW(row,col-2);
	val[1] = RAW(row,col+2);
	val[2] = RAW(row-2,col);
	val[3] = RAW(row+2,col);
	RAW(row,col) = median4(val);
      }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">smal_v9_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> seg[256][2], offset, nseg, holes, i;

  fseek (ifp, 67, SEEK_SET);
  offset = get4();
  nseg = (uchar) fgetc(ifp);
  fseek (ifp, offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; nseg*2; i++)
    ((<B><FONT COLOR="#228B22">unsigned</FONT></B> *)seg)[i] = get4() + data_offset*(i &amp; 1);
  fseek (ifp, 78, SEEK_SET);
  holes = fgetc(ifp);
  fseek (ifp, 88, SEEK_SET);
  seg[nseg][0] = raw_height * raw_width;
  seg[nseg][1] = get4() + data_offset;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; nseg; i++)
    smal_decode_segment (seg+i, holes);
  <B><FONT COLOR="#A020F0">if</FONT></B> (holes) fill_holes (holes);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">redcine_load_raw</FONT></B>()
{
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_JASPER</FONT>
  <B><FONT COLOR="#228B22">int</FONT></B> c, row, col;
  jas_stream_t *in;
  jas_image_t *jimg;
  jas_matrix_t *jmat;
  jas_seqent_t *data;
  ushort *img, *pix;

  jas_init();
  in = jas_stream_fopen (ifname, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);
  jas_stream_seek (in, data_offset+20, SEEK_SET);
  jimg = jas_image_decode (in, -1, 0);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!jimg) longjmp (failure, 3);
  jmat = jas_matrix_create (height/2, width/2);
  merror (jmat, <B><FONT COLOR="#BC8F8F">&quot;redcine_load_raw()&quot;</FONT></B>);
  img = (ushort *) calloc ((height+2), (width+2)*2);
  merror (img, <B><FONT COLOR="#BC8F8F">&quot;redcine_load_raw()&quot;</FONT></B>);
  FORC4 {
    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);
    data = jas_matrix_getref (jmat, 0, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (row = c &gt;&gt; 1; row &lt; height; row+=2)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col = c &amp; 1; col &lt; width; col+=2)
	img[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (col=1; col &lt;= width; col++) {
    img[col] = img[2*(width+2)+col];
    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height+2; row++) {
    img[row*(width+2)] = img[row*(width+2)+2];
    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt;= height; row++) {
    pix = img + row*(width+2) + (col = 1 + (FC(row,1) &amp; 1));
    <B><FONT COLOR="#A020F0">for</FONT></B> (   ; col &lt;= width; col+=2, pix+=2) {
      c = (((pix[0] - 0x800) &lt;&lt; 3) +
	pix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) &gt;&gt; 2;
      pix[0] = LIM(c,0,4095);
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];
  free (img);
  jas_matrix_destroy (jmat);
  jas_image_destroy (jimg);
  jas_stream_close (in);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}

<I><FONT COLOR="#B22222">/* RESTRICTED code starts here */</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_decoder</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> size, <B><FONT COLOR="#228B22">unsigned</FONT></B> code)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> huff[1024];
  <B><FONT COLOR="#228B22">struct</FONT></B> decode *cur;
  <B><FONT COLOR="#228B22">int</FONT></B> i, len;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!code) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
      huff[i] = get4();
    memset (first_decode, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> first_decode);
    free_decode = first_decode;
  }
  cur = free_decode++;
  <B><FONT COLOR="#A020F0">if</FONT></B> (free_decode &gt; first_decode+2048) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: decoder table overflow\n&quot;</FONT></B>), ifname);
    longjmp (failure, 2);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (code)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (huff[i] == code) {
	cur-&gt;leaf = i;
	<B><FONT COLOR="#A020F0">return</FONT></B>;
      }
  <B><FONT COLOR="#A020F0">if</FONT></B> ((len = code &gt;&gt; 27) &gt; 26) <B><FONT COLOR="#A020F0">return</FONT></B>;
  code = (len+1) &lt;&lt; 27 | (code &amp; 0x3ffffff) &lt;&lt; 1;

  cur-&gt;branch[0] = free_decode;
  foveon_decoder (size, code);
  cur-&gt;branch[1] = free_decode;
  foveon_decoder (size, code+1);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> bwide, row, col, bitbuf=0, bit=1, c, i;
  <B><FONT COLOR="#228B22">char</FONT></B> *buf;
  <B><FONT COLOR="#228B22">struct</FONT></B> decode *dindex;
  <B><FONT COLOR="#228B22">short</FONT></B> pred[3];

  bwide = get4();
  fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P6\n%d %d\n255\n&quot;</FONT></B>, thumb_width, thumb_height);
  <B><FONT COLOR="#A020F0">if</FONT></B> (bwide &gt; 0) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (bwide &lt; thumb_width*3) <B><FONT COLOR="#A020F0">return</FONT></B>;
    buf = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (bwide);
    merror (buf, <B><FONT COLOR="#BC8F8F">&quot;foveon_thumb()&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; thumb_height; row++) {
      fread  (buf, 1, bwide, ifp);
      fwrite (buf, 3, thumb_width, ofp);
    }
    free (buf);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  foveon_decoder (256, 0);

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; thumb_height; row++) {
    memset (pred, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pred);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!bit) get4();
    <B><FONT COLOR="#A020F0">for</FONT></B> (bit=col=0; col &lt; thumb_width; col++)
      FORC3 {
	<B><FONT COLOR="#A020F0">for</FONT></B> (dindex=first_decode; dindex-&gt;branch[0]; ) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((bit = (bit-1) &amp; 31) == 31)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	      bitbuf = (bitbuf &lt;&lt; 8) + fgetc(ifp);
	  dindex = dindex-&gt;branch[bitbuf &gt;&gt; bit &amp; 1];
	}
	pred[c] += dindex-&gt;leaf;
	fputc (pred[c], ofp);
      }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_sd_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> decode *dindex;
  <B><FONT COLOR="#228B22">short</FONT></B> diff[1024];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> bitbuf=0;
  <B><FONT COLOR="#228B22">int</FONT></B> pred[3], row, col, bit=-1, c, i;

  read_shorts ((ushort *) diff, 1024);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!load_flags) foveon_decoder (1024, 0);

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    memset (pred, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pred);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!bit &amp;&amp; !load_flags &amp;&amp; atoi(model+2) &lt; 14) get4();
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=bit=0; col &lt; width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags) {
	bitbuf = get4();
	FORC3 pred[2-c] += diff[bitbuf &gt;&gt; c*10 &amp; 0x3ff];
      }
      <B><FONT COLOR="#A020F0">else</FONT></B> FORC3 {
	<B><FONT COLOR="#A020F0">for</FONT></B> (dindex=first_decode; dindex-&gt;branch[0]; ) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((bit = (bit-1) &amp; 31) == 31)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	      bitbuf = (bitbuf &lt;&lt; 8) + fgetc(ifp);
	  dindex = dindex-&gt;branch[bitbuf &gt;&gt; bit &amp; 1];
	}
	pred[c] += diff[dindex-&gt;leaf];
	<B><FONT COLOR="#A020F0">if</FONT></B> (pred[c] &gt;&gt; 16 &amp;&amp; ~pred[c] &gt;&gt; 16) derror();
      }
      FORC3 image[row*width+col][c] = pred[c];
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_huff</FONT></B> (ushort *huff)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, clen, code;

  huff[0] = 8;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 13; i++) {
    clen = getc(ifp);
    code = getc(ifp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 256 &gt;&gt; clen; )
      huff[code+ ++j] = clen &lt;&lt; 8 | i;
  }
  get2();
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_dp_load_raw</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> c, roff[4], row, col, diff;
  ushort huff[512], vpred[2][2], hpred[2];

  fseek (ifp, 8, SEEK_CUR);
  foveon_huff (huff);
  roff[0] = 48;
  FORC3 roff[c+1] = -(-(roff[c] + get4()) &amp; -16);
  FORC3 {
    fseek (ifp, data_offset+roff[c], SEEK_SET);
    getbits(-1);
    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
	diff = ljpeg_diff(huff);
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) hpred[col] = vpred[row &amp; 1][col] += diff;
	<B><FONT COLOR="#A020F0">else</FONT></B> hpred[col &amp; 1] += diff;
	image[row*width+col][c] = hpred[col &amp; 1];
      }
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_load_camf</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> type, wide, high, i, j, row, col, diff;
  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];

  fseek (ifp, meta_offset, SEEK_SET);
  type = get4();  get4();  get4();
  wide = get4();
  high = get4();
  <B><FONT COLOR="#A020F0">if</FONT></B> (type == 2) {
    fread (meta_data, 1, meta_length, ifp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; meta_length; i++) {
      high = (high * 1597 + 51749) % 244944;
      wide = high * (INT64) 301593171 &gt;&gt; 24;
      meta_data[i] ^= ((((high &lt;&lt; 8) - wide) &gt;&gt; 1) + wide) &gt;&gt; 17;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (type == 4) {
    free (meta_data);
    meta_data = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (meta_length = wide*high*3/2);
    merror (meta_data, <B><FONT COLOR="#BC8F8F">&quot;foveon_load_camf()&quot;</FONT></B>);
    foveon_huff (huff);
    get4();
    getbits(-1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=row=0; row &lt; high; row++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; wide; col++) {
	diff = ljpeg_diff(huff);
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &lt; 2) hpred[col] = vpred[row &amp; 1][col] += diff;
	<B><FONT COLOR="#A020F0">else</FONT></B>         hpred[col &amp; 1] += diff;
	<B><FONT COLOR="#A020F0">if</FONT></B> (col &amp; 1) {
	  meta_data[j++] = hpred[0] &gt;&gt; 4;
	  meta_data[j++] = hpred[0] &lt;&lt; 4 | hpred[1] &gt;&gt; 8;
	  meta_data[j++] = hpred[1];
	}
      }
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s has unknown CAMF type %d.\n&quot;</FONT></B>), ifname, type);
}

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> * CLASS <B><FONT COLOR="#0000FF">foveon_camf_param</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *block, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *param)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> idx, num;
  <B><FONT COLOR="#228B22">char</FONT></B> *pos, *cp, *dp;

  <B><FONT COLOR="#A020F0">for</FONT></B> (idx=0; idx &lt; meta_length; idx += sget4(pos+8)) {
    pos = meta_data + idx;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strncmp (pos, <B><FONT COLOR="#BC8F8F">&quot;CMb&quot;</FONT></B>, 3)) <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pos[3] != <B><FONT COLOR="#BC8F8F">'P'</FONT></B>) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp (block, pos+sget4(pos+12))) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    cp = pos + sget4(pos+16);
    num = sget4(cp);
    dp = pos + sget4(cp+4);
    <B><FONT COLOR="#A020F0">while</FONT></B> (num--) {
      cp += 8;
      <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (param, dp+sget4(cp)))
	<B><FONT COLOR="#A020F0">return</FONT></B> dp+sget4(cp+4);
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> * CLASS <B><FONT COLOR="#0000FF">foveon_camf_matrix</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> dim[3], <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *name)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, idx, type, ndim, size, *mat;
  <B><FONT COLOR="#228B22">char</FONT></B> *pos, *cp, *dp;
  <B><FONT COLOR="#228B22">double</FONT></B> dsize;

  <B><FONT COLOR="#A020F0">for</FONT></B> (idx=0; idx &lt; meta_length; idx += sget4(pos+8)) {
    pos = meta_data + idx;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strncmp (pos, <B><FONT COLOR="#BC8F8F">&quot;CMb&quot;</FONT></B>, 3)) <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pos[3] != <B><FONT COLOR="#BC8F8F">'M'</FONT></B>) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp (name, pos+sget4(pos+12))) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    dim[0] = dim[1] = dim[2] = 1;
    cp = pos + sget4(pos+16);
    type = sget4(cp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((ndim = sget4(cp+4)) &gt; 3) <B><FONT COLOR="#A020F0">break</FONT></B>;
    dp = pos + sget4(cp+8);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=ndim; i--; ) {
      cp += 12;
      dim[i] = sget4(cp);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((dsize = (<B><FONT COLOR="#228B22">double</FONT></B>) dim[0]*dim[1]*dim[2]) &gt; meta_length/4) <B><FONT COLOR="#A020F0">break</FONT></B>;
    mat = (<B><FONT COLOR="#228B22">unsigned</FONT></B> *) malloc ((size = dsize) * 4);
    merror (mat, <B><FONT COLOR="#BC8F8F">&quot;foveon_camf_matrix()&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (type &amp;&amp; type != 6)
	mat[i] = sget4(dp + i*4);
      <B><FONT COLOR="#A020F0">else</FONT></B>
	mat[i] = sget4(dp + i*2) &amp; 0xffff;
    <B><FONT COLOR="#A020F0">return</FONT></B> mat;
  }
  fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: \&quot;%s\&quot; matrix not found!\n&quot;</FONT></B>), ifname, name);
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_fixed</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B> *ptr, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *name)
{
  <B><FONT COLOR="#228B22">void</FONT></B> *dp;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> dim[3];

  <B><FONT COLOR="#A020F0">if</FONT></B> (!name) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  dp = foveon_camf_matrix (dim, name);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!dp) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  memcpy (ptr, dp, size*4);
  free (dp);
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">float</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_avg</FONT></B> (<B><FONT COLOR="#228B22">short</FONT></B> *pix, <B><FONT COLOR="#228B22">int</FONT></B> range[2], <B><FONT COLOR="#228B22">float</FONT></B> cfilt)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#228B22">float</FONT></B> val, min=FLT_MAX, max=-FLT_MAX, sum=0;

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=range[0]; i &lt;= range[1]; i++) {
    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;
    <B><FONT COLOR="#A020F0">if</FONT></B> (min &gt; val) min = val;
    <B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; val) max = val;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (range[1] - range[0] == 1) <B><FONT COLOR="#A020F0">return</FONT></B> sum/2;
  <B><FONT COLOR="#A020F0">return</FONT></B> (sum - min - max) / (range[1] - range[0] - 1);
}

<B><FONT COLOR="#228B22">short</FONT></B> * CLASS <B><FONT COLOR="#0000FF">foveon_make_curve</FONT></B> (<B><FONT COLOR="#228B22">double</FONT></B> max, <B><FONT COLOR="#228B22">double</FONT></B> mul, <B><FONT COLOR="#228B22">double</FONT></B> filt)
{
  <B><FONT COLOR="#228B22">short</FONT></B> *curve;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, size;
  <B><FONT COLOR="#228B22">double</FONT></B> x;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!filt) filt = 0.8;
  size = 4*M_PI*max / filt;
  <B><FONT COLOR="#A020F0">if</FONT></B> (size == UINT_MAX) size--;
  curve = (<B><FONT COLOR="#228B22">short</FONT></B> *) calloc (size+1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *curve);
  merror (curve, <B><FONT COLOR="#BC8F8F">&quot;foveon_make_curve()&quot;</FONT></B>);
  curve[0] = size;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++) {
    x = i*filt/max/4;
    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> curve;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS foveon_make_curves
	(<B><FONT COLOR="#228B22">short</FONT></B> **curvep, <B><FONT COLOR="#228B22">float</FONT></B> dq[3], <B><FONT COLOR="#228B22">float</FONT></B> div[3], <B><FONT COLOR="#228B22">float</FONT></B> filt)
{
  <B><FONT COLOR="#228B22">double</FONT></B> mul[3], max=0;
  <B><FONT COLOR="#228B22">int</FONT></B> c;

  FORC3 mul[c] = dq[c]/div[c];
  FORC3 <B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; mul[c]) max = mul[c];
  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_apply_curve</FONT></B> (<B><FONT COLOR="#228B22">short</FONT></B> *curve, <B><FONT COLOR="#228B22">int</FONT></B> i)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (abs(i) &gt;= curve[0]) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">return</FONT></B> i &lt; 0 ? -curve[1-i] : curve[1+i];
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">image</FONT> ((short (*)[4]) image)

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">foveon_interpolate</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };
  <B><FONT COLOR="#228B22">short</FONT></B> *pix, prev[3], *curve[8], (*shrink)[3];
  <B><FONT COLOR="#228B22">float</FONT></B> cfilt=0, ddft[3][3][2], ppm[3][3][3];
  <B><FONT COLOR="#228B22">float</FONT></B> cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];
  <B><FONT COLOR="#228B22">float</FONT></B> chroma_dq[3], color_dq[3], diag[3][3], div[3];
  <B><FONT COLOR="#228B22">float</FONT></B> (*black)[3], (*sgain)[3], (*sgrow)[3];
  <B><FONT COLOR="#228B22">float</FONT></B> fsum[3], val, frow, num;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;
  <B><FONT COLOR="#228B22">int</FONT></B> dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];
  <B><FONT COLOR="#228B22">int</FONT></B> work[3][3], smlast, smred, smred_p=0, dev[3];
  <B><FONT COLOR="#228B22">int</FONT></B> satlev[3], keep[4], active[4];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> dim[3], *badpix;
  <B><FONT COLOR="#228B22">double</FONT></B> dsum=0, trsum[3];
  <B><FONT COLOR="#228B22">char</FONT></B> str[128];
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* cp;

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Foveon interpolation...\n&quot;</FONT></B>));

  foveon_load_camf();
  foveon_fixed (dscr, 4, <B><FONT COLOR="#BC8F8F">&quot;DarkShieldColRange&quot;</FONT></B>);
  foveon_fixed (ppm[0][0], 27, <B><FONT COLOR="#BC8F8F">&quot;PostPolyMatrix&quot;</FONT></B>);
  foveon_fixed (satlev, 3, <B><FONT COLOR="#BC8F8F">&quot;SaturationLevel&quot;</FONT></B>);
  foveon_fixed (keep, 4, <B><FONT COLOR="#BC8F8F">&quot;KeepImageArea&quot;</FONT></B>);
  foveon_fixed (active, 4, <B><FONT COLOR="#BC8F8F">&quot;ActiveImageArea&quot;</FONT></B>);
  foveon_fixed (chroma_dq, 3, <B><FONT COLOR="#BC8F8F">&quot;ChromaDQ&quot;</FONT></B>);
  foveon_fixed (color_dq, 3,
	foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;IncludeBlocks&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;ColorDQ&quot;</FONT></B>) ?
		<B><FONT COLOR="#BC8F8F">&quot;ColorDQ&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;ColorDQCamRGB&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;IncludeBlocks&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;ColumnFilter&quot;</FONT></B>))
		 foveon_fixed (&amp;cfilt, 1, <B><FONT COLOR="#BC8F8F">&quot;ColumnFilter&quot;</FONT></B>);

  memset (ddft, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> ddft);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;IncludeBlocks&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DarkDrift&quot;</FONT></B>)
	 || !foveon_fixed (ddft[1][0], 12, <B><FONT COLOR="#BC8F8F">&quot;DarkDrift&quot;</FONT></B>))
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++) {
      foveon_fixed (dstb, 4, i ? <B><FONT COLOR="#BC8F8F">&quot;DarkShieldBottom&quot;</FONT></B>:<B><FONT COLOR="#BC8F8F">&quot;DarkShieldTop&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row = dstb[1]; row &lt;= dstb[3]; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = dstb[0]; col &lt;= dstb[2]; col++)
	  FORC3 ddft[i+1][c][1] += (<B><FONT COLOR="#228B22">short</FONT></B>) image[row*width+col][c];
      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);
    }

  <B><FONT COLOR="#A020F0">if</FONT></B> (!(cp = foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;WhiteBalanceIlluminants&quot;</FONT></B>, model2)))
  { fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: Invalid white balance \&quot;%s\&quot;\n&quot;</FONT></B>), ifname, model2);
    <B><FONT COLOR="#A020F0">return</FONT></B>; }
  foveon_fixed (cam_xyz, 9, cp);
  foveon_fixed (correct, 9,
	foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;WhiteBalanceCorrections&quot;</FONT></B>, model2));
  memset (last, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> last);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];

  #define LAST(x,y) last[(i+x)%3][(c+y)%3]
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);
  #undef LAST
  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;
  sprintf (str, <B><FONT COLOR="#BC8F8F">&quot;%sRGBNeutral&quot;</FONT></B>, model2);
  <B><FONT COLOR="#A020F0">if</FONT></B> (foveon_camf_param (<B><FONT COLOR="#BC8F8F">&quot;IncludeBlocks&quot;</FONT></B>, str))
    foveon_fixed (div, 3, str);
  num = 0;
  FORC3 <B><FONT COLOR="#A020F0">if</FONT></B> (num &lt; div[c]) num = div[c];
  FORC3 div[c] /= num;

  memset (trans, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> trans);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];
  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];
  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];
  memset (trans, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> trans);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;

  foveon_make_curves (curve, color_dq, div, cfilt);
  FORC3 chroma_dq[c] /= 3;
  foveon_make_curves (curve+3, chroma_dq, div, cfilt);
  FORC3 dsum += chroma_dq[c] / div[c];
  curve[6] = foveon_make_curve (dsum, dsum, cfilt);
  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);

  sgain = (<B><FONT COLOR="#228B22">float</FONT></B> (*)[3]) foveon_camf_matrix (dim, <B><FONT COLOR="#BC8F8F">&quot;SpatialGain&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!sgain) <B><FONT COLOR="#A020F0">return</FONT></B>;
  sgrow = (<B><FONT COLOR="#228B22">float</FONT></B> (*)[3]) calloc (dim[1], <B><FONT COLOR="#A020F0">sizeof</FONT></B> *sgrow);
  sgx = (width + dim[1]-2) / (dim[1]-1);

  black = (<B><FONT COLOR="#228B22">float</FONT></B> (*)[3]) calloc (height, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *black);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 6; i++)
      ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[0])[i] = ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[1])[i] +
	row / (height-1.0) * (((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[2])[i] - ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[1])[i]);
    FORC3 black[row][c] =
	( foveon_avg (image[row*width]+c, dscr[0], cfilt) +
	  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3
	  - ddft[0][c][0] ) / 4 - ddft[0][c][1];
  }
  memcpy (black, black+8, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *black*8);
  memcpy (black+height-11, black+height-22, 11*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *black);
  memcpy (last, black, <B><FONT COLOR="#A020F0">sizeof</FONT></B> last);

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt; height-1; row++) {
    FORC3 <B><FONT COLOR="#A020F0">if</FONT></B> (last[1][c] &gt; last[0][c]) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (last[1][c] &gt; last[2][c])
	  black[row][c] = (last[0][c] &gt; last[2][c]) ? last[0][c]:last[2][c];
      } <B><FONT COLOR="#A020F0">else</FONT></B>
	<B><FONT COLOR="#A020F0">if</FONT></B> (last[1][c] &lt; last[2][c])
	  black[row][c] = (last[0][c] &lt; last[2][c]) ? last[0][c]:last[2][c];
    memmove (last, last+1, 2*<B><FONT COLOR="#A020F0">sizeof</FONT></B> last[0]);
    memcpy (last[2], black[row+1], <B><FONT COLOR="#A020F0">sizeof</FONT></B> last[2]);
  }
  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;
  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;

  val = 1 - exp(-1/24.0);
  memcpy (fsum, black, <B><FONT COLOR="#A020F0">sizeof</FONT></B> fsum);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt; height; row++)
    FORC3 fsum[c] += black[row][c] =
	(black[row][c] - black[row-1][c])*val + black[row-1][c];
  memcpy (last[0], black[height-1], <B><FONT COLOR="#A020F0">sizeof</FONT></B> last[0]);
  FORC3 fsum[c] /= height;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row = height; row--; )
    FORC3 last[0][c] = black[row][c] =
	(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];

  memset (total, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> total);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height; row+=4)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width; col+=4) {
      FORC3 total[c] += (<B><FONT COLOR="#228B22">short</FONT></B>) image[row*width+col][c];
      total[3]++;
    }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 6; i++)
      ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[0])[i] = ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[1])[i] +
	row / (height-1.0) * (((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[2])[i] - ((<B><FONT COLOR="#228B22">float</FONT></B> *)ddft[1])[i]);
    pix = image[row*width];
    memcpy (prev, pix, <B><FONT COLOR="#A020F0">sizeof</FONT></B> prev);
    frow = row / (height-1.0) * (dim[2]-1);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((irow = frow) == dim[2]-1) irow--;
    frow -= irow;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; dim[1]; i++)
      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +
			  sgain[(irow+1)*dim[1]+i][c] *    frow;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      FORC3 {
	diff = pix[c] - prev[c];
	prev[c] = pix[c];
	ipix[c] = pix[c] + floor ((diff + (diff*diff &gt;&gt; 14)) * cfilt
		- ddft[0][c][1] - ddft[0][c][0] * ((<B><FONT COLOR="#228B22">float</FONT></B>) col/width - 0.5)
		- black[row][c] );
      }
      FORC3 {
	work[0][c] = ipix[c] * ipix[c] &gt;&gt; 14;
	work[2][c] = ipix[c] * work[0][c] &gt;&gt; 14;
	work[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] &gt;&gt; 14;
      }
      FORC3 {
	<B><FONT COLOR="#A020F0">for</FONT></B> (val=i=0; i &lt; 3; i++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (  j=0; j &lt; 3; j++)
	    val += ppm[c][i][j] * work[i][j];
	ipix[c] = floor ((ipix[c] + floor(val)) *
		( sgrow[col/sgx  ][c] * (sgx - col%sgx) +
		  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);
	<B><FONT COLOR="#A020F0">if</FONT></B> (ipix[c] &gt; 32000) ipix[c] = 32000;
	pix[c] = ipix[c];
      }
      pix += 4;
    }
  }
  free (black);
  free (sgrow);
  free (sgain);

  <B><FONT COLOR="#A020F0">if</FONT></B> ((badpix = (<B><FONT COLOR="#228B22">unsigned</FONT></B> *) foveon_camf_matrix (dim, <B><FONT COLOR="#BC8F8F">&quot;BadPixels&quot;</FONT></B>))) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; dim[0]; i++) {
      col = (badpix[i] &gt;&gt; 8 &amp; 0xfff) - keep[0];
      row = (badpix[i] &gt;&gt; 20       ) - keep[1];
      <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>)(row-1) &gt; height-3 || (<B><FONT COLOR="#228B22">unsigned</FONT></B>)(col-1) &gt; width-3)
	<B><FONT COLOR="#A020F0">continue</FONT></B>;
      memset (fsum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> fsum);
      <B><FONT COLOR="#A020F0">for</FONT></B> (sum=j=0; j &lt; 8; j++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (badpix[i] &amp; (1 &lt;&lt; j)) {
	  FORC3 fsum[c] += (<B><FONT COLOR="#228B22">short</FONT></B>)
		image[(row+hood[j*2])*width+col+hood[j*2+1]][c];
	  sum++;
	}
      <B><FONT COLOR="#A020F0">if</FONT></B> (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;
    }
    free (badpix);
  }

  <I><FONT COLOR="#B22222">/* Array for 5x5 Gaussian averaging of red values */</FONT></I>
  smrow[6] = (<B><FONT COLOR="#228B22">int</FONT></B> (*)[3]) calloc (width*5, <B><FONT COLOR="#A020F0">sizeof</FONT></B> **smrow);
  merror (smrow[6], <B><FONT COLOR="#BC8F8F">&quot;foveon_interpolate()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 5; i++)
    smrow[i] = smrow[6] + i*width;

  <I><FONT COLOR="#B22222">/* Sharpen the reds against these Gaussian averages */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (smlast=-1, row=2; row &lt; height-2; row++) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (smlast &lt; row+2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 6; i++)
	smrow[(i+5) % 6] = smrow[i];
      pix = image[++smlast*width+2];
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
	smrow[4][col][0] =
	  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) &gt;&gt; 4;
	pix += 4;
      }
    }
    pix = image[row*width+2];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
      smred = ( 6 *  smrow[2][col][0]
	      + 4 * (smrow[1][col][0] + smrow[3][col][0])
	      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) &gt;&gt; 4;
      <B><FONT COLOR="#A020F0">if</FONT></B> (col == 2)
	smred_p = smred;
      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) &gt;&gt; 3)) &gt;&gt; 3);
      <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 32000) i = 32000;
      pix[0] = i;
      smred_p = smred;
      pix += 4;
    }
  }

  <I><FONT COLOR="#B22222">/* Adjust the brighter pixels for better linearity */</FONT></I>
  min = 0xffff;
  FORC3 {
    i = satlev[c] / div[c];
    <B><FONT COLOR="#A020F0">if</FONT></B> (min &gt; i) min = i;
  }
  limit = min * 9 &gt;&gt; 4;
  <B><FONT COLOR="#A020F0">for</FONT></B> (pix=image[0]; pix &lt; image[height*width]; pix+=4) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (pix[0] &lt;= limit || pix[1] &lt;= limit || pix[2] &lt;= limit)
      <B><FONT COLOR="#A020F0">continue</FONT></B>;
    min = max = pix[0];
    <B><FONT COLOR="#A020F0">for</FONT></B> (c=1; c &lt; 3; c++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (min &gt; pix[c]) min = pix[c];
      <B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; pix[c]) max = pix[c];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (min &gt;= limit*2) {
      pix[0] = pix[1] = pix[2] = max;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      i = 0x4000 - ((min - limit) &lt;&lt; 14) / limit;
      i = 0x4000 - (i*i &gt;&gt; 14);
      i = i*i &gt;&gt; 14;
      FORC3 pix[c] += (max - pix[c]) * i &gt;&gt; 14;
    }
  }
<I><FONT COLOR="#B22222">/*
   Because photons that miss one detector often hit another,
   the sum R+G+B is much less noisy than the individual colors.
   So smooth the hues without smoothing the total.
 */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (smlast=-1, row=2; row &lt; height-2; row++) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (smlast &lt; row+2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 6; i++)
	smrow[(i+5) % 6] = smrow[i];
      pix = image[++smlast*width+2];
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
	FORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) &gt;&gt; 2;
	pix += 4;
      }
    }
    pix = image[row*width+2];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -
	((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) &gt;&gt; 2));
      sum = (dev[0] + dev[1] + dev[2]) &gt;&gt; 3;
      FORC3 pix[c] += dev[c] - sum;
      pix += 4;
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (smlast=-1, row=2; row &lt; height-2; row++) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (smlast &lt; row+2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 6; i++)
	smrow[(i+5) % 6] = smrow[i];
      pix = image[++smlast*width+2];
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
	FORC3 smrow[4][col][c] =
		(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) &gt;&gt; 2;
	pix += 4;
      }
    }
    pix = image[row*width+2];
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (total[3]=375, sum=60, c=0; c &lt; 3; c++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (total[c]=i=0; i &lt; 5; i++)
	  total[c] += smrow[i][col][c];
	total[3] += total[c];
	sum += pix[c];
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (sum &lt; 0) sum = 0;
      j = total[3] &gt; 375 ? (sum &lt;&lt; 16) / total[3] : sum * 174;
      FORC3 pix[c] += foveon_apply_curve (curve[6],
		((j*total[c] + 0x8000) &gt;&gt; 16) - pix[c]);
      pix += 4;
    }
  }

  <I><FONT COLOR="#B22222">/* Transform the image to a different colorspace */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (pix=image[0]; pix &lt; image[height*width]; pix+=4) {
    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);
    sum = (pix[0]+pix[1]+pix[1]+pix[2]) &gt;&gt; 2;
    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);
    FORC3 {
      <B><FONT COLOR="#A020F0">for</FONT></B> (dsum=i=0; i &lt; 3; i++)
	dsum += trans[c][i] * pix[i];
      <B><FONT COLOR="#A020F0">if</FONT></B> (dsum &lt; 0)  dsum = 0;
      <B><FONT COLOR="#A020F0">if</FONT></B> (dsum &gt; 24000) dsum = 24000;
      ipix[c] = dsum + 0.5;
    }
    FORC3 pix[c] = ipix[c];
  }

  <I><FONT COLOR="#B22222">/* Smooth the image bottom-to-top and save at 1/4 scale */</FONT></I>
  shrink = (<B><FONT COLOR="#228B22">short</FONT></B> (*)[3]) calloc ((height/4), (width/4)*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *shrink);
  merror (shrink, <B><FONT COLOR="#BC8F8F">&quot;foveon_interpolate()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row = height/4; row--; )
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width/4; col++) {
      ipix[0] = ipix[1] = ipix[2] = 0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 4; j++)
	  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];
      FORC3
	<B><FONT COLOR="#A020F0">if</FONT></B> (row+2 &gt; height/4)
	  shrink[row*(width/4)+col][c] = ipix[c] &gt;&gt; 4;
	<B><FONT COLOR="#A020F0">else</FONT></B>
	  shrink[row*(width/4)+col][c] =
	    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) &gt;&gt; 12;
    }
  <I><FONT COLOR="#B22222">/* From the 1/4-scale image, smooth right-to-left */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; (height &amp; ~3); row++) {
    ipix[0] = ipix[1] = ipix[2] = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((row &amp; 3) == 0)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col = width &amp; ~3 ; col--; )
	FORC3 smrow[0][col][c] = ipix[c] =
	  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) &gt;&gt; 13;

  <I><FONT COLOR="#B22222">/* Then smooth left-to-right */</FONT></I>
    ipix[0] = ipix[1] = ipix[2] = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; (width &amp; ~3); col++)
      FORC3 smrow[1][col][c] = ipix[c] =
	(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) &gt;&gt; 13;

  <I><FONT COLOR="#B22222">/* Smooth top-to-bottom */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (row == 0)
      memcpy (smrow[2], smrow[1], <B><FONT COLOR="#A020F0">sizeof</FONT></B> **smrow * width);
    <B><FONT COLOR="#A020F0">else</FONT></B>
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; (width &amp; ~3); col++)
	FORC3 smrow[2][col][c] =
	  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) &gt;&gt; 13;

  <I><FONT COLOR="#B22222">/* Adjust the chroma toward the smooth values */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; (width &amp; ~3); col++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=j=30, c=0; c &lt; 3; c++) {
	i += smrow[2][col][c];
	j += image[row*width+col][c];
      }
      j = (j &lt;&lt; 16) / i;
      <B><FONT COLOR="#A020F0">for</FONT></B> (sum=c=0; c &lt; 3; c++) {
	ipix[c] = foveon_apply_curve (curve[c+3],
	  ((smrow[2][col][c] * j + 0x8000) &gt;&gt; 16) - image[row*width+col][c]);
	sum += ipix[c];
      }
      sum &gt;&gt;= 3;
      FORC3 {
	i = image[row*width+col][c] + ipix[c] - sum;
	<B><FONT COLOR="#A020F0">if</FONT></B> (i &lt; 0) i = 0;
	image[row*width+col][c] = i;
      }
    }
  }
  free (shrink);
  free (smrow[6]);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 8; i++)
    free (curve[i]);

  <I><FONT COLOR="#B22222">/* Trim off the black border */</FONT></I>
  active[1] -= keep[1];
  active[3] -= 2;
  i = active[2] - active[0];
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; active[3]-active[1]; row++)
    memcpy (image[row*i], image[(row+active[1])*width+active[0]],
	 i * <B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
  width = i;
  height = row;
}
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">image</FONT>

<I><FONT COLOR="#B22222">/* RESTRICTED code ends here */</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">crop_masked_pixels</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> r, c, m, mblack[8], zero, val;

  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS phase_one_load_raw ||
      load_raw == &amp;CLASS phase_one_load_raw_c)
    phase_one_correct();
  <B><FONT COLOR="#A020F0">if</FONT></B> (fuji_width) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; raw_height-top_margin*2; row++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; fuji_width &lt;&lt; !fuji_layout; col++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (fuji_layout) {
	  r = fuji_width - 1 - col + (row &gt;&gt; 1);
	  c = col + ((row+1) &gt;&gt; 1);
	} <B><FONT COLOR="#A020F0">else</FONT></B> {
	  r = fuji_width - 1 + row - (col &gt;&gt; 1);
	  c = row + ((col+1) &gt;&gt; 1);
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; height &amp;&amp; c &lt; width)
	  BAYER(r,c) = RAW(row+top_margin,col+left_margin);
      }
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
	BAYER2(row,col) = RAW(row+top_margin,col+left_margin);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (mask[0][3] &gt; 0) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">mask_set</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS canon_load_raw ||
      load_raw == &amp;CLASS lossless_jpeg_load_raw) {
    mask[0][1] = mask[1][1] += 2;
    mask[0][3] -= 2;
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">sides</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS canon_600_load_raw ||
      load_raw == &amp;CLASS sony_load_raw ||
     (load_raw == &amp;CLASS eight_bit_load_raw &amp;&amp; strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DC2&quot;</FONT></B>,3)) ||
      load_raw == &amp;CLASS kodak_262_load_raw ||
     (load_raw == &amp;CLASS packed_load_raw &amp;&amp; (load_flags &amp; 256))) {
<B><FONT COLOR="#5F9EA0">sides</FONT></B>:
    mask[0][0] = mask[1][0] = top_margin;
    mask[0][2] = mask[1][2] = top_margin+height;
    mask[0][3] += left_margin;
    mask[1][1] += left_margin+width;
    mask[1][3] += raw_width;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS nokia_load_raw) {
    mask[0][2] = top_margin;
    mask[0][3] = width;
  }
<B><FONT COLOR="#5F9EA0">mask_set</FONT></B>:
  memset (mblack, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> mblack);
  <B><FONT COLOR="#A020F0">for</FONT></B> (zero=m=0; m &lt; 8; m++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=MAX(mask[m][0],0); row &lt; MIN(mask[m][2],raw_height); row++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=MAX(mask[m][1],0); col &lt; MIN(mask[m][3],raw_width); col++) {
	c = FC(row-top_margin,col-left_margin);
	mblack[c] += val = RAW(row,col);
	mblack[4+c]++;
	zero += !val;
      }
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS canon_600_load_raw &amp;&amp; width &lt; raw_width) {
    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /
	    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;
    canon_600_correct();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (zero &lt; mblack[4] &amp;&amp; mblack[5] &amp;&amp; mblack[6] &amp;&amp; mblack[7]) {
    FORC4 cblack[c] = mblack[c] / mblack[4+c];
    cblack[4] = cblack[5] = cblack[6] = 0;
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">remove_zeroes</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> row, col, tot, n, r, c;

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (BAYER(row,col) == 0) {
	tot = n = 0;
	<B><FONT COLOR="#A020F0">for</FONT></B> (r = row-2; r &lt;= row+2; r++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (c = col-2; c &lt;= col+2; c++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; height &amp;&amp; c &lt; width &amp;&amp;
		FC(r,c) == FC(row,col) &amp;&amp; BAYER(r,c))
	      tot += (n++,BAYER(r,c));
	<B><FONT COLOR="#A020F0">if</FONT></B> (n) BAYER(row,col) = tot/n;
      }
}

<I><FONT COLOR="#B22222">/*
   Seach from the current directory up to the root looking for
   a &quot;.badpixels&quot; file, and fix those pixels now.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">bad_pixels</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *cfname)
{
  FILE *fp=0;
  <B><FONT COLOR="#228B22">char</FONT></B> *fname, *cp, line[128];
  <B><FONT COLOR="#228B22">int</FONT></B> len, time, row, col, r, c, rad, tot, n, fixed=0;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!filters) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (cfname)
    fp = fopen (cfname, <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">for</FONT></B> (len=32 ; ; len *= 2) {
      fname = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (len);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!fname) <B><FONT COLOR="#A020F0">return</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (getcwd (fname, len-16)) <B><FONT COLOR="#A020F0">break</FONT></B>;
      free (fname);
      <B><FONT COLOR="#A020F0">if</FONT></B> (errno != ERANGE) <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">WIN32</FONT>) || <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">DJGPP</FONT>)
    <B><FONT COLOR="#A020F0">if</FONT></B> (fname[1] == <B><FONT COLOR="#BC8F8F">':'</FONT></B>)
      memmove (fname, fname+2, len-2);
    <B><FONT COLOR="#A020F0">for</FONT></B> (cp=fname; *cp; cp++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (*cp == <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>) *cp = <B><FONT COLOR="#BC8F8F">'/'</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    cp = fname + strlen(fname);
    <B><FONT COLOR="#A020F0">if</FONT></B> (cp[-1] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) cp--;
    <B><FONT COLOR="#A020F0">while</FONT></B> (*fname == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) {
      strcpy (cp, <B><FONT COLOR="#BC8F8F">&quot;/.badpixels&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = fopen (fname, <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>))) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (cp == fname) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">while</FONT></B> (*--cp != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>);
    }
    free (fname);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!fp) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">while</FONT></B> (fgets (line, 128, fp)) {
    cp = strchr (line, <B><FONT COLOR="#BC8F8F">'#'</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (cp) *cp = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (sscanf (line, <B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;col, &amp;row, &amp;time) != 3) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) col &gt;= width || (<B><FONT COLOR="#228B22">unsigned</FONT></B>) row &gt;= height) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (time &gt; timestamp) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B> (tot=n=0, rad=1; rad &lt; 3 &amp;&amp; n==0; rad++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (r = row-rad; r &lt;= row+rad; r++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (c = col-rad; c &lt;= col+rad; c++)
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) r &lt; height &amp;&amp; (<B><FONT COLOR="#228B22">unsigned</FONT></B>) c &lt; width &amp;&amp;
		(r != row || c != col) &amp;&amp; fcol(r,c) == fcol(row,col)) {
	    tot += BAYER2(r,c);
	    n++;
	  }
    BAYER2(row,col) = tot/n;
    <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!fixed++)
	fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Fixed dead pixels at:&quot;</FONT></B>));
      fprintf (stderr, <B><FONT COLOR="#BC8F8F">&quot; %d,%d&quot;</FONT></B>, col, row);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (fixed) fputc (<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>, stderr);
  fclose (fp);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">subtract</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fname)
{
  FILE *fp;
  <B><FONT COLOR="#228B22">int</FONT></B> dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;
  ushort *pixel;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!(fp = fopen (fname, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>))) {
    perror (fname);  <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (fgetc(fp) != <B><FONT COLOR="#BC8F8F">'P'</FONT></B> || fgetc(fp) != <B><FONT COLOR="#BC8F8F">'5'</FONT></B>) error = 1;
  <B><FONT COLOR="#A020F0">while</FONT></B> (!error &amp;&amp; nd &lt; 3 &amp;&amp; (c = fgetc(fp)) != EOF) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (c == <B><FONT COLOR="#BC8F8F">'#'</FONT></B>)  comment = 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (c == <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>) comment = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (comment) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (isdigit(c)) number = 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (number) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (isdigit(c)) dim[nd] = dim[nd]*10 + c -<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (isspace(c)) {
	number = 0;  nd++;
      } <B><FONT COLOR="#A020F0">else</FONT></B> error = 1;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (error || nd &lt; 3) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s is not a valid PGM file!\n&quot;</FONT></B>), fname);
    fclose (fp);  <B><FONT COLOR="#A020F0">return</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (dim[0] != width || dim[1] != height || dim[2] != 65535) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s has the wrong dimensions!\n&quot;</FONT></B>), fname);
    fclose (fp);  <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  pixel = (ushort *) calloc (width, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *pixel);
  merror (pixel, <B><FONT COLOR="#BC8F8F">&quot;subtract()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++) {
    fread (pixel, 2, width, fp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++)
      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);
  }
  free (pixel);
  fclose (fp);
  memset (cblack, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cblack);
  black = 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">gamma_curve</FONT></B> (<B><FONT COLOR="#228B22">double</FONT></B> pwr, <B><FONT COLOR="#228B22">double</FONT></B> ts, <B><FONT COLOR="#228B22">int</FONT></B> mode, <B><FONT COLOR="#228B22">int</FONT></B> imax)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#228B22">double</FONT></B> g[6], bnd[2]={0,0}, r;

  g[0] = pwr;
  g[1] = ts;
  g[2] = g[3] = g[4] = 0;
  bnd[g[1] &gt;= 1] = 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (g[1] &amp;&amp; (g[1]-1)*(g[0]-1) &lt;= 0) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 48; i++) {
      g[2] = (bnd[0] + bnd[1])/2;
      <B><FONT COLOR="#A020F0">if</FONT></B> (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] &gt; -1] = g[2];
      <B><FONT COLOR="#A020F0">else</FONT></B>	bnd[g[2]/exp(1-1/g[2]) &lt; g[1]] = g[2];
    }
    g[3] = g[2] / g[1];
    <B><FONT COLOR="#A020F0">if</FONT></B> (g[0]) g[4] = g[2] * (1/g[0] - 1);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +
		(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;
  <B><FONT COLOR="#A020F0">else</FONT></B>      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1
		- g[2] - g[3] -	g[2]*g[3]*(log(g[3]) - 1)) - 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!mode--) {
    memcpy (gamm, g, <B><FONT COLOR="#A020F0">sizeof</FONT></B> gamm);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 0x10000; i++) {
    curve[i] = 0xffff;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((r = (<B><FONT COLOR="#228B22">double</FONT></B>) i / imax) &lt; 1)
      curve[i] = 0x10000 * ( mode
	? (r &lt; g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))
	: (r &lt; g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">pseudoinverse</FONT></B> (<B><FONT COLOR="#228B22">double</FONT></B> (*in)[3], <B><FONT COLOR="#228B22">double</FONT></B> (*out)[3], <B><FONT COLOR="#228B22">int</FONT></B> size)
{
  <B><FONT COLOR="#228B22">double</FONT></B> work[3][6], num;
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 6; j++)
      work[i][j] = j == i+3;
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (k=0; k &lt; size; k++)
	work[i][j] += in[k][i] * in[k][j];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++) {
    num = work[i][i];
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 6; j++)
      work[i][j] /= num;
    <B><FONT COLOR="#A020F0">for</FONT></B> (k=0; k &lt; 3; k++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (k==i) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      num = work[k][i];
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 6; j++)
	work[k][j] -= work[i][j] * num;
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (out[i][j]=k=0; k &lt; 3; k++)
	out[i][j] += work[j][k+3] * in[i][k];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">cam_xyz_coeff</FONT></B> (<B><FONT COLOR="#228B22">float</FONT></B> rgb_cam[3][4], <B><FONT COLOR="#228B22">double</FONT></B> cam_xyz[4][3])
{
  <B><FONT COLOR="#228B22">double</FONT></B> cam_rgb[4][3], inverse[4][3], num;
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; colors; i++)		<I><FONT COLOR="#B22222">/* Multiply out XYZ colorspace */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (cam_rgb[i][j] = k=0; k &lt; 3; k++)
	cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; colors; i++) {		<I><FONT COLOR="#B22222">/* Normalize cam_rgb so that */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (num=j=0; j &lt; 3; j++)		<I><FONT COLOR="#B22222">/* cam_rgb * (1,1,1) is (1,1,1,1) */</FONT></I>
      num += cam_rgb[i][j];
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      cam_rgb[i][j] /= num;
    pre_mul[i] = 1 / num;
  }
  pseudoinverse (cam_rgb, inverse, colors);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; colors; j++)
      rgb_cam[i][j] = inverse[j][i];
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">COLORCHECK</FONT>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">colorcheck</FONT></B>()
{
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">NSQ</FONT> 24
<I><FONT COLOR="#B22222">// Coordinates of the GretagMacbeth ColorChecker squares
</FONT></I><I><FONT COLOR="#B22222">// width, height, 1st_column, 1st_row
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> cut[NSQ][4];			<I><FONT COLOR="#B22222">// you must set these
</FONT></I><I><FONT COLOR="#B22222">// ColorChecker Chart under 6500-kelvin illumination
</FONT></I>  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> gmb_xyY[NSQ][3] = {
    { 0.400, 0.350, 10.1 },		<I><FONT COLOR="#B22222">// Dark Skin
</FONT></I>    { 0.377, 0.345, 35.8 },		<I><FONT COLOR="#B22222">// Light Skin
</FONT></I>    { 0.247, 0.251, 19.3 },		<I><FONT COLOR="#B22222">// Blue Sky
</FONT></I>    { 0.337, 0.422, 13.3 },		<I><FONT COLOR="#B22222">// Foliage
</FONT></I>    { 0.265, 0.240, 24.3 },		<I><FONT COLOR="#B22222">// Blue Flower
</FONT></I>    { 0.261, 0.343, 43.1 },		<I><FONT COLOR="#B22222">// Bluish Green
</FONT></I>    { 0.506, 0.407, 30.1 },		<I><FONT COLOR="#B22222">// Orange
</FONT></I>    { 0.211, 0.175, 12.0 },		<I><FONT COLOR="#B22222">// Purplish Blue
</FONT></I>    { 0.453, 0.306, 19.8 },		<I><FONT COLOR="#B22222">// Moderate Red
</FONT></I>    { 0.285, 0.202, 6.6 },		<I><FONT COLOR="#B22222">// Purple
</FONT></I>    { 0.380, 0.489, 44.3 },		<I><FONT COLOR="#B22222">// Yellow Green
</FONT></I>    { 0.473, 0.438, 43.1 },		<I><FONT COLOR="#B22222">// Orange Yellow
</FONT></I>    { 0.187, 0.129, 6.1 },		<I><FONT COLOR="#B22222">// Blue
</FONT></I>    { 0.305, 0.478, 23.4 },		<I><FONT COLOR="#B22222">// Green
</FONT></I>    { 0.539, 0.313, 12.0 },		<I><FONT COLOR="#B22222">// Red
</FONT></I>    { 0.448, 0.470, 59.1 },		<I><FONT COLOR="#B22222">// Yellow
</FONT></I>    { 0.364, 0.233, 19.8 },		<I><FONT COLOR="#B22222">// Magenta
</FONT></I>    { 0.196, 0.252, 19.8 },		<I><FONT COLOR="#B22222">// Cyan
</FONT></I>    { 0.310, 0.316, 90.0 },		<I><FONT COLOR="#B22222">// White
</FONT></I>    { 0.310, 0.316, 59.1 },		<I><FONT COLOR="#B22222">// Neutral 8
</FONT></I>    { 0.310, 0.316, 36.2 },		<I><FONT COLOR="#B22222">// Neutral 6.5
</FONT></I>    { 0.310, 0.316, 19.8 },		<I><FONT COLOR="#B22222">// Neutral 5
</FONT></I>    { 0.310, 0.316, 9.0 },		<I><FONT COLOR="#B22222">// Neutral 3.5
</FONT></I>    { 0.310, 0.316, 3.1 } };		<I><FONT COLOR="#B22222">// Black
</FONT></I>  <B><FONT COLOR="#228B22">double</FONT></B> gmb_cam[NSQ][4], gmb_xyz[NSQ][3];
  <B><FONT COLOR="#228B22">double</FONT></B> inverse[NSQ][3], cam_xyz[4][3], balance[4], num;
  <B><FONT COLOR="#228B22">int</FONT></B> c, i, j, k, sq, row, col, pass, count[4];

  memset (gmb_cam, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> gmb_cam);
  <B><FONT COLOR="#A020F0">for</FONT></B> (sq=0; sq &lt; NSQ; sq++) {
    FORCC count[c] = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>   (row=cut[sq][3]; row &lt; cut[sq][3]+cut[sq][1]; row++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=cut[sq][2]; col &lt; cut[sq][2]+cut[sq][0]; col++) {
	c = FC(row,col);
	<B><FONT COLOR="#A020F0">if</FONT></B> (c &gt;= colors) c -= 2;
	gmb_cam[sq][c] += BAYER2(row,col);
	BAYER2(row,col) = black + (BAYER2(row,col)-black)/2;
	count[c]++;
      }
    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;
    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];
    gmb_xyz[sq][1] = gmb_xyY[sq][2];
    gmb_xyz[sq][2] = gmb_xyY[sq][2] *
		(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];
  }
  pseudoinverse (gmb_xyz, inverse, NSQ);
  <B><FONT COLOR="#A020F0">for</FONT></B> (pass=0; pass &lt; 2; pass++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = i=0; i &lt; colors; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (cam_xyz[i][j] = k=0; k &lt; NSQ; k++)
	  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];
    cam_xyz_coeff (rgb_cam, cam_xyz);
    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];
    <B><FONT COLOR="#A020F0">for</FONT></B> (sq=0; sq &lt; NSQ; sq++)
      FORCC gmb_cam[sq][c] *= balance[c];
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) {
    printf (<B><FONT COLOR="#BC8F8F">&quot;    { \&quot;%s %s\&quot;, %d,\n\t{&quot;</FONT></B>, make, model, black);
    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);
    FORCC <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      printf (<B><FONT COLOR="#BC8F8F">&quot;%c%d&quot;</FONT></B>, (c | j) ? <B><FONT COLOR="#BC8F8F">','</FONT></B>:<B><FONT COLOR="#BC8F8F">' '</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) (cam_xyz[c][j] * num + 0.5));
    puts (<B><FONT COLOR="#BC8F8F">&quot; } },&quot;</FONT></B>);
  }
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">NSQ</FONT>
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">hat_transform</FONT></B> (<B><FONT COLOR="#228B22">float</FONT></B> *temp, <B><FONT COLOR="#228B22">float</FONT></B> *base, <B><FONT COLOR="#228B22">int</FONT></B> st, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">int</FONT></B> sc)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; sc; i++)
    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];
  <B><FONT COLOR="#A020F0">for</FONT></B> (; i+sc &lt; size; i++)
    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];
  <B><FONT COLOR="#A020F0">for</FONT></B> (; i &lt; size; i++)
    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">wavelet_denoise</FONT></B>()
{
  <B><FONT COLOR="#228B22">float</FONT></B> *fimg=0, *temp, thold, mul[2], avg, diff;
  <B><FONT COLOR="#228B22">int</FONT></B> scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];
  ushort *window[4];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> noise[] =
  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Wavelet denoising...\n&quot;</FONT></B>));

  <B><FONT COLOR="#A020F0">while</FONT></B> (maximum &lt;&lt; scale &lt; 0x10000) scale++;
  maximum &lt;&lt;= --scale;
  black &lt;&lt;= scale;
  FORC4 cblack[c] &lt;&lt;= scale;
  <B><FONT COLOR="#A020F0">if</FONT></B> ((size = iheight*iwidth) &lt; 0x15550000)
    fimg = (<B><FONT COLOR="#228B22">float</FONT></B> *) malloc ((size*3 + iheight + iwidth) * <B><FONT COLOR="#A020F0">sizeof</FONT></B> *fimg);
  merror (fimg, <B><FONT COLOR="#BC8F8F">&quot;wavelet_denoise()&quot;</FONT></B>);
  temp = fimg + size*3;
  <B><FONT COLOR="#A020F0">if</FONT></B> ((nc = colors) == 3 &amp;&amp; filters) nc++;
  FORC(nc) {			<I><FONT COLOR="#B22222">/* denoise R,G1,B,G3 individually */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
      fimg[i] = 256 * sqrt(image[i][c] &lt;&lt; scale);
    <B><FONT COLOR="#A020F0">for</FONT></B> (hpass=lev=0; lev &lt; 5; lev++) {
      lpass = size*((lev &amp; 1)+1);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; iheight; row++) {
	hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 &lt;&lt; lev);
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; iwidth; col++)
	  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; iwidth; col++) {
	hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 &lt;&lt; lev);
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; iheight; row++)
	  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;
      }
      thold = threshold * noise[lev];
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++) {
	fimg[hpass+i] -= fimg[lpass+i];
	<B><FONT COLOR="#A020F0">if</FONT></B>	(fimg[hpass+i] &lt; -thold) fimg[hpass+i] += thold;
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fimg[hpass+i] &gt;  thold) fimg[hpass+i] -= thold;
	<B><FONT COLOR="#A020F0">else</FONT></B>	 fimg[hpass+i] = 0;
	<B><FONT COLOR="#A020F0">if</FONT></B> (hpass) fimg[i] += fimg[hpass+i];
      }
      hpass = lpass;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters &amp;&amp; colors == 3) {  <I><FONT COLOR="#B22222">/* pull G1 and G3 closer together */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 2; row++) {
      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];
      blk[row] = cblack[FC(row,0) | 1];
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
      window[i] = (ushort *) fimg + width*i;
    <B><FONT COLOR="#A020F0">for</FONT></B> (wlast=-1, row=1; row &lt; height-1; row++) {
      <B><FONT COLOR="#A020F0">while</FONT></B> (wlast &lt; row+1) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (wlast++, i=0; i &lt; 4; i++)
	  window[(i+3) &amp; 3] = window[i];
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = FC(wlast,1) &amp; 1; col &lt; width; col+=2)
	  window[2][col] = BAYER(wlast,col);
      }
      thold = threshold/512;
      <B><FONT COLOR="#A020F0">for</FONT></B> (col = (FC(row,0) &amp; 1)+1; col &lt; width-1; col+=2) {
	avg = ( window[0][col-1] + window[0][col+1] +
		window[2][col-1] + window[2][col+1] - blk[~row &amp; 1]*4 )
	      * mul[row &amp; 1] + (window[1][col] + blk[row &amp; 1]) * 0.5;
	avg = avg &lt; 0 ? 0 : sqrt(avg);
	diff = sqrt(BAYER(row,col)) - avg;
	<B><FONT COLOR="#A020F0">if</FONT></B>      (diff &lt; -thold) diff += thold;
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (diff &gt;  thold) diff -= thold;
	<B><FONT COLOR="#A020F0">else</FONT></B> diff = 0;
	BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);
      }
    }
  }
  free (fimg);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">scale_colors</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];
  <B><FONT COLOR="#228B22">int</FONT></B> val, dark, sat;
  <B><FONT COLOR="#228B22">double</FONT></B> dsum[8], dmin, dmax;
  <B><FONT COLOR="#228B22">float</FONT></B> scale_mul[4], fr, fc;
  ushort *img=0, *pix;

  <B><FONT COLOR="#A020F0">if</FONT></B> (user_mul[0])
    memcpy (pre_mul, user_mul, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pre_mul);
  <B><FONT COLOR="#A020F0">if</FONT></B> (use_auto_wb || (use_camera_wb &amp;&amp; cam_mul[0] == -1)) {
    memset (dsum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> dsum);
    bottom = MIN (greybox[1]+greybox[3], height);
    right  = MIN (greybox[0]+greybox[2], width);
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=greybox[1]; row &lt; bottom; row += 8)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=greybox[0]; col &lt; right; col += 8) {
	memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
	<B><FONT COLOR="#A020F0">for</FONT></B> (y=row; y &lt; row+8 &amp;&amp; y &lt; bottom; y++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (x=col; x &lt; col+8 &amp;&amp; x &lt; right; x++)
	    FORC4 {
	      <B><FONT COLOR="#A020F0">if</FONT></B> (filters) {
		c = fcol(y,x);
		val = BAYER2(y,x);
	      } <B><FONT COLOR="#A020F0">else</FONT></B>
		val = image[y*width+x][c];
	      <B><FONT COLOR="#A020F0">if</FONT></B> (val &gt; maximum-25) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">skip_block</FONT></B>;
	      <B><FONT COLOR="#A020F0">if</FONT></B> ((val -= cblack[c]) &lt; 0) val = 0;
	      sum[c] += val;
	      sum[c+4]++;
	      <B><FONT COLOR="#A020F0">if</FONT></B> (filters) <B><FONT COLOR="#A020F0">break</FONT></B>;
	    }
	FORC(8) dsum[c] += sum[c];
<B><FONT COLOR="#5F9EA0">skip_block</FONT></B>: ;
      }
    FORC4 <B><FONT COLOR="#A020F0">if</FONT></B> (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (use_camera_wb &amp;&amp; cam_mul[0] != -1) {
    memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
    <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 8; row++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; 8; col++) {
	c = FC(row,col);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((val = white[row][col] - cblack[c]) &gt; 0)
	  sum[c] += val;
	sum[c+4]++;
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> (sum[0] &amp;&amp; sum[1] &amp;&amp; sum[2] &amp;&amp; sum[3])
      FORC4 pre_mul[c] = (<B><FONT COLOR="#228B22">float</FONT></B>) sum[c+4] / sum[c];
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (cam_mul[0] &amp;&amp; cam_mul[2])
      memcpy (pre_mul, cam_mul, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pre_mul);
    <B><FONT COLOR="#A020F0">else</FONT></B>
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: Cannot use camera white balance.\n&quot;</FONT></B>), ifname);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (pre_mul[1] == 0) pre_mul[1] = 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (pre_mul[3] == 0) pre_mul[3] = colors &lt; 4 ? pre_mul[1] : 1;
  dark = black;
  sat = maximum;
  <B><FONT COLOR="#A020F0">if</FONT></B> (threshold) wavelet_denoise();
  maximum -= black;
  <B><FONT COLOR="#A020F0">for</FONT></B> (dmin=DBL_MAX, dmax=c=0; c &lt; 4; c++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (dmin &gt; pre_mul[c])
	dmin = pre_mul[c];
    <B><FONT COLOR="#A020F0">if</FONT></B> (dmax &lt; pre_mul[c])
	dmax = pre_mul[c];
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!highlight) dmax = dmin;
  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) {
    fprintf (stderr,
      _(<B><FONT COLOR="#BC8F8F">&quot;Scaling with darkness %d, saturation %d, and\nmultipliers&quot;</FONT></B>), dark, sat);
    FORC4 fprintf (stderr, <B><FONT COLOR="#BC8F8F">&quot; %f&quot;</FONT></B>, pre_mul[c]);
    fputc (<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>, stderr);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters &gt; 1000 &amp;&amp; (cblack[4]+1)/2 == 1 &amp;&amp; (cblack[5]+1)/2 == 1) {
    FORC4 cblack[FC(c/2,c%2)] +=
	cblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];
    cblack[4] = cblack[5] = 0;
  }
  size = iheight*iwidth;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size*4; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(val = ((ushort *)image)[i])) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (cblack[4] &amp;&amp; cblack[5])
      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +
			i/4 % iwidth % cblack[5]];
    val -= cblack[i &amp; 3];
    val *= scale_mul[i &amp; 3];
    ((ushort *)image)[i] = CLIP(val);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> ((aber[0] != 1 || aber[2] != 1) &amp;&amp; colors == 3) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Correcting chromatic aberration...\n&quot;</FONT></B>));
    <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 4; c+=2) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (aber[c] == 1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      img = (ushort *) malloc (size * <B><FONT COLOR="#A020F0">sizeof</FONT></B> *img);
      merror (img, <B><FONT COLOR="#BC8F8F">&quot;scale_colors()&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; size; i++)
	img[i] = image[i][c];
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; iheight; row++) {
	ur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;
	<B><FONT COLOR="#A020F0">if</FONT></B> (ur &gt; iheight-2) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	fr -= ur;
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; iwidth; col++) {
	  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (uc &gt; iwidth-2) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  fc -= uc;
	  pix = img + ur*iwidth + uc;
	  image[row*iwidth+col][c] =
	    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +
	    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;
	}
      }
      free(img);
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">pre_interpolate</FONT></B>()
{
  ushort (*img)[4];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, c;

  <B><FONT COLOR="#A020F0">if</FONT></B> (shrink) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (half_size) {
      height = iheight;
      width  = iwidth;
      <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 3; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=1; col &lt; 4; col++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (!(image[row*width+col][0] | image[row*width+col][2]))
	      <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">break2</FONT></B>;  break2:
	<B><FONT COLOR="#A020F0">for</FONT></B> ( ; row &lt; height; row+=3)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=(col-1)%3+1; col &lt; width-1; col+=3) {
	    img = image + row*width+col;
	    <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 3; c+=2)
	      img[0][c] = (img[-1][c] + img[1][c]) &gt;&gt; 1;
	  }
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      img = (ushort (*)[4]) calloc (height, width*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *img);
      merror (img, <B><FONT COLOR="#BC8F8F">&quot;pre_interpolate()&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
	  c = fcol(row,col);
	  img[row*width+col][c] = image[(row &gt;&gt; 1)*iwidth+(col &gt;&gt; 1)][c];
	}
      free (image);
      image = img;
      shrink = 0;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters &gt; 1000 &amp;&amp; colors == 3) {
    mix_green = four_color_rgb ^ half_size;
    <B><FONT COLOR="#A020F0">if</FONT></B> (four_color_rgb | half_size) colors++;
    <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">for</FONT></B> (row = FC(1,0) &gt;&gt; 1; row &lt; height; row+=2)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = FC(row,1) &amp; 1; col &lt; width; col+=2)
	  image[row*width+col][1] = image[row*width+col][3];
      filters &amp;= ~((filters &amp; 0x55555555) &lt;&lt; 1);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (half_size) filters = 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">border_interpolate</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> border)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> row, col, y, x, f, c, sum[8];

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (col==border &amp;&amp; row &gt;= border &amp;&amp; row &lt; height-border)
	col = width-border;
      memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
      <B><FONT COLOR="#A020F0">for</FONT></B> (y=row-1; y != row+2; y++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (x=col-1; x != col+2; x++)
	  <B><FONT COLOR="#A020F0">if</FONT></B> (y &lt; height &amp;&amp; x &lt; width) {
	    f = fcol(y,x);
	    sum[f] += image[y*width+x][f];
	    sum[f+4]++;
	  }
      f = fcol(row,col);
      FORCC <B><FONT COLOR="#A020F0">if</FONT></B> (c != f &amp;&amp; sum[c+4])
	image[row*width+col][c] = sum[c] / sum[c+4];
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">lin_interpolate</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> code[16][16][32], size=16, *ip, sum[4];
  <B><FONT COLOR="#228B22">int</FONT></B> f, c, i, x, y, row, col, shift, color;
  ushort *pix;

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Bilinear interpolation...\n&quot;</FONT></B>));
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) size = 6;
  border_interpolate(1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; size; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; size; col++) {
      ip = code[row][col]+1;
      f = fcol(row,col);
      memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
      <B><FONT COLOR="#A020F0">for</FONT></B> (y=-1; y &lt;= 1; y++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (x=-1; x &lt;= 1; x++) {
	  shift = (y==0) + (x==0);
	  color = fcol(row+y,col+x);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (color == f) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  *ip++ = (width*y + x)*4 + color;
	  *ip++ = shift;
	  *ip++ = color;
	  sum[color] += 1 &lt;&lt; shift;
	}
      code[row][col][0] = (ip - code[row][col]) / 3;
      FORCC
	<B><FONT COLOR="#A020F0">if</FONT></B> (c != f) {
	  *ip++ = c;
	  *ip++ = 256 / sum[c];
	}
    }
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt; height-1; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=1; col &lt; width-1; col++) {
      pix = image[row*width+col];
      ip = code[row % size][col % size];
      memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=*ip++; i--; ip+=3)
	sum[ip[2]] += pix[ip[0]] &lt;&lt; ip[1];
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=colors; --i; ip+=2)
	pix[ip[0]] = sum[ip[0]] * ip[1] &gt;&gt; 8;
    }
}

<I><FONT COLOR="#B22222">/*
   This algorithm is officially called:

   &quot;Interpolation using a Threshold-based variable number of gradients&quot;

   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html

   I've extended the basic idea to work with non-Bayer filter arrays.
   Gradients are numbered clockwise from NW=0 to W=7.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">vng_interpolate</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *cp, terms[] = {
    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,
    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,
    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,
    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,
    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,
    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,
    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,
    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,
    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,
    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,
    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,
    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,
    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,
    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,
    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,
    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,
    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,
    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,
    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,
    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,
    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,
    +1,+0,+2,+1,0,0x10
  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };
  ushort (*brow[5])[4], *pix;
  <B><FONT COLOR="#228B22">int</FONT></B> prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;
  <B><FONT COLOR="#228B22">int</FONT></B> g, diff, thold, num, c;

  lin_interpolate();
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;VNG interpolation...\n&quot;</FONT></B>));

  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 1) prow = pcol = 16;
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) prow = pcol =  6;
  ip = (<B><FONT COLOR="#228B22">int</FONT></B> *) calloc (prow*pcol, 1280);
  merror (ip, <B><FONT COLOR="#BC8F8F">&quot;vng_interpolate()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; prow; row++)		<I><FONT COLOR="#B22222">/* Precalculate for VNG */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; pcol; col++) {
      code[row][col] = ip;
      <B><FONT COLOR="#A020F0">for</FONT></B> (cp=terms, t=0; t &lt; 64; t++) {
	y1 = *cp++;  x1 = *cp++;
	y2 = *cp++;  x2 = *cp++;
	weight = *cp++;
	grads = *cp++;
	color = fcol(row+y1,col+x1);
	<B><FONT COLOR="#A020F0">if</FONT></B> (fcol(row+y2,col+x2) != color) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	diag = (fcol(row,col+1) == color &amp;&amp; fcol(row+1,col) == color) ? 2:1;
	<B><FONT COLOR="#A020F0">if</FONT></B> (abs(y1-y2) == diag &amp;&amp; abs(x1-x2) == diag) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	*ip++ = (y1*width + x1)*4 + color;
	*ip++ = (y2*width + x2)*4 + color;
	*ip++ = weight;
	<B><FONT COLOR="#A020F0">for</FONT></B> (g=0; g &lt; 8; g++)
	  <B><FONT COLOR="#A020F0">if</FONT></B> (grads &amp; 1&lt;&lt;g) *ip++ = g;
	*ip++ = -1;
      }
      *ip++ = INT_MAX;
      <B><FONT COLOR="#A020F0">for</FONT></B> (cp=chood, g=0; g &lt; 8; g++) {
	y = *cp++;  x = *cp++;
	*ip++ = (y*width + x) * 4;
	color = fcol(row,col);
	<B><FONT COLOR="#A020F0">if</FONT></B> (fcol(row+y,col+x) != color &amp;&amp; fcol(row+y*2,col+x*2) == color)
	  *ip++ = (y*width + x) * 8 + color;
	<B><FONT COLOR="#A020F0">else</FONT></B>
	  *ip++ = 0;
      }
    }
  brow[4] = (ushort (*)[4]) calloc (width*3, <B><FONT COLOR="#A020F0">sizeof</FONT></B> **brow);
  merror (brow[4], <B><FONT COLOR="#BC8F8F">&quot;vng_interpolate()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 3; row++)
    brow[row] = brow[4] + row*width;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height-2; row++) {		<I><FONT COLOR="#B22222">/* Do VNG interpolation */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; width-2; col++) {
      pix = image[row*width+col];
      ip = code[row % prow][col % pcol];
      memset (gval, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> gval);
      <B><FONT COLOR="#A020F0">while</FONT></B> ((g = ip[0]) != INT_MAX) {		<I><FONT COLOR="#B22222">/* Calculate gradients */</FONT></I>
	diff = ABS(pix[g] - pix[ip[1]]) &lt;&lt; ip[2];
	gval[ip[3]] += diff;
	ip += 5;
	<B><FONT COLOR="#A020F0">if</FONT></B> ((g = ip[-1]) == -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	gval[g] += diff;
	<B><FONT COLOR="#A020F0">while</FONT></B> ((g = *ip++) != -1)
	  gval[g] += diff;
      }
      ip++;
      gmin = gmax = gval[0];			<I><FONT COLOR="#B22222">/* Choose a threshold */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (g=1; g &lt; 8; g++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (gmin &gt; gval[g]) gmin = gval[g];
	<B><FONT COLOR="#A020F0">if</FONT></B> (gmax &lt; gval[g]) gmax = gval[g];
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (gmax == 0) {
	memcpy (brow[2][col], pix, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
	<B><FONT COLOR="#A020F0">continue</FONT></B>;
      }
      thold = gmin + (gmax &gt;&gt; 1);
      memset (sum, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> sum);
      color = fcol(row,col);
      <B><FONT COLOR="#A020F0">for</FONT></B> (num=g=0; g &lt; 8; g++,ip+=2) {		<I><FONT COLOR="#B22222">/* Average the neighbors */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (gval[g] &lt;= thold) {
	  FORCC
	    <B><FONT COLOR="#A020F0">if</FONT></B> (c == color &amp;&amp; ip[1])
	      sum[c] += (pix[c] + pix[ip[1]]) &gt;&gt; 1;
	    <B><FONT COLOR="#A020F0">else</FONT></B>
	      sum[c] += pix[ip[0] + c];
	  num++;
	}
      }
      FORCC {					<I><FONT COLOR="#B22222">/* Save to buffer */</FONT></I>
	t = pix[color];
	<B><FONT COLOR="#A020F0">if</FONT></B> (c != color)
	  t += (sum[c] - sum[color]) / num;
	brow[2][col][c] = CLIP(t);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (row &gt; 3)				<I><FONT COLOR="#B22222">/* Write buffer to image */</FONT></I>
      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
    <B><FONT COLOR="#A020F0">for</FONT></B> (g=0; g &lt; 4; g++)
      brow[(g-1) &amp; 3] = brow[g];
  }
  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
  free (brow[4]);
  free (code[0][0]);
}

<I><FONT COLOR="#B22222">/*
   Patterned Pixel Grouping Interpolation by Alain Desbiolles
*/</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ppg_interpolate</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> dir[5] = { 1, width, -1, -width, 1 };
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, diff[2], guess[2], c, d, i;
  ushort (*pix)[4];

  border_interpolate(3);
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;PPG interpolation...\n&quot;</FONT></B>));

<I><FONT COLOR="#B22222">/*  Fill in the green layer with gradients and pattern recognition: */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=3; row &lt; height-3; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=3+(FC(row,3) &amp; 1), c=FC(row,col); col &lt; width-3; col+=2) {
      pix = image + row*width+col;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; (d=dir[i]) &gt; 0; i++) {
	guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2
		      - pix[-2*d][c] - pix[2*d][c];
	diff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +
		    ABS(pix[ 2*d][c] - pix[ 0][c]) +
		    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +
		  ( ABS(pix[ 3*d][1] - pix[ d][1]) +
		    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;
      }
      d = dir[i = diff[0] &gt; diff[1]];
      pix[0][1] = ULIM(guess[i] &gt;&gt; 2, pix[d][1], pix[-d][1]);
    }
<I><FONT COLOR="#B22222">/*  Calculate red and blue for each green pixel:		*/</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt; height-1; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=1+(FC(row,2) &amp; 1), c=FC(row,col+1); col &lt; width-1; col+=2) {
      pix = image + row*width+col;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; (d=dir[i]) &gt; 0; c=2-c, i++)
	pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]
			- pix[-d][1] - pix[d][1]) &gt;&gt; 1);
    }
<I><FONT COLOR="#B22222">/*  Calculate blue for red pixels and vice versa:		*/</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=1; row &lt; height-1; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=1+(FC(row,1) &amp; 1), c=2-FC(row,col); col &lt; width-1; col+=2) {
      pix = image + row*width+col;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; (d=dir[i]+dir[i+1]) &gt; 0; i++) {
	diff[i] = ABS(pix[-d][c] - pix[d][c]) +
		  ABS(pix[-d][1] - pix[0][1]) +
		  ABS(pix[ d][1] - pix[0][1]);
	guess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]
		 - pix[-d][1] - pix[d][1];
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (diff[0] != diff[1])
	pix[0][c] = CLIP(guess[diff[0] &gt; diff[1]] &gt;&gt; 1);
      <B><FONT COLOR="#A020F0">else</FONT></B>
	pix[0][c] = CLIP((guess[0]+guess[1]) &gt;&gt; 2);
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">cielab</FONT></B> (ushort rgb[3], <B><FONT COLOR="#228B22">short</FONT></B> lab[3])
{
  <B><FONT COLOR="#228B22">int</FONT></B> c, i, j, k;
  <B><FONT COLOR="#228B22">float</FONT></B> r, xyz[3];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> cbrt[0x10000], xyz_cam[3][4];

  <B><FONT COLOR="#A020F0">if</FONT></B> (!rgb) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 0x10000; i++) {
      r = i / 65535.0;
      cbrt[i] = r &gt; 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; colors; j++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (xyz_cam[i][j] = k=0; k &lt; 3; k++)
	  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  xyz[0] = xyz[1] = xyz[2] = 0.5;
  FORCC {
    xyz[0] += xyz_cam[0][c] * rgb[c];
    xyz[1] += xyz_cam[1][c] * rgb[c];
    xyz[2] += xyz_cam[2][c] * rgb[c];
  }
  xyz[0] = cbrt[CLIP((<B><FONT COLOR="#228B22">int</FONT></B>) xyz[0])];
  xyz[1] = cbrt[CLIP((<B><FONT COLOR="#228B22">int</FONT></B>) xyz[1])];
  xyz[2] = cbrt[CLIP((<B><FONT COLOR="#228B22">int</FONT></B>) xyz[2])];
  lab[0] = 64 * (116 * xyz[1] - 16);
  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);
  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">TS</FONT> 512		<I><FONT COLOR="#B22222">/* Tile Size */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">fcol</FONT></B>(row,col) xtrans[(row+6) % 6][(col+6) % 6]

<I><FONT COLOR="#B22222">/*
   Frank Markesteijn's algorithm for Fuji X-Trans sensors
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">xtrans_interpolate</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> passes)
{
  <B><FONT COLOR="#228B22">int</FONT></B> c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;
  <B><FONT COLOR="#228B22">int</FONT></B> val, ndir, pass, hm[8], avg[4], color[3][8];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },
	patt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },
			{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },
	dir[4] = { 1,TS,TS+1,TS-1 };
  <B><FONT COLOR="#228B22">short</FONT></B> allhex[3][3][2][8], *hex;
  ushort min, max, sgrow, sgcol;
  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];
   <B><FONT COLOR="#228B22">short</FONT></B> (*lab)    [TS][3], (*lix)[3];
   <B><FONT COLOR="#228B22">float</FONT></B> (*drv)[TS][TS], diff[6], tr;
   <B><FONT COLOR="#228B22">char</FONT></B> (*homo)[TS][TS], *buffer;

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%d-pass X-Trans interpolation...\n&quot;</FONT></B>), passes);

  cielab (0,0);
  ndir = 4 &lt;&lt; (passes &gt; 1);
  buffer = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (TS*TS*(ndir*11+6));
  merror (buffer, <B><FONT COLOR="#BC8F8F">&quot;xtrans_interpolate()&quot;</FONT></B>);
  rgb  = (ushort(*)[TS][TS][3]) buffer;
  lab  = (<B><FONT COLOR="#228B22">short</FONT></B> (*)    [TS][3])(buffer + TS*TS*(ndir*6));
  drv  = (<B><FONT COLOR="#228B22">float</FONT></B> (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));
  homo = (<B><FONT COLOR="#228B22">char</FONT></B>  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));

<I><FONT COLOR="#B22222">/* Map a green hexagon around each non-green pixel and vice versa:	*/</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; 3; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; 3; col++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (ng=d=0; d &lt; 10; d+=2) {
	g = fcol(row,col) == 1;
	<B><FONT COLOR="#A020F0">if</FONT></B> (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; <B><FONT COLOR="#A020F0">else</FONT></B> ng++;
	<B><FONT COLOR="#A020F0">if</FONT></B> (ng == 4) { sgrow = row; sgcol = col; }
	<B><FONT COLOR="#A020F0">if</FONT></B> (ng == g+1) FORC(8) {
	  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];
	  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];
	  allhex[row][col][0][c^(g*2 &amp; d)] = h + v*width;
	  allhex[row][col][1][c^(g*2 &amp; d)] = h + v*TS;
	}
      }

<I><FONT COLOR="#B22222">/* Set green1 and green3 to the minimum and maximum allowed values:	*/</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; height-2; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (min=~(max=0), col=2; col &lt; width-2; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (fcol(row,col) == 1 &amp;&amp; (min=~(max=0))) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      pix = image + row*width + col;
      hex = allhex[row % 3][col % 3][0];
      <B><FONT COLOR="#A020F0">if</FONT></B> (!max) FORC(6) {
	val = pix[hex[c]][1];
	<B><FONT COLOR="#A020F0">if</FONT></B> (min &gt; val) min = val;
	<B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; val) max = val;
      }
      pix[0][1] = min;
      pix[0][3] = max;
      <B><FONT COLOR="#A020F0">switch</FONT></B> ((row-sgrow) % 3) {
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>: <B><FONT COLOR="#A020F0">if</FONT></B> (row &lt; height-3) { row++; col--; } <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: <B><FONT COLOR="#A020F0">if</FONT></B> ((min=~(max=0)) &amp;&amp; (col+=2) &lt; width-3 &amp;&amp; row &gt; 2) row--;
      }
    }

  <B><FONT COLOR="#A020F0">for</FONT></B> (top=3; top &lt; height-19; top += TS-16)
    <B><FONT COLOR="#A020F0">for</FONT></B> (left=3; left &lt; width-19; left += TS-16) {
      mrow = MIN (top+TS, height-3);
      mcol = MIN (left+TS, width-3);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=top; row &lt; mrow; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=left; col &lt; mcol; col++)
	  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);
      FORC3 memcpy (rgb[c+1], rgb[0], <B><FONT COLOR="#A020F0">sizeof</FONT></B> *rgb);

<I><FONT COLOR="#B22222">/* Interpolate green horizontally, vertically, and along both diagonals: */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=top; row &lt; mrow; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=left; col &lt; mcol; col++) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((f = fcol(row,col)) == 1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  pix = image + row*width + col;
	  hex = allhex[row % 3][col % 3][0];
	  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -
			 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);
	  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +
			 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);
	  FORC(2) color[1][2+c] =
		164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *
		(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);
	  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =
		LIM(color[1][c] &gt;&gt; 8,pix[0][1],pix[0][3]);
	}

      <B><FONT COLOR="#A020F0">for</FONT></B> (pass=0; pass &lt; passes; pass++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (pass == 1)
	  memcpy (rgb+=4, buffer, 4*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *rgb);

<I><FONT COLOR="#B22222">/* Recalculate green from interpolated values of closer pixels:	*/</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (pass) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (row=top+2; row &lt; mrow-2; row++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (col=left+2; col &lt; mcol-2; col++) {
	      <B><FONT COLOR="#A020F0">if</FONT></B> ((f = fcol(row,col)) == 1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	      pix = image + row*width + col;
	      hex = allhex[row % 3][col % 3][1];
	      <B><FONT COLOR="#A020F0">for</FONT></B> (d=3; d &lt; 6; d++) {
		rix = &amp;rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];
		val = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]
		    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];
		rix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);
	      }
	    }
	}

<I><FONT COLOR="#B22222">/* Interpolate red and blue values for solitary green pixels:	*/</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=(top-sgrow+4)/3*3+sgrow; row &lt; mrow-2; row+=3)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=(left-sgcol+4)/3*3+sgcol; col &lt; mcol-2; col+=3) {
	    rix = &amp;rgb[0][row-top][col-left];
	    h = fcol(row,col+1);
	    memset (diff, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> diff);
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=1, d=0; d &lt; 6; d++, i^=TS^1, h^=2) {
	      <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 2; c++, h^=2) {
		g = 2*rix[0][1] - rix[i&lt;&lt;c][1] - rix[-i&lt;&lt;c][1];
		color[h][d] = g + rix[i&lt;&lt;c][h] + rix[-i&lt;&lt;c][h];
		<B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; 1)
		  diff[d] += SQR (rix[i&lt;&lt;c][1] - rix[-i&lt;&lt;c][1]
				- rix[i&lt;&lt;c][h] + rix[-i&lt;&lt;c][h]) + SQR(g);
	      }
	      <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; 1 &amp;&amp; (d &amp; 1))
		<B><FONT COLOR="#A020F0">if</FONT></B> (diff[d-1] &lt; diff[d])
		  FORC(2) color[c*2][d] = color[c*2][d-1];
	      <B><FONT COLOR="#A020F0">if</FONT></B> (d &lt; 2 || (d &amp; 1)) {
		FORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);
		rix += TS*TS;
	      }
	    }
	  }

<I><FONT COLOR="#B22222">/* Interpolate red for blue pixels and vice versa:		*/</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=top+3; row &lt; mrow-3; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=left+3; col &lt; mcol-3; col++) {
	    <B><FONT COLOR="#A020F0">if</FONT></B> ((f = 2-fcol(row,col)) == 1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	    rix = &amp;rgb[0][row-top][col-left];
	    c = (row-sgrow) % 3 ? TS:1;
	    h = 3 * (c ^ TS ^ 1);
	    <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 4; d++, rix += TS*TS) {
	      i = d &gt; 1 || ((d ^ c) &amp; 1) ||
		 ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) &lt;
		2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;
	      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +
		  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);
	    }
	  }

<I><FONT COLOR="#B22222">/* Fill in red and blue for 2x2 blocks of green:		*/</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=top+2; row &lt; mrow-2; row++) <B><FONT COLOR="#A020F0">if</FONT></B> ((row-sgrow) % 3)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=left+2; col &lt; mcol-2; col++) <B><FONT COLOR="#A020F0">if</FONT></B> ((col-sgcol) % 3) {
	    rix = &amp;rgb[0][row-top][col-left];
	    hex = allhex[row % 3][col % 3][1];
	    <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir; d+=2, rix += TS*TS)
	      <B><FONT COLOR="#A020F0">if</FONT></B> (hex[d] + hex[d+1]) {
		g = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];
		<B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 4; c+=2) rix[0][c] =
			CLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);
	      } <B><FONT COLOR="#A020F0">else</FONT></B> {
		g = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];
		<B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 4; c+=2) rix[0][c] =
			CLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);
	      }
	  }
      }
      rgb = (ushort(*)[TS][TS][3]) buffer;
      mrow -= top;
      mcol -= left;

<I><FONT COLOR="#B22222">/* Convert to CIELab and differentiate in all directions:	*/</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir; d++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=2; row &lt; mrow-2; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=2; col &lt; mcol-2; col++)
	    cielab (rgb[d][row][col], lab[row][col]);
	<B><FONT COLOR="#A020F0">for</FONT></B> (f=dir[d &amp; 3],row=3; row &lt; mrow-3; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=3; col &lt; mcol-3; col++) {
	    lix = &amp;lab[row][col];
	    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];
	    drv[d][row][col] = SQR(g)
	      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))
	      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));
	  }
      }

<I><FONT COLOR="#B22222">/* Build homogeneity maps from the derivatives:			*/</FONT></I>
      memset(homo, 0, ndir*TS*TS);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=4; row &lt; mrow-4; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=4; col &lt; mcol-4; col++) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (tr=FLT_MAX, d=0; d &lt; ndir; d++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (tr &gt; drv[d][row][col])
		tr = drv[d][row][col];
	  tr *= 8;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir; d++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (v=-1; v &lt;= 1; v++)
	      <B><FONT COLOR="#A020F0">for</FONT></B> (h=-1; h &lt;= 1; h++)
		<B><FONT COLOR="#A020F0">if</FONT></B> (drv[d][row+v][col+h] &lt;= tr)
		  homo[d][row][col]++;
	}

<I><FONT COLOR="#B22222">/* Average the most homogenous pixels for the final result:	*/</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (height-top &lt; TS+4) mrow = height-top+2;
      <B><FONT COLOR="#A020F0">if</FONT></B> (width-left &lt; TS+4) mcol = width-left+2;
      <B><FONT COLOR="#A020F0">for</FONT></B> (row = MIN(top,8); row &lt; mrow-8; row++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (col = MIN(left,8); col &lt; mcol-8; col++) {
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir; d++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (hm[d]=0, v=-2; v &lt;= 2; v++)
	      <B><FONT COLOR="#A020F0">for</FONT></B> (h=-2; h &lt;= 2; h++)
		hm[d] += homo[d][row+v][col+h];
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir-4; d++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (hm[d] &lt; hm[d+4]) hm[d  ] = 0; <B><FONT COLOR="#A020F0">else</FONT></B>
	    <B><FONT COLOR="#A020F0">if</FONT></B> (hm[d] &gt; hm[d+4]) hm[d+4] = 0;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (max=hm[0],d=1; d &lt; ndir; d++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (max &lt; hm[d]) max = hm[d];
	  max -= max &gt;&gt; 3;
	  memset (avg, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> avg);
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; ndir; d++)
	    <B><FONT COLOR="#A020F0">if</FONT></B> (hm[d] &gt;= max) {
	      FORC3 avg[c] += rgb[d][row][col][c];
	      avg[3]++;
	    }
	  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];
	}
    }
  free(buffer);
  border_interpolate(8);
}
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">fcol</FONT>

<I><FONT COLOR="#B22222">/*
   Adaptive Homogeneity-Directed interpolation is based on
   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ahd_interpolate</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, top, left, row, col, tr, tc, c, d, val, hm[2];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dir[4] = { -1, 1, -TS, TS };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> ldiff[2][4], abdiff[2][4], leps, abeps;
  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];
   <B><FONT COLOR="#228B22">short</FONT></B> (*lab)[TS][TS][3], (*lix)[3];
   <B><FONT COLOR="#228B22">char</FONT></B> (*homo)[TS][TS], *buffer;

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;AHD interpolation...\n&quot;</FONT></B>));

  cielab (0,0);
  border_interpolate(5);
  buffer = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (26*TS*TS);
  merror (buffer, <B><FONT COLOR="#BC8F8F">&quot;ahd_interpolate()&quot;</FONT></B>);
  rgb  = (ushort(*)[TS][TS][3]) buffer;
  lab  = (<B><FONT COLOR="#228B22">short</FONT></B> (*)[TS][TS][3])(buffer + 12*TS*TS);
  homo = (<B><FONT COLOR="#228B22">char</FONT></B>  (*)[TS][TS])   (buffer + 24*TS*TS);

  <B><FONT COLOR="#A020F0">for</FONT></B> (top=2; top &lt; height-5; top += TS-6)
    <B><FONT COLOR="#A020F0">for</FONT></B> (left=2; left &lt; width-5; left += TS-6) {

<I><FONT COLOR="#B22222">/*  Interpolate green horizontally and vertically:		*/</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=top; row &lt; top+TS &amp;&amp; row &lt; height-2; row++) {
	col = left + (FC(row,left) &amp; 1);
	<B><FONT COLOR="#A020F0">for</FONT></B> (c = FC(row,col); col &lt; left+TS &amp;&amp; col &lt; width-2; col+=2) {
	  pix = image + row*width+col;
	  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2
		- pix[-2][c] - pix[2][c]) &gt;&gt; 2;
	  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);
	  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2
		- pix[-2*width][c] - pix[2*width][c]) &gt;&gt; 2;
	  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);
	}
      }
<I><FONT COLOR="#B22222">/*  Interpolate red and blue, and convert to CIELab:		*/</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 2; d++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (row=top+1; row &lt; top+TS-1 &amp;&amp; row &lt; height-3; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col=left+1; col &lt; left+TS-1 &amp;&amp; col &lt; width-3; col++) {
	    pix = image + row*width+col;
	    rix = &amp;rgb[d][row-top][col-left];
	    lix = &amp;lab[d][row-top][col-left];
	    <B><FONT COLOR="#A020F0">if</FONT></B> ((c = 2 - FC(row,col)) == 1) {
	      c = FC(row+1,col);
	      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]
				 - rix[-1][1] - rix[1][1] ) &gt;&gt; 1);
	      rix[0][2-c] = CLIP(val);
	      val = pix[0][1] + (( pix[-width][c] + pix[width][c]
				 - rix[-TS][1] - rix[TS][1] ) &gt;&gt; 1);
	    } <B><FONT COLOR="#A020F0">else</FONT></B>
	      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]
				 + pix[+width-1][c] + pix[+width+1][c]
				 - rix[-TS-1][1] - rix[-TS+1][1]
				 - rix[+TS-1][1] - rix[+TS+1][1] + 1) &gt;&gt; 2);
	    rix[0][c] = CLIP(val);
	    c = FC(row,col);
	    rix[0][c] = pix[0][c];
	    cielab (rix[0],lix[0]);
	  }
<I><FONT COLOR="#B22222">/*  Build homogeneity maps from the CIELab images:		*/</FONT></I>
      memset (homo, 0, 2*TS*TS);
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=top+2; row &lt; top+TS-2 &amp;&amp; row &lt; height-4; row++) {
	tr = row-top;
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=left+2; col &lt; left+TS-2 &amp;&amp; col &lt; width-4; col++) {
	  tc = col-left;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 2; d++) {
	    lix = &amp;lab[d][tr][tc];
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++) {
	       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);
	      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])
			   + SQR(lix[0][2]-lix[dir[i]][2]);
	    }
	  }
	  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),
		     MAX(ldiff[1][2],ldiff[1][3]));
	  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),
		      MAX(abdiff[1][2],abdiff[1][3]));
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 2; d++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	      <B><FONT COLOR="#A020F0">if</FONT></B> (ldiff[d][i] &lt;= leps &amp;&amp; abdiff[d][i] &lt;= abeps)
		homo[d][tr][tc]++;
	}
      }
<I><FONT COLOR="#B22222">/*  Combine the most homogenous pixels for the final result:	*/</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=top+3; row &lt; top+TS-3 &amp;&amp; row &lt; height-5; row++) {
	tr = row-top;
	<B><FONT COLOR="#A020F0">for</FONT></B> (col=left+3; col &lt; left+TS-3 &amp;&amp; col &lt; width-5; col++) {
	  tc = col-left;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 2; d++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (hm[d]=0, i=tr-1; i &lt;= tr+1; i++)
	      <B><FONT COLOR="#A020F0">for</FONT></B> (j=tc-1; j &lt;= tc+1; j++)
		hm[d] += homo[d][i][j];
	  <B><FONT COLOR="#A020F0">if</FONT></B> (hm[0] != hm[1])
	    FORC3 image[row*width+col][c] = rgb[hm[1] &gt; hm[0]][tr][tc][c];
	  <B><FONT COLOR="#A020F0">else</FONT></B>
	    FORC3 image[row*width+col][c] =
		(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) &gt;&gt; 1;
	}
      }
    }
  free (buffer);
}
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">TS</FONT>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">median_filter</FONT></B>()
{
  ushort (*pix)[4];
  <B><FONT COLOR="#228B22">int</FONT></B> pass, c, i, j, k, med[9];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar opt[] =	<I><FONT COLOR="#B22222">/* Optimal 9-element median search */</FONT></I>
  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,
    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };

  <B><FONT COLOR="#A020F0">for</FONT></B> (pass=1; pass &lt;= med_passes; pass++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Median filter pass %d...\n&quot;</FONT></B>), pass);
    <B><FONT COLOR="#A020F0">for</FONT></B> (c=0; c &lt; 3; c+=2) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (pix = image; pix &lt; image+width*height; pix++)
	pix[0][3] = pix[0][c];
      <B><FONT COLOR="#A020F0">for</FONT></B> (pix = image+width; pix &lt; image+width*(height-1); pix++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((pix-image+1) % width &lt; 2) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	<B><FONT COLOR="#A020F0">for</FONT></B> (k=0, i = -width; i &lt;= width; i += width)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (j = i-1; j &lt;= i+1; j++)
	    med[k++] = pix[j][3] - pix[j][1];
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> opt; i+=2)
	  <B><FONT COLOR="#A020F0">if</FONT></B>     (med[opt[i]] &gt; med[opt[i+1]])
	    SWAP (med[opt[i]] , med[opt[i+1]]);
	pix[0][c] = CLIP(med[4] + pix[0][1]);
      }
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">blend_highlights</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> clip=INT_MAX, row, col, c, i, j;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> trans[2][4][4] =
  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },
    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> itrans[2][4][4] =
  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },
    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
  <B><FONT COLOR="#228B22">float</FONT></B> cam[2][4], lab[2][4], sum[2], chratio;

  <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) (colors-3) &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Blending highlights...\n&quot;</FONT></B>));
  FORCC <B><FONT COLOR="#A020F0">if</FONT></B> (clip &gt; (i = 65535*pre_mul[c])) clip = i;
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++) {
      FORCC <B><FONT COLOR="#A020F0">if</FONT></B> (image[row*width+col][c] &gt; clip) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (c == colors) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      FORCC {
	cam[0][c] = image[row*width+col][c];
	cam[1][c] = MIN(cam[0][c],clip);
      }
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 2; i++) {
	FORCC <B><FONT COLOR="#A020F0">for</FONT></B> (lab[i][c]=j=0; j &lt; colors; j++)
	  lab[i][c] += trans[colors-3][c][j] * cam[i][j];
	<B><FONT COLOR="#A020F0">for</FONT></B> (sum[i]=0,c=1; c &lt; colors; c++)
	  sum[i] += SQR(lab[i][c]);
      }
      chratio = sqrt(sum[1]/sum[0]);
      <B><FONT COLOR="#A020F0">for</FONT></B> (c=1; c &lt; colors; c++)
	lab[0][c] *= chratio;
      FORCC <B><FONT COLOR="#A020F0">for</FONT></B> (cam[0][c]=j=0; j &lt; colors; j++)
	cam[0][c] += itrans[colors-3][c][j] * lab[0][j];
      FORCC image[row*width+col][c] = cam[0][c] / colors;
    }
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SCALE</FONT> (4 &gt;&gt; shrink)
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">recover_highlights</FONT></B>()
{
  <B><FONT COLOR="#228B22">float</FONT></B> *map, sum, wgt, grow;
  <B><FONT COLOR="#228B22">int</FONT></B> hsat[4], count, spread, change, val, i;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> high, wide, mrow, mcol, row, col, kc, c, d, y, x;
  ushort *pixel;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> dir[8][2] =
    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };

  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Rebuilding highlights...\n&quot;</FONT></B>));

  grow = pow (2, 4-highlight);
  FORCC hsat[c] = 32000 * pre_mul[c];
  <B><FONT COLOR="#A020F0">for</FONT></B> (kc=0, c=1; c &lt; colors; c++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (pre_mul[kc] &lt; pre_mul[c]) kc = c;
  high = height / SCALE;
  wide =  width / SCALE;
  map = (<B><FONT COLOR="#228B22">float</FONT></B> *) calloc (high, wide*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *map);
  merror (map, <B><FONT COLOR="#BC8F8F">&quot;recover_highlights()&quot;</FONT></B>);
  FORCC <B><FONT COLOR="#A020F0">if</FONT></B> (c != kc) {
    memset (map, 0, high*wide*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *map);
    <B><FONT COLOR="#A020F0">for</FONT></B> (mrow=0; mrow &lt; high; mrow++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (mcol=0; mcol &lt; wide; mcol++) {
	sum = wgt = count = 0;
	<B><FONT COLOR="#A020F0">for</FONT></B> (row = mrow*SCALE; row &lt; (mrow+1)*SCALE; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col = mcol*SCALE; col &lt; (mcol+1)*SCALE; col++) {
	    pixel = image[row*width+col];
	    <B><FONT COLOR="#A020F0">if</FONT></B> (pixel[c] / hsat[c] == 1 &amp;&amp; pixel[kc] &gt; 24000) {
	      sum += pixel[c];
	      wgt += pixel[kc];
	      count++;
	    }
	  }
	<B><FONT COLOR="#A020F0">if</FONT></B> (count == SCALE*SCALE)
	  map[mrow*wide+mcol] = sum / wgt;
      }
    <B><FONT COLOR="#A020F0">for</FONT></B> (spread = 32/grow; spread--; ) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (mrow=0; mrow &lt; high; mrow++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (mcol=0; mcol &lt; wide; mcol++) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (map[mrow*wide+mcol]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  sum = count = 0;
	  <B><FONT COLOR="#A020F0">for</FONT></B> (d=0; d &lt; 8; d++) {
	    y = mrow + dir[d][0];
	    x = mcol + dir[d][1];
	    <B><FONT COLOR="#A020F0">if</FONT></B> (y &lt; high &amp;&amp; x &lt; wide &amp;&amp; map[y*wide+x] &gt; 0) {
	      sum  += (1 + (d &amp; 1)) * map[y*wide+x];
	      count += 1 + (d &amp; 1);
	    }
	  }
	  <B><FONT COLOR="#A020F0">if</FONT></B> (count &gt; 3)
	    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);
	}
      <B><FONT COLOR="#A020F0">for</FONT></B> (change=i=0; i &lt; high*wide; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (map[i] &lt; 0) {
	  map[i] = -map[i];
	  change = 1;
	}
      <B><FONT COLOR="#A020F0">if</FONT></B> (!change) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; high*wide; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (map[i] == 0) map[i] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (mrow=0; mrow &lt; high; mrow++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (mcol=0; mcol &lt; wide; mcol++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (row = mrow*SCALE; row &lt; (mrow+1)*SCALE; row++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (col = mcol*SCALE; col &lt; (mcol+1)*SCALE; col++) {
	    pixel = image[row*width+col];
	    <B><FONT COLOR="#A020F0">if</FONT></B> (pixel[c] / hsat[c] &gt; 1) {
	      val = pixel[kc] * map[mrow*wide+mcol];
	      <B><FONT COLOR="#A020F0">if</FONT></B> (pixel[c] &lt; val) pixel[c] = CLIP(val);
	    }
	  }
      }
  }
  free (map);
}
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">SCALE</FONT>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">tiff_get</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> base,
	<B><FONT COLOR="#228B22">unsigned</FONT></B> *tag, <B><FONT COLOR="#228B22">unsigned</FONT></B> *type, <B><FONT COLOR="#228B22">unsigned</FONT></B> *len, <B><FONT COLOR="#228B22">unsigned</FONT></B> *save)
{
  *tag  = get2();
  *type = get2();
  *len  = get4();
  *save = ftell(ifp) + 4;
  <B><FONT COLOR="#A020F0">if</FONT></B> (*len * (<B><FONT COLOR="#BC8F8F">&quot;11124811248484&quot;</FONT></B>[*type &lt; 14 ? *type:0]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &gt; 4)
    fseek (ifp, get4()+base, SEEK_SET);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_thumb_note</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base, <B><FONT COLOR="#228B22">unsigned</FONT></B> toff, <B><FONT COLOR="#228B22">unsigned</FONT></B> tlen)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, type, len, save;

  entries = get2();
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == toff) thumb_offset = get4()+base;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == tlen) thumb_length = get4();
    fseek (ifp, save, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_tiff_ifd</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base);

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_makernote</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base, <B><FONT COLOR="#228B22">int</FONT></B> uptag)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uchar xlat[2][256] = {
  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,
    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,
    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,
    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,
    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,
    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,
    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,
    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,
    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,
    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,
    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,
    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,
    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,
    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,
    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,
    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },
  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,
    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,
    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,
    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,
    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,
    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,
    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,
    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,
    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,
    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,
    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,
    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,
    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,
    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,
    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,
    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> offset=0, entries, tag, type, len, save, c;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};
  uchar buf97[324], ci, cj, ck;
  <B><FONT COLOR="#228B22">short</FONT></B> morder, sorder=order;
  <B><FONT COLOR="#228B22">char</FONT></B> buf[10];
<I><FONT COLOR="#B22222">/*
   The MakerNote might have its own TIFF header (possibly with
   its own byte-order!), or it might just be a table.
 */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Nokia&quot;</FONT></B>)) <B><FONT COLOR="#A020F0">return</FONT></B>;
  fread (buf, 1, 10, ifp);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;KDK&quot;</FONT></B> ,3) ||	<I><FONT COLOR="#B22222">/* these aren't TIFF tables */</FONT></I>
      !strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;VER&quot;</FONT></B> ,3) ||
      !strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;IIII&quot;</FONT></B>,4) ||
      !strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;MMMM&quot;</FONT></B>,4)) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;KC&quot;</FONT></B>  ,2) ||	<I><FONT COLOR="#B22222">/* Konica KD-400Z, KD-510Z */</FONT></I>
      !strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;MLY&quot;</FONT></B> ,3)) {	<I><FONT COLOR="#B22222">/* Minolta DiMAGE G series */</FONT></I>
    order = 0x4d4d;
    <B><FONT COLOR="#A020F0">while</FONT></B> ((i=ftell(ifp)) &lt; data_offset &amp;&amp; i &lt; 16384) {
      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];
      wb[3] = get2();
      <B><FONT COLOR="#A020F0">if</FONT></B> (wb[1] == 256 &amp;&amp; wb[3] == 256 &amp;&amp;
	  wb[0] &gt; 256 &amp;&amp; wb[0] &lt; 640 &amp;&amp; wb[2] &gt; 256 &amp;&amp; wb[2] &lt; 640)
	FORC4 cam_mul[c] = wb[c];
    }
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">quit</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>)) {
    base = ftell(ifp);
    order = get2();
    <B><FONT COLOR="#A020F0">if</FONT></B> (get2() != 42) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">quit</FONT></B>;
    offset = get4();
    fseek (ifp, offset-8, SEEK_CUR);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;OLYMPUS&quot;</FONT></B>) ||
	     !strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;PENTAX &quot;</FONT></B>)) {
    base = ftell(ifp)-10;
    fseek (ifp, -2, SEEK_CUR);
    order = get2();
    <B><FONT COLOR="#A020F0">if</FONT></B> (buf[0] == <B><FONT COLOR="#BC8F8F">'O'</FONT></B>) get2();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;SONY&quot;</FONT></B>,4) ||
	     !strcmp  (buf,<B><FONT COLOR="#BC8F8F">&quot;Panasonic&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">nf</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (buf,<B><FONT COLOR="#BC8F8F">&quot;FUJIFILM&quot;</FONT></B>,8)) {
    base = ftell(ifp)-10;
<B><FONT COLOR="#5F9EA0">nf</FONT></B>: order = 0x4949;
    fseek (ifp,  2, SEEK_CUR);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;OLYMP&quot;</FONT></B>) ||
	     !strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;LEICA&quot;</FONT></B>) ||
	     !strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;Ricoh&quot;</FONT></B>) ||
	     !strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;EPSON&quot;</FONT></B>))
    fseek (ifp, -2, SEEK_CUR);
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;AOC&quot;</FONT></B>) ||
	   !strcmp (buf,<B><FONT COLOR="#BC8F8F">&quot;QVC&quot;</FONT></B>))
    fseek (ifp, -4, SEEK_CUR);
  <B><FONT COLOR="#A020F0">else</FONT></B> {
    fseek (ifp, -10, SEEK_CUR);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;SAMSUNG&quot;</FONT></B>,7))
      base = ftell(ifp);
  }
  entries = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> (entries &gt; 1000) <B><FONT COLOR="#A020F0">return</FONT></B>;
  morder = order;
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    order = morder;
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    tag |= uptag &lt;&lt; 16;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2 &amp;&amp; strstr(make,<B><FONT COLOR="#BC8F8F">&quot;NIKON&quot;</FONT></B>) &amp;&amp; !iso_speed)
      iso_speed = (get2(),get2());
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 4 &amp;&amp; len &gt; 26 &amp;&amp; len &lt; 35) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i=(get4(),get2())) != 0x7fff &amp;&amp; !iso_speed)
	iso_speed = 50 * pow (2, i/32.0 - 4);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i=(get2(),get2())) != 0x7fff &amp;&amp; !aperture)
	aperture = pow (2, i/64.0);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i=get2()) != 0xffff &amp;&amp; !shutter)
	shutter = pow (2, (<B><FONT COLOR="#228B22">short</FONT></B>) i/-32.0);
      wbi = (get2(),get2());
      shot_order = (get2(),get2());
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tag == 4 || tag == 0x114) &amp;&amp; !strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;KONICA&quot;</FONT></B>,6)) {
      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);
      <B><FONT COLOR="#A020F0">switch</FONT></B> (get2()) {
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">72</FONT></B>:  flip = 0;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">76</FONT></B>:  flip = 6;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">82</FONT></B>:  flip = 5;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 7 &amp;&amp; type == 2 &amp;&amp; len &gt; 20)
      fgets (model2, 64, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 8 &amp;&amp; type == 4)
      shot_order = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 9 &amp;&amp; !strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>))
      fread (artist, 64, 1, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xc &amp;&amp; len == 4)
      FORC3 cam_mul[(c &lt;&lt; 1 | c &gt;&gt; 1) &amp; 3] = getreal(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xd &amp;&amp; type == 7 &amp;&amp; get2() == 0xaaaa) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (c=i=2; (ushort) c != 0xbbbb &amp;&amp; i &lt; len; i++)
	c = c &lt;&lt; 8 | fgetc(ifp);
      <B><FONT COLOR="#A020F0">while</FONT></B> ((i+=4) &lt; len-5)
	<B><FONT COLOR="#A020F0">if</FONT></B> (get4() == 257 &amp;&amp; (i=len) &amp;&amp; (c = (get4(),fgetc(ifp))) &lt; 3)
	  flip = <B><FONT COLOR="#BC8F8F">&quot;065&quot;</FONT></B>[c]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x10 &amp;&amp; type == 4)
      unique_id = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x11 &amp;&amp; is_raw &amp;&amp; !strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;NIKON&quot;</FONT></B>,5)) {
      fseek (ifp, get4()+base, SEEK_SET);
      parse_tiff_ifd (base);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x14 &amp;&amp; type == 7) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (len == 2560) {
	fseek (ifp, 1248, SEEK_CUR);
	<B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">get2_256</FONT></B>;
      }
      fread (buf, 1, 10, ifp);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(buf,<B><FONT COLOR="#BC8F8F">&quot;NRW &quot;</FONT></B>,4)) {
	fseek (ifp, strcmp(buf+4,<B><FONT COLOR="#BC8F8F">&quot;0100&quot;</FONT></B>) ? 46:1546, SEEK_CUR);
	cam_mul[0] = get4() &lt;&lt; 2;
	cam_mul[1] = get4() + get4();
	cam_mul[2] = get4() &lt;&lt; 2;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x15 &amp;&amp; type == 2 &amp;&amp; is_raw)
      fread (model, 64, 1, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(make,<B><FONT COLOR="#BC8F8F">&quot;PENTAX&quot;</FONT></B>)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x1b) tag = 0x1018;
      <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x1c) tag = 0x1017;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x1d)
      <B><FONT COLOR="#A020F0">while</FONT></B> ((c = fgetc(ifp)) &amp;&amp; c != EOF)
	serial = serial*10 + (isdigit(c) ? c - <B><FONT COLOR="#BC8F8F">'0'</FONT></B> : c % 10);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x29 &amp;&amp; type == 1) {
      c = wbi &lt; 18 ? <B><FONT COLOR="#BC8F8F">&quot;012347800000005896&quot;</FONT></B>[wbi]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B> : 0;
      fseek (ifp, 8 + c*32, SEEK_CUR);
      FORC4 cam_mul[c ^ (c &gt;&gt; 1) ^ 1] = get4();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x3d &amp;&amp; type == 3 &amp;&amp; len == 4)
      FORC4 cblack[c ^ c &gt;&gt; 1] = get2() &gt;&gt; (14-tiff_bps);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x81 &amp;&amp; type == 4) {
      data_offset = get4();
      fseek (ifp, data_offset + 41, SEEK_SET);
      raw_height = get2() * 2;
      raw_width  = get2();
      filters = 0x61616161;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tag == 0x81  &amp;&amp; type == 7) ||
	(tag == 0x100 &amp;&amp; type == 7) ||
	(tag == 0x280 &amp;&amp; type == 1)) {
      thumb_offset = ftell(ifp);
      thumb_length = len;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x88 &amp;&amp; type == 4 &amp;&amp; (thumb_offset = get4()))
      thumb_offset += base;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x89 &amp;&amp; type == 4)
      thumb_length = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x8c || tag == 0x96)
      meta_offset = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x97) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
	ver97 = ver97 * 10 + fgetc(ifp)-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
      <B><FONT COLOR="#A020F0">switch</FONT></B> (ver97) {
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">100</FONT></B>:
	  fseek (ifp, 68, SEEK_CUR);
	  FORC4 cam_mul[(c &gt;&gt; 1) | ((c &amp; 1) &lt;&lt; 1)] = get2();
	  <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">102</FONT></B>:
	  fseek (ifp, 6, SEEK_CUR);
	  FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get2();
	  <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">103</FONT></B>:
	  fseek (ifp, 16, SEEK_CUR);
	  FORC4 cam_mul[c] = get2();
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (ver97 &gt;= 200) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (ver97 != 205) fseek (ifp, 280, SEEK_CUR);
	fread (buf97, 324, 1, ifp);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xa1 &amp;&amp; type == 7) {
      order = 0x4949;
      fseek (ifp, 140, SEEK_CUR);
      FORC3 cam_mul[c] = get4();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xa4 &amp;&amp; type == 3) {
      fseek (ifp, wbi*48, SEEK_CUR);
      FORC3 cam_mul[c] = get2();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xa7 &amp;&amp; (<B><FONT COLOR="#228B22">unsigned</FONT></B>) (ver97-200) &lt; 17) {
      ci = xlat[0][serial &amp; 0xff];
      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];
      ck = 0x60;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 324; i++)
	buf97[i] ^= (cj += ci * ck++);
      i = <B><FONT COLOR="#BC8F8F">&quot;66666&gt;666;6A;:;55&quot;</FONT></B>[ver97-200] - <B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
      FORC4 cam_mul[c ^ (c &gt;&gt; 1) ^ (i &amp; 1)] =
	sget2 (buf97 + (i &amp; -2) + c*2);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x200 &amp;&amp; len == 3)
      shot_order = (get4(),get4());
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x200 &amp;&amp; len == 4)
      FORC4 cblack[c ^ c &gt;&gt; 1] = get2();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x201 &amp;&amp; len == 4)
      FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get2();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x220 &amp;&amp; type == 7)
      meta_offset = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x401 &amp;&amp; type == 4 &amp;&amp; len == 4)
      FORC4 cblack[c ^ c &gt;&gt; 1] = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xe01) {		<I><FONT COLOR="#B22222">/* Nikon Capture Note */</FONT></I>
      order = 0x4949;
      fseek (ifp, 22, SEEK_CUR);
      <B><FONT COLOR="#A020F0">for</FONT></B> (offset=22; offset+22 &lt; len; offset += 22+i) {
	tag = get4();
	fseek (ifp, 14, SEEK_CUR);
	i = get4()-4;
	<B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x76a43207) flip = get2();
	<B><FONT COLOR="#A020F0">else</FONT></B> fseek (ifp, i, SEEK_CUR);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xe80 &amp;&amp; len == 256 &amp;&amp; type == 7) {
      fseek (ifp, 48, SEEK_CUR);
      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;
      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xf00 &amp;&amp; type == 7) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (len == 614)
	fseek (ifp, 176, SEEK_CUR);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (len == 734 || len == 1502)
	fseek (ifp, 148, SEEK_CUR);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
      <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">get2_256</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tag == 0x1011 &amp;&amp; len == 9) || tag == 0x20400200)
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
	FORC3 cmatrix[i][c] = ((<B><FONT COLOR="#228B22">short</FONT></B>) get2()) / 256.0;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tag == 0x1012 || tag == 0x20400600) &amp;&amp; len == 4)
      FORC4 cblack[c ^ c &gt;&gt; 1] = get2();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x1017 || tag == 0x20400100)
      cam_mul[0] = get2() / 256.0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x1018 || tag == 0x20400100)
      cam_mul[2] = get2() / 256.0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x2011 &amp;&amp; len == 2) {
<B><FONT COLOR="#5F9EA0">get2_256</FONT></B>:
      order = 0x4d4d;
      cam_mul[0] = get2() / 256.0;
      cam_mul[2] = get2() / 256.0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tag | 0x70) == 0x2070 &amp;&amp; (type == 4 || type == 13))
      fseek (ifp, get4()+base, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x2020 &amp;&amp; !strncmp(buf,<B><FONT COLOR="#BC8F8F">&quot;OLYMP&quot;</FONT></B>,5))
      parse_thumb_note (base, 257, 258);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x2040)
      parse_makernote (base, 0x2040);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xb028) {
      fseek (ifp, get4()+base, SEEK_SET);
      parse_thumb_note (base, 136, 137);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x4001 &amp;&amp; len &gt; 500) {
      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;
      fseek (ifp, i, SEEK_CUR);
      FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get2();
      <B><FONT COLOR="#A020F0">for</FONT></B> (i+=18; i &lt;= len; i+=10) {
	get2();
	FORC4 sraw_mul[c ^ (c &gt;&gt; 1)] = get2();
	<B><FONT COLOR="#A020F0">if</FONT></B> (sraw_mul[1] == 1170) <B><FONT COLOR="#A020F0">break</FONT></B>;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x4021 &amp;&amp; get4() &amp;&amp; get4())
      FORC4 cam_mul[c] = 1024;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xa021)
      FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xa028)
      FORC4 cam_mul[c ^ (c &gt;&gt; 1)] -= get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xb001)
      unique_id = get2();
<B><FONT COLOR="#5F9EA0">next</FONT></B>:
    fseek (ifp, save, SEEK_SET);
  }
<B><FONT COLOR="#5F9EA0">quit</FONT></B>:
  order = sorder;
}

<I><FONT COLOR="#B22222">/*
   Since the TIFF DateTime string has no timezone information,
   assume that the camera's clock was set to Universal Time.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">get_timestamp</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> reversed)
{
  <B><FONT COLOR="#228B22">struct</FONT></B> tm t;
  <B><FONT COLOR="#228B22">char</FONT></B> str[20];
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  str[19] = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (reversed)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=19; i--; ) str[i] = fgetc(ifp);
  <B><FONT COLOR="#A020F0">else</FONT></B>
    fread (str, 19, 1, ifp);
  memset (&amp;t, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> t);
  <B><FONT COLOR="#A020F0">if</FONT></B> (sscanf (str, <B><FONT COLOR="#BC8F8F">&quot;%d:%d:%d %d:%d:%d&quot;</FONT></B>, &amp;t.tm_year, &amp;t.tm_mon,
	&amp;t.tm_mday, &amp;t.tm_hour, &amp;t.tm_min, &amp;t.tm_sec) != 6)
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  t.tm_year -= 1900;
  t.tm_mon -= 1;
  t.tm_isdst = -1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (mktime(&amp;t) &gt; 0)
    timestamp = mktime(&amp;t);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_exif</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> kodak, entries, tag, type, len, save, c;
  <B><FONT COLOR="#228B22">double</FONT></B> expo;

  kodak = !strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;EASTMAN&quot;</FONT></B>,7) &amp;&amp; tiff_nifds &lt; 3;
  entries = get2();
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33434</FONT></B>:  tiff_ifd[tiff_nifds-1].shutter =
		   shutter = getreal(type);		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33437</FONT></B>:  aperture = getreal(type);		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34855</FONT></B>:  iso_speed = get2();			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">36867</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">36868</FONT></B>:  get_timestamp(0);			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37377</FONT></B>:  <B><FONT COLOR="#A020F0">if</FONT></B> ((expo = -getreal(type)) &lt; 128)
		     tiff_ifd[tiff_nifds-1].shutter =
		     shutter = pow (2, expo);		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37378</FONT></B>:  aperture = pow (2, getreal(type)/2);	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37386</FONT></B>:  focal_len = getreal(type);		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37500</FONT></B>:  parse_makernote (base, 0);		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">40962</FONT></B>:  <B><FONT COLOR="#A020F0">if</FONT></B> (kodak) raw_width  = get4();	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">40963</FONT></B>:  <B><FONT COLOR="#A020F0">if</FONT></B> (kodak) raw_height = get4();	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">41730</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (get4() == 0x20002)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (exif_cfa=c=0; c &lt; 8; c+=2)
	    exif_cfa |= fgetc(ifp) * 0x01010101 &lt;&lt; c;
    }
    fseek (ifp, save, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_gps</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, type, len, save, c;

  entries = get2();
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">5</FONT></B>:
	gpsdata[29+tag/2] = getc(ifp);			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">4</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">7</FONT></B>:
	FORC(6) gpsdata[tag/3*6+c] = get4();		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>:
	FORC(2) gpsdata[18+c] = get4();			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">18</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29</FONT></B>:
	fgets ((<B><FONT COLOR="#228B22">char</FONT></B> *) (gpsdata+14+tag/3), MIN(len,12), ifp);
    }
    fseek (ifp, save, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">romm_coeff</FONT></B> (<B><FONT COLOR="#228B22">float</FONT></B> romm_cam[3][3])
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> rgb_romm[3][3] =	<I><FONT COLOR="#B22222">/* ROMM == Kodak ProPhoto */</FONT></I>
  { {  2.034193, -0.727420, -0.306766 },
    { -0.228811,  1.231729, -0.002922 },
    { -0.008565, -0.153273,  1.161839 } };
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (cmatrix[i][j] = k=0; k &lt; 3; k++)
	cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_mos</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset)
{
  <B><FONT COLOR="#228B22">char</FONT></B> data[40];
  <B><FONT COLOR="#228B22">int</FONT></B> skip, from, i, c, neut[4], planes=0, frot=0;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *mod[] =
  { <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;DCB2&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Volare&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Cantare&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;CMost&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Valeo 6&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Valeo 11&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Valeo 22&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;Valeo 11p&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Valeo 17&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 17&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 22&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 75&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 65&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;Aptus 54S&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 65S&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus 75S&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;AFi 5&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;AFi 6&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;AFi 7&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;AFi-II 7&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 7&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 6&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 10&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 5&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 10R&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 8&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aptus-II 12&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;AFi-II 12&quot;</FONT></B> };
  <B><FONT COLOR="#228B22">float</FONT></B> romm_cam[3][3];

  fseek (ifp, offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">while</FONT></B> (1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (get4() != 0x504b5453) <B><FONT COLOR="#A020F0">break</FONT></B>;
    get4();
    fread (data, 1, 40, ifp);
    skip = get4();
    from = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;JPEG_preview_data&quot;</FONT></B>)) {
      thumb_offset = from;
      thumb_length = skip;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;icc_camera_profile&quot;</FONT></B>)) {
      profile_offset = from;
      profile_length = skip;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;ShootObj_back_type&quot;</FONT></B>)) {
      fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;i);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> mod / <B><FONT COLOR="#A020F0">sizeof</FONT></B> (*mod))
	strcpy (model, mod[i]);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;icc_camera_to_tone_matrix&quot;</FONT></B>)) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 9; i++)
	((<B><FONT COLOR="#228B22">float</FONT></B> *)romm_cam)[i] = int_to_float(get4());
      romm_coeff (romm_cam);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;CaptProf_color_matrix&quot;</FONT></B>)) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 9; i++)
	fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%f&quot;</FONT></B>, (<B><FONT COLOR="#228B22">float</FONT></B> *)romm_cam + i);
      romm_coeff (romm_cam);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;CaptProf_number_of_planes&quot;</FONT></B>))
      fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;planes);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;CaptProf_raw_data_rotation&quot;</FONT></B>))
      fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;flip);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;CaptProf_mosaic_pattern&quot;</FONT></B>))
      FORC4 {
	fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;i);
	<B><FONT COLOR="#A020F0">if</FONT></B> (i == 1) frot = c ^ (c &gt;&gt; 1);
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;ImgProf_rotation_angle&quot;</FONT></B>)) {
      fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;i);
      flip = i - flip;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;NeutObj_neutrals&quot;</FONT></B>) &amp;&amp; !cam_mul[0]) {
      FORC4 fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, neut+c);
      FORC3 cam_mul[c] = (<B><FONT COLOR="#228B22">float</FONT></B>) neut[0] / neut[c+1];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(data,<B><FONT COLOR="#BC8F8F">&quot;Rows_data&quot;</FONT></B>))
      load_flags = get4();
    parse_mos (from);
    fseek (ifp, skip+from, SEEK_SET);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (planes)
    filters = (planes == 1) * 0x01010101 *
	(uchar) <B><FONT COLOR="#BC8F8F">&quot;\x94\x61\x16\x49&quot;</FONT></B>[(flip/90 + frot) &amp; 3];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">linear_table</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> len)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; 0x1000) len = 0x1000;
  read_shorts (curve, len);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=len; i &lt; 0x1000; i++)
    curve[i] = curve[i-1];
  maximum = curve[0xfff];
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_kodak_ifd</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, type, len, save;
  <B><FONT COLOR="#228B22">int</FONT></B> i, c, wbi=-2, wbtemp=6500;
  <B><FONT COLOR="#228B22">float</FONT></B> mul[3]={1,1,1}, num;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };

  entries = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> (entries &gt; 1024) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 1020) wbi = getint(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 1021 &amp;&amp; len == 72) {		<I><FONT COLOR="#B22222">/* WB set in software */</FONT></I>
      fseek (ifp, 40, SEEK_CUR);
      FORC3 cam_mul[c] = 2048.0 / get2();
      wbi = -2;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2118) wbtemp = getint(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2120 + wbi &amp;&amp; wbi &gt;= 0)
      FORC3 cam_mul[c] = 2048.0 / getreal(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2130 + wbi)
      FORC3 mul[c] = getreal(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2140 + wbi &amp;&amp; wbi &gt;= 0)
      FORC3 {
	<B><FONT COLOR="#A020F0">for</FONT></B> (num=i=0; i &lt; 4; i++)
	  num += getreal(type) * pow (wbtemp/100.0, i);
	cam_mul[c] = 2048 / (num * mul[c]);
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 2317) linear_table (len);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 6020) iso_speed = getint(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 64013) wbi = fgetc(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) wbi &lt; 7 &amp;&amp; tag == wbtag[wbi])
      FORC3 cam_mul[c] = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 64019) width = getint(type);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 64020) height = (getint(type)+1) &amp; -2;
    fseek (ifp, save, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_minolta</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base);
<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_tiff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base);

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_tiff_ifd</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, type, len, plen=16, save;
  <B><FONT COLOR="#228B22">int</FONT></B> ifd, use_cm=0, cfa, i, j, c, ima_len=0;
  <B><FONT COLOR="#228B22">char</FONT></B> software[64], *cbuf, *cp;
  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
  <B><FONT COLOR="#228B22">double</FONT></B> cc[4][4], cm[4][3], cam_xyz[4][3], num;
  <B><FONT COLOR="#228B22">double</FONT></B> ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> sony_curve[] = { 0,0,0,0,0,4095 };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> *buf, sony_offset=0, sony_length=0, sony_key=0;
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;
  FILE *sfp;

  <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_nifds &gt;= <B><FONT COLOR="#A020F0">sizeof</FONT></B> tiff_ifd / <B><FONT COLOR="#A020F0">sizeof</FONT></B> tiff_ifd[0])
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  ifd = tiff_nifds++;
  <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 4; j++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++)
      cc[j][i] = i == j;
  entries = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> (entries &gt; 512) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tiff_get (base, &amp;tag, &amp;type, &amp;len, &amp;save);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">5</FONT></B>:   width  = get2();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>:   height = get2();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">7</FONT></B>:   width += get2();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">9</FONT></B>:   <B><FONT COLOR="#A020F0">if</FONT></B> ((i = get2())) filters = i;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">17</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">18</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (type == 3 &amp;&amp; len == 1)
	  cam_mul[(tag-17)*2] = get2() / 256.0;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">23</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (type == 3) iso_speed = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">28</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">30</FONT></B>:
	cblack[tag-28] = get2();
	cblack[3] = cblack[1];
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">36</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">38</FONT></B>:
	cam_mul[tag-36] = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">39</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (len &lt; 50 || cam_mul[0]) <B><FONT COLOR="#A020F0">break</FONT></B>;
	fseek (ifp, 12, SEEK_CUR);
	FORC3 cam_mul[c] = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">46</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) <B><FONT COLOR="#A020F0">break</FONT></B>;
	thumb_offset = ftell(ifp) - 2;
	thumb_length = len;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61440</FONT></B>:			<I><FONT COLOR="#B22222">/* Fuji HS10 table */</FONT></I>
	fseek (ifp, get4()+base, SEEK_SET);
	parse_tiff_ifd (base);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">256</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61441</FONT></B>:	<I><FONT COLOR="#B22222">/* ImageWidth */</FONT></I>
	tiff_ifd[ifd].width = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">257</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61442</FONT></B>:	<I><FONT COLOR="#B22222">/* ImageHeight */</FONT></I>
	tiff_ifd[ifd].height = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">258</FONT></B>:				<I><FONT COLOR="#B22222">/* BitsPerSample */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61443</FONT></B>:
	tiff_ifd[ifd].samples = len &amp; 7;
	<B><FONT COLOR="#A020F0">if</FONT></B> ((tiff_ifd[ifd].bps = getint(type)) &gt; 32)
	     tiff_ifd[ifd].bps = 8;
	<B><FONT COLOR="#A020F0">if</FONT></B> (tiff_bps &lt; tiff_ifd[ifd].bps)
	    tiff_bps = tiff_ifd[ifd].bps;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61446</FONT></B>:
	raw_height = 0;
	load_flags = get4() ? 24:80;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">259</FONT></B>:				<I><FONT COLOR="#B22222">/* Compression */</FONT></I>
	tiff_ifd[ifd].comp = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">262</FONT></B>:				<I><FONT COLOR="#B22222">/* PhotometricInterpretation */</FONT></I>
	tiff_ifd[ifd].phint = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">270</FONT></B>:				<I><FONT COLOR="#B22222">/* ImageDescription */</FONT></I>
	fread (desc, 512, 1, ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">271</FONT></B>:				<I><FONT COLOR="#B22222">/* Make */</FONT></I>
	fgets (make, 64, ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">272</FONT></B>:				<I><FONT COLOR="#B22222">/* Model */</FONT></I>
	fgets (model, 64, ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">280</FONT></B>:				<I><FONT COLOR="#B22222">/* Panasonic RW2 offset */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (type != 4) <B><FONT COLOR="#A020F0">break</FONT></B>;
	load_raw = &amp;CLASS panasonic_load_raw;
	load_flags = 0x2008;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">273</FONT></B>:				<I><FONT COLOR="#B22222">/* StripOffset */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">513</FONT></B>:				<I><FONT COLOR="#B22222">/* JpegIFOffset */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61447</FONT></B>:
	tiff_ifd[ifd].offset = get4()+base;
	<B><FONT COLOR="#A020F0">if</FONT></B> (!tiff_ifd[ifd].bps &amp;&amp; tiff_ifd[ifd].offset &gt; 0) {
	  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (ljpeg_start (&amp;jh, 1)) {
	    tiff_ifd[ifd].comp    = 6;
	    tiff_ifd[ifd].width   = jh.wide;
	    tiff_ifd[ifd].height  = jh.high;
	    tiff_ifd[ifd].bps     = jh.bits;
	    tiff_ifd[ifd].samples = jh.clrs;
	    <B><FONT COLOR="#A020F0">if</FONT></B> (!(jh.sraw || (jh.clrs &amp; 1)))
	      tiff_ifd[ifd].width *= jh.clrs;
	    <B><FONT COLOR="#A020F0">if</FONT></B> ((tiff_ifd[ifd].width &gt; 4*tiff_ifd[ifd].height) &amp; ~jh.clrs) {
	      tiff_ifd[ifd].width  /= 2;
	      tiff_ifd[ifd].height *= 2;
	    }
	    i = order;
	    parse_tiff (tiff_ifd[ifd].offset + 12);
	    order = i;
	  }
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">274</FONT></B>:				<I><FONT COLOR="#B22222">/* Orientation */</FONT></I>
	tiff_ifd[ifd].flip = <B><FONT COLOR="#BC8F8F">&quot;50132467&quot;</FONT></B>[get2() &amp; 7]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">277</FONT></B>:				<I><FONT COLOR="#B22222">/* SamplesPerPixel */</FONT></I>
	tiff_ifd[ifd].samples = getint(type) &amp; 7;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">279</FONT></B>:				<I><FONT COLOR="#B22222">/* StripByteCounts */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">514</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61448</FONT></B>:
	tiff_ifd[ifd].bytes = get4();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61454</FONT></B>:
	FORC3 cam_mul[(4-c) % 3] = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">305</FONT></B>:  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">11</FONT></B>:		<I><FONT COLOR="#B22222">/* Software */</FONT></I>
	fgets (software, 64, ifp);
	<B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;Adobe&quot;</FONT></B>,5) ||
	    !strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;dcraw&quot;</FONT></B>,5) ||
	    !strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;UFRaw&quot;</FONT></B>,5) ||
	    !strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;Bibble&quot;</FONT></B>,6) ||
	    !strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;Nikon Scan&quot;</FONT></B>,10) ||
	    !strcmp (software,<B><FONT COLOR="#BC8F8F">&quot;Digital Photo Professional&quot;</FONT></B>))
	  is_raw = 0;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">306</FONT></B>:				<I><FONT COLOR="#B22222">/* DateTime */</FONT></I>
	get_timestamp(0);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">315</FONT></B>:				<I><FONT COLOR="#B22222">/* Artist */</FONT></I>
	fread (artist, 64, 1, ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">322</FONT></B>:				<I><FONT COLOR="#B22222">/* TileWidth */</FONT></I>
	tiff_ifd[ifd].tile_width = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">323</FONT></B>:				<I><FONT COLOR="#B22222">/* TileLength */</FONT></I>
	tiff_ifd[ifd].tile_length = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">324</FONT></B>:				<I><FONT COLOR="#B22222">/* TileOffsets */</FONT></I>
	tiff_ifd[ifd].offset = len &gt; 1 ? ftell(ifp) : get4();
	<B><FONT COLOR="#A020F0">if</FONT></B> (len == 1)
	  tiff_ifd[ifd].tile_width = tiff_ifd[ifd].tile_length = 0;
	<B><FONT COLOR="#A020F0">if</FONT></B> (len == 4) {
	  load_raw = &amp;CLASS sinar_4shot_load_raw;
	  is_raw = 5;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">330</FONT></B>:				<I><FONT COLOR="#B22222">/* SubIFDs */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSLR-A100&quot;</FONT></B>) &amp;&amp; tiff_ifd[ifd].width == 3872) {
	  load_raw = &amp;CLASS sony_arw_load_raw;
	  data_offset = get4()+base;
	  ifd++;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	<B><FONT COLOR="#A020F0">while</FONT></B> (len--) {
	  i = ftell(ifp);
	  fseek (ifp, get4()+base, SEEK_SET);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (parse_tiff_ifd (base)) <B><FONT COLOR="#A020F0">break</FONT></B>;
	  fseek (ifp, i+4, SEEK_SET);
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">400</FONT></B>:
	strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Sarnoff&quot;</FONT></B>);
	maximum = 0xfff;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">28688</FONT></B>:
	FORC4 sony_curve[c+1] = get2() &gt;&gt; 2 &amp; 0xfff;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 5; i++)
	  <B><FONT COLOR="#A020F0">for</FONT></B> (j = sony_curve[i]+1; j &lt;= sony_curve[i+1]; j++)
	    curve[j] = curve[j-1] + (1 &lt;&lt; i);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29184</FONT></B>: sony_offset = get4();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29185</FONT></B>: sony_length = get4();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29217</FONT></B>: sony_key    = get4();  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29264</FONT></B>:
	parse_minolta (ftell(ifp));
	raw_width = 0;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29443</FONT></B>:
	FORC4 cam_mul[c ^ (c &lt; 2)] = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">29459</FONT></B>:
	FORC4 cam_mul[c] = get2();
	i = (cam_mul[1] == 1024 &amp;&amp; cam_mul[2] == 1024) &lt;&lt; 1;
	SWAP (cam_mul[i],cam_mul[i+1])
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33405</FONT></B>:			<I><FONT COLOR="#B22222">/* Model2 */</FONT></I>
	fgets (model2, 64, ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33421</FONT></B>:			<I><FONT COLOR="#B22222">/* CFARepeatPatternDim */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (get2() == 6 &amp;&amp; get2() == 6)
	  filters = 9;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33422</FONT></B>:			<I><FONT COLOR="#B22222">/* CFAPattern */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) {
	  FORC(36) ((<B><FONT COLOR="#228B22">char</FONT></B> *)xtrans)[c] = fgetc(ifp) &amp; 3;
	  <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">64777</FONT></B>:			<I><FONT COLOR="#B22222">/* Kodak P-series */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> ((plen=len) &gt; 16) plen = 16;
	fread (cfa_pat, 1, plen, ifp);
	<B><FONT COLOR="#A020F0">for</FONT></B> (colors=cfa=i=0; i &lt; plen &amp;&amp; colors &lt; 4; i++) {
	  colors += !(cfa &amp; (1 &lt;&lt; cfa_pat[i]));
	  cfa |= 1 &lt;&lt; cfa_pat[i];
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (cfa == 070) memcpy (cfa_pc,<B><FONT COLOR="#BC8F8F">&quot;\003\004\005&quot;</FONT></B>,3);	<I><FONT COLOR="#B22222">/* CMY */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (cfa == 072) memcpy (cfa_pc,<B><FONT COLOR="#BC8F8F">&quot;\005\003\004\001&quot;</FONT></B>,4);	<I><FONT COLOR="#B22222">/* GMCY */</FONT></I>
	<B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">guess_cfa_pc</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33424</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">65024</FONT></B>:
	fseek (ifp, get4()+base, SEEK_SET);
	parse_kodak_ifd (base);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33434</FONT></B>:			<I><FONT COLOR="#B22222">/* ExposureTime */</FONT></I>
	tiff_ifd[ifd].shutter = shutter = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">33437</FONT></B>:			<I><FONT COLOR="#B22222">/* FNumber */</FONT></I>
	aperture = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34306</FONT></B>:			<I><FONT COLOR="#B22222">/* Leaf white balance */</FONT></I>
	FORC4 cam_mul[c ^ 1] = 4096.0 / get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34307</FONT></B>:			<I><FONT COLOR="#B22222">/* Leaf CatchLight color matrix */</FONT></I>
	fread (software, 1, 7, ifp);
	<B><FONT COLOR="#A020F0">if</FONT></B> (strncmp(software,<B><FONT COLOR="#BC8F8F">&quot;MATRIX&quot;</FONT></B>,6)) <B><FONT COLOR="#A020F0">break</FONT></B>;
	colors = 4;
	<B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = i=0; i &lt; 3; i++) {
	  FORC4 fscanf (ifp, <B><FONT COLOR="#BC8F8F">&quot;%f&quot;</FONT></B>, &amp;rgb_cam[i][c^1]);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!use_camera_wb) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	  num = 0;
	  FORC4 num += rgb_cam[i][c];
	  FORC4 rgb_cam[i][c] /= num;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34310</FONT></B>:			<I><FONT COLOR="#B22222">/* Leaf metadata */</FONT></I>
	parse_mos (ftell(ifp));
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34303</FONT></B>:
	strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Leaf&quot;</FONT></B>);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34665</FONT></B>:			<I><FONT COLOR="#B22222">/* EXIF tag */</FONT></I>
	fseek (ifp, get4()+base, SEEK_SET);
	parse_exif (base);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34853</FONT></B>:			<I><FONT COLOR="#B22222">/* GPSInfo tag */</FONT></I>
	fseek (ifp, get4()+base, SEEK_SET);
	parse_gps (base);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34675</FONT></B>:			<I><FONT COLOR="#B22222">/* InterColorProfile */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50831</FONT></B>:			<I><FONT COLOR="#B22222">/* AsShotICCProfile */</FONT></I>
	profile_offset = ftell(ifp);
	profile_length = len;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37122</FONT></B>:			<I><FONT COLOR="#B22222">/* CompressedBitsPerPixel */</FONT></I>
	kodak_cbpp = get4();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37386</FONT></B>:			<I><FONT COLOR="#B22222">/* FocalLength */</FONT></I>
	focal_len = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37393</FONT></B>:			<I><FONT COLOR="#B22222">/* ImageNumber */</FONT></I>
	shot_order = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">37400</FONT></B>:			<I><FONT COLOR="#B22222">/* old Kodak KDC tag */</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = i=0; i &lt; 3; i++) {
	  getreal(type);
	  FORC3 rgb_cam[i][c] = getreal(type);
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">40976</FONT></B>:
	strip_offset = get4();
	<B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_ifd[ifd].comp) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32770</FONT></B>: load_raw = &amp;CLASS samsung_load_raw;   <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32772</FONT></B>: load_raw = &amp;CLASS samsung2_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32773</FONT></B>: load_raw = &amp;CLASS samsung3_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">46275</FONT></B>:			<I><FONT COLOR="#B22222">/* Imacon tags */</FONT></I>
	strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Imacon&quot;</FONT></B>);
	data_offset = ftell(ifp);
	ima_len = len;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">46279</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (!ima_len) <B><FONT COLOR="#A020F0">break</FONT></B>;
	fseek (ifp, 38, SEEK_CUR);
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">46274</FONT></B>:
	fseek (ifp, 40, SEEK_CUR);
	raw_width  = get4();
	raw_height = get4();
	left_margin = get4() &amp; 7;
	width = raw_width - left_margin - (get4() &amp; 7);
	top_margin = get4() &amp; 7;
	height = raw_height - top_margin - (get4() &amp; 7);
	<B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 7262) {
	  height = 5444;
	  width  = 7244;
	  left_margin = 7;
	}
	fseek (ifp, 52, SEEK_CUR);
	FORC3 cam_mul[c] = getreal(11);
	fseek (ifp, 114, SEEK_CUR);
	flip = (get2() &gt;&gt; 7) * 90;
	<B><FONT COLOR="#A020F0">if</FONT></B> (width * height * 6 == ima_len) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (flip % 180 == 90) SWAP(width,height);
	  raw_width = width;
	  raw_height = height;
	  left_margin = top_margin = filters = flip = 0;
	}
	sprintf (model, <B><FONT COLOR="#BC8F8F">&quot;Ixpress %d-Mp&quot;</FONT></B>, height*width/1000000);
	load_raw = &amp;CLASS imacon_full_load_raw;
	<B><FONT COLOR="#A020F0">if</FONT></B> (filters) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (left_margin &amp; 1) filters = 0x61616161;
	  load_raw = &amp;CLASS unpacked_load_raw;
	}
	maximum = 0xffff;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50454</FONT></B>:			<I><FONT COLOR="#B22222">/* Sinar tag */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50455</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (!(cbuf = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc(len))) <B><FONT COLOR="#A020F0">break</FONT></B>;
	fread (cbuf, 1, len, ifp);
	<B><FONT COLOR="#A020F0">for</FONT></B> (cp = cbuf-1; cp &amp;&amp; cp &lt; cbuf+len; cp = strchr(cp,<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>))
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (++cp,<B><FONT COLOR="#BC8F8F">&quot;Neutral &quot;</FONT></B>,8))
	    sscanf (cp+8, <B><FONT COLOR="#BC8F8F">&quot;%f %f %f&quot;</FONT></B>, cam_mul, cam_mul+1, cam_mul+2);
	free (cbuf);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50458</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (!make[0]) strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Hasselblad&quot;</FONT></B>);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50459</FONT></B>:			<I><FONT COLOR="#B22222">/* Hasselblad tag */</FONT></I>
	i = order;
	j = ftell(ifp);
	c = tiff_nifds;
	order = get2();
	fseek (ifp, j+(get2(),get4()), SEEK_SET);
	parse_tiff_ifd (j);
	maximum = 0xffff;
	tiff_nifds = c;
	order = i;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50706</FONT></B>:			<I><FONT COLOR="#B22222">/* DNGVersion */</FONT></I>
	FORC4 dng_version = (dng_version &lt;&lt; 8) + fgetc(ifp);
	<B><FONT COLOR="#A020F0">if</FONT></B> (!make[0]) strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;DNG&quot;</FONT></B>);
	is_raw = 1;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50708</FONT></B>:			<I><FONT COLOR="#B22222">/* UniqueCameraModel */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (model[0]) <B><FONT COLOR="#A020F0">break</FONT></B>;
	fgets (make, 64, ifp);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((cp = strchr(make,<B><FONT COLOR="#BC8F8F">' '</FONT></B>))) {
	  strcpy(model,cp+1);
	  *cp = 0;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50710</FONT></B>:			<I><FONT COLOR="#B22222">/* CFAPlaneColor */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) <B><FONT COLOR="#A020F0">break</FONT></B>;
	<B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; 4) len = 4;
	colors = len;
	fread (cfa_pc, 1, colors, ifp);
<B><FONT COLOR="#5F9EA0">guess_cfa_pc</FONT></B>:
	FORCC tab[cfa_pc[c]] = c;
	cdesc[c] = 0;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=16; i--; )
	  filters = filters &lt;&lt; 2 | tab[cfa_pat[i % plen]];
	filters -= !filters;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50711</FONT></B>:			<I><FONT COLOR="#B22222">/* CFALayout */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (get2() == 2) fuji_width = 1;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">291</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50712</FONT></B>:			<I><FONT COLOR="#B22222">/* LinearizationTable */</FONT></I>
	linear_table (len);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50713</FONT></B>:			<I><FONT COLOR="#B22222">/* BlackLevelRepeatDim */</FONT></I>
	cblack[4] = get2();
	cblack[5] = get2();
	<B><FONT COLOR="#A020F0">if</FONT></B> (cblack[4] * cblack[5] &gt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> cblack / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *cblack - 6)
	    cblack[4] = cblack[5] = 1;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">61450</FONT></B>:
	cblack[4] = cblack[5] = MIN(sqrt(len),64);
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50714</FONT></B>:			<I><FONT COLOR="#B22222">/* BlackLevel */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (!(cblack[4] * cblack[5]))
	  cblack[4] = cblack[5] = 1;
	FORC (cblack[4] * cblack[5])
	  cblack[6+c] = getreal(type);
	black = 0;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50715</FONT></B>:			<I><FONT COLOR="#B22222">/* BlackLevelDeltaH */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50716</FONT></B>:			<I><FONT COLOR="#B22222">/* BlackLevelDeltaV */</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (num=i=0; i &lt; (len &amp; 0xffff); i++)
	  num += getreal(type);
	black += num/len + 0.5;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50717</FONT></B>:			<I><FONT COLOR="#B22222">/* WhiteLevel */</FONT></I>
	maximum = getint(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50718</FONT></B>:			<I><FONT COLOR="#B22222">/* DefaultScale */</FONT></I>
	pixel_aspect  = getreal(type);
	pixel_aspect /= getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50721</FONT></B>:			<I><FONT COLOR="#B22222">/* ColorMatrix1 */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50722</FONT></B>:			<I><FONT COLOR="#B22222">/* ColorMatrix2 */</FONT></I>
	FORCC <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++)
	  cm[c][j] = getreal(type);
	use_cm = 1;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50723</FONT></B>:			<I><FONT COLOR="#B22222">/* CameraCalibration1 */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50724</FONT></B>:			<I><FONT COLOR="#B22222">/* CameraCalibration2 */</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; colors; i++)
	  FORCC cc[i][c] = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50727</FONT></B>:			<I><FONT COLOR="#B22222">/* AnalogBalance */</FONT></I>
	FORCC ab[c] = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50728</FONT></B>:			<I><FONT COLOR="#B22222">/* AsShotNeutral */</FONT></I>
	FORCC asn[c] = getreal(type);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50729</FONT></B>:			<I><FONT COLOR="#B22222">/* AsShotWhiteXY */</FONT></I>
	xyz[0] = getreal(type);
	xyz[1] = getreal(type);
	xyz[2] = 1 - xyz[0] - xyz[1];
	FORC3 xyz[c] /= d65_white[c];
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50740</FONT></B>:			<I><FONT COLOR="#B22222">/* DNGPrivateData */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (dng_version) <B><FONT COLOR="#A020F0">break</FONT></B>;
	parse_minolta (j = get4()+base);
	fseek (ifp, j, SEEK_SET);
	parse_tiff_ifd (base);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50752</FONT></B>:
	read_shorts (cr2_slice, 3);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50829</FONT></B>:			<I><FONT COLOR="#B22222">/* ActiveArea */</FONT></I>
	top_margin = getint(type);
	left_margin = getint(type);
	height = getint(type) - top_margin;
	width = getint(type) - left_margin;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">50830</FONT></B>:			<I><FONT COLOR="#B22222">/* MaskedAreas */</FONT></I>
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; len &amp;&amp; i &lt; 32; i++)
	  ((<B><FONT COLOR="#228B22">int</FONT></B> *)mask)[i] = getint(type);
	black = 0;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">51009</FONT></B>:			<I><FONT COLOR="#B22222">/* OpcodeList2 */</FONT></I>
	meta_offset = ftell(ifp);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">64772</FONT></B>:			<I><FONT COLOR="#B22222">/* Kodak P-series */</FONT></I>
	<B><FONT COLOR="#A020F0">if</FONT></B> (len &lt; 13) <B><FONT COLOR="#A020F0">break</FONT></B>;
	fseek (ifp, 16, SEEK_CUR);
	data_offset = get4();
	fseek (ifp, 28, SEEK_CUR);
	data_offset += get4();
	load_raw = &amp;CLASS packed_load_raw;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">65026</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (type == 2) fgets (model2, 64, ifp);
    }
    fseek (ifp, save, SEEK_SET);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (sony_length &amp;&amp; (buf = (<B><FONT COLOR="#228B22">unsigned</FONT></B> *) malloc(sony_length))) {
    fseek (ifp, sony_offset, SEEK_SET);
    fread (buf, sony_length, 1, ifp);
    sony_decrypt (buf, sony_length/4, 1, sony_key);
    sfp = ifp;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((ifp = tmpfile())) {
      fwrite (buf, sony_length, 1, ifp);
      fseek (ifp, 0, SEEK_SET);
      parse_tiff_ifd (-sony_offset);
      fclose (ifp);
    }
    ifp = sfp;
    free (buf);
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; colors; i++)
    FORCC cc[i][c] *= ab[i];
  <B><FONT COLOR="#A020F0">if</FONT></B> (use_cm) {
    FORCC <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (cam_xyz[c][i]=j=0; j &lt; colors; j++)
	cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];
    cam_xyz_coeff (cmatrix, cam_xyz);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (asn[0]) {
    cam_mul[3] = 0;
    FORCC cam_mul[c] = 1 / asn[c];
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!use_cm)
    FORCC pre_mul[c] /= cc[c][c];
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_tiff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">int</FONT></B> doff;

  fseek (ifp, base, SEEK_SET);
  order = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> (order != 0x4949 &amp;&amp; order != 0x4d4d) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  get2();
  <B><FONT COLOR="#A020F0">while</FONT></B> ((doff = get4())) {
    fseek (ifp, doff+base, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (parse_tiff_ifd (base)) <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">apply_tiff</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;

  thumb_misc = 16;
  <B><FONT COLOR="#A020F0">if</FONT></B> (thumb_offset) {
    fseek (ifp, thumb_offset, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ljpeg_start (&amp;jh, 1)) {
      thumb_misc   = jh.bits;
      thumb_width  = jh.wide;
      thumb_height = jh.high;
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=tiff_nifds; i--; ) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[i].shutter)
      shutter = tiff_ifd[i].shutter;
    tiff_ifd[i].shutter = shutter;
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; tiff_nifds; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (max_samp &lt; tiff_ifd[i].samples)
	max_samp = tiff_ifd[i].samples;
    <B><FONT COLOR="#A020F0">if</FONT></B> (max_samp &gt; 3) max_samp = 3;
    os = raw_width*raw_height;
    ns = tiff_ifd[i].width*tiff_ifd[i].height;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_bps) {
      os *= tiff_bps;
      ns *= tiff_ifd[i].bps;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &amp;&amp;
	(tiff_ifd[i].width | tiff_ifd[i].height) &lt; 0x10000 &amp;&amp;
	 ns &amp;&amp; ((ns &gt; os &amp;&amp; (ties = 1)) ||
		(ns == os &amp;&amp; shot_select == ties++))) {
      raw_width     = tiff_ifd[i].width;
      raw_height    = tiff_ifd[i].height;
      tiff_bps      = tiff_ifd[i].bps;
      tiff_compress = tiff_ifd[i].comp;
      data_offset   = tiff_ifd[i].offset;
      tiff_flip     = tiff_ifd[i].flip;
      tiff_samples  = tiff_ifd[i].samples;
      tile_width    = tiff_ifd[i].tile_width;
      tile_length   = tiff_ifd[i].tile_length;
      shutter       = tiff_ifd[i].shutter;
      raw = i;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (is_raw == 1 &amp;&amp; ties) is_raw = ties;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!tile_width ) tile_width  = INT_MAX;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!tile_length) tile_length = INT_MAX;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=tiff_nifds; i--; )
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[i].flip) tiff_flip = tiff_ifd[i].flip;
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw &gt;= 0 &amp;&amp; !load_raw)
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_compress) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32767</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[raw].bytes == raw_width*raw_height) {
	  tiff_bps = 12;
	  maximum = 4095;
	  load_raw = &amp;CLASS sony_arw2_load_raw;			<B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {
	  raw_height += 8;
	  load_raw = &amp;CLASS sony_arw_load_raw;			<B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	load_flags = 79;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32769</FONT></B>:
	load_flags++;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32770</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32773</FONT></B>: <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">slr</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>:  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;OLYMPUS&quot;</FONT></B>,7) &amp;&amp;
		tiff_ifd[raw].bytes*2 == raw_width*raw_height*3)
	  load_flags = 24;
	<B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;SONY&quot;</FONT></B>) &amp;&amp; tiff_bps &lt; 14 &amp;&amp;
		tiff_ifd[raw].bytes == raw_width*raw_height*2)
	    tiff_bps = 14;
	<B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {
	  load_flags = 81;
	  tiff_bps = 12;
	} slr:
	<B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_bps) {
	  <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">8</FONT></B>: load_raw = &amp;CLASS eight_bit_load_raw;	<B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">12</FONT></B>: <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[raw].phint == 2)
		     load_flags = 6;
		   load_raw = &amp;CLASS packed_load_raw;		<B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">14</FONT></B>: load_raw = &amp;CLASS packed_load_raw;
		   <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[raw].bytes*4 == raw_width*raw_height*7) <B><FONT COLOR="#A020F0">break</FONT></B>;
		   load_flags = 0;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">16</FONT></B>: load_raw = &amp;CLASS unpacked_load_raw;
		   <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;OLYMPUS&quot;</FONT></B>,7) &amp;&amp;
			tiff_ifd[raw].bytes*7 &gt; raw_width*raw_height)
		     load_raw = &amp;CLASS olympus_load_raw;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9 &amp;&amp; tiff_ifd[raw].bytes*8 &lt; raw_width*raw_height*tiff_bps)
	  load_raw = &amp;CLASS fuji_xtrans_load_raw;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>:  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">7</FONT></B>:  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">99</FONT></B>:
	load_raw = &amp;CLASS lossless_jpeg_load_raw;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">262</FONT></B>:
	load_raw = &amp;CLASS kodak_262_load_raw;			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34713</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {
	  load_raw = &amp;CLASS packed_load_raw;
	  load_flags = 1;
	} <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {
	  load_raw = &amp;CLASS packed_load_raw;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (model[0] == <B><FONT COLOR="#BC8F8F">'N'</FONT></B>) load_flags = 80;
	} <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {
	  load_raw = &amp;CLASS nikon_yuv_load_raw;
	  gamma_curve (1/2.4, 12.92, 1, 4095);
	  memset (cblack, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cblack);
	  filters = 0;
	} <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {
	  load_raw = &amp;CLASS unpacked_load_raw;
	  load_flags = 4;
	  order = 0x4d4d;
	} <B><FONT COLOR="#A020F0">else</FONT></B>
	  load_raw = &amp;CLASS nikon_load_raw;			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">65535</FONT></B>:
	load_raw = &amp;CLASS pentax_load_raw;			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">65000</FONT></B>:
	<B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_ifd[raw].phint) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>: load_raw = &amp;CLASS kodak_rgb_load_raw;   filters = 0;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>: load_raw = &amp;CLASS kodak_ycbcr_load_raw; filters = 0;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32803</FONT></B>: load_raw = &amp;CLASS kodak_65000_load_raw;
	}
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">32867</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34892</FONT></B>: <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#5F9EA0">default</FONT></B>: is_raw = 0;
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!dng_version)
    <B><FONT COLOR="#A020F0">if</FONT></B> ( (tiff_samples == 3 &amp;&amp; tiff_ifd[raw].bytes &amp;&amp; tiff_bps != 14 &amp;&amp;
	  (tiff_compress &amp; -16) != 32768)
      || (tiff_bps == 8 &amp;&amp; strncmp(make,<B><FONT COLOR="#BC8F8F">&quot;Phase&quot;</FONT></B>,5) &amp;&amp;
	  !strcasestr(make,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>) &amp;&amp; !strstr(model2,<B><FONT COLOR="#BC8F8F">&quot;DEBUG RAW&quot;</FONT></B>)))
      is_raw = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; tiff_nifds; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (i != raw &amp;&amp; tiff_ifd[i].samples == max_samp &amp;&amp;
	tiff_ifd[i].width * tiff_ifd[i].height / (SQR(tiff_ifd[i].bps)+1) &gt;
	      thumb_width *       thumb_height / (SQR(thumb_misc)+1)
	&amp;&amp; tiff_ifd[i].comp != 34892) {
      thumb_width  = tiff_ifd[i].width;
      thumb_height = tiff_ifd[i].height;
      thumb_offset = tiff_ifd[i].offset;
      thumb_length = tiff_ifd[i].bytes;
      thumb_misc   = tiff_ifd[i].bps;
      thm = i;
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (thm &gt;= 0) {
    thumb_misc |= tiff_ifd[thm].samples &lt;&lt; 5;
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_ifd[thm].comp) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>:
	write_thumb = &amp;CLASS layer_thumb;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (tiff_ifd[thm].bps &lt;= 8)
	  write_thumb = &amp;CLASS ppm_thumb;
	<B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Imacon&quot;</FONT></B>))
	  write_thumb = &amp;CLASS ppm16_thumb;
	<B><FONT COLOR="#A020F0">else</FONT></B>
	  thumb_load_raw = &amp;CLASS kodak_thumb_load_raw;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">65000</FONT></B>:
	thumb_load_raw = tiff_ifd[thm].phint == 6 ?
		&amp;CLASS kodak_ycbcr_load_raw : &amp;CLASS kodak_rgb_load_raw;
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_minolta</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">int</FONT></B> save, tag, len, offset, high=0, wide=0, i, c;
  <B><FONT COLOR="#228B22">short</FONT></B> sorder=order;

  fseek (ifp, base, SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fgetc(ifp) || fgetc(ifp)-<B><FONT COLOR="#BC8F8F">'M'</FONT></B> || fgetc(ifp)-<B><FONT COLOR="#BC8F8F">'R'</FONT></B>) <B><FONT COLOR="#A020F0">return</FONT></B>;
  order = fgetc(ifp) * 0x101;
  offset = base + get4() + 8;
  <B><FONT COLOR="#A020F0">while</FONT></B> ((save=ftell(ifp)) &lt; offset) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (tag=i=0; i &lt; 4; i++)
      tag = tag &lt;&lt; 8 | fgetc(ifp);
    len = get4();
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x505244</FONT></B>:				<I><FONT COLOR="#B22222">/* PRD */</FONT></I>
	fseek (ifp, 8, SEEK_CUR);
	high = get2();
	wide = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x574247</FONT></B>:				<I><FONT COLOR="#B22222">/* WBG */</FONT></I>
	get4();
	i = strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DiMAGE A200&quot;</FONT></B>) ? 0:3;
	FORC4 cam_mul[c ^ (c &gt;&gt; 1) ^ i] = get2();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x545457</FONT></B>:				<I><FONT COLOR="#B22222">/* TTW */</FONT></I>
	parse_tiff (ftell(ifp));
	data_offset = offset;
    }
    fseek (ifp, save+len+8, SEEK_SET);
  }
  raw_height = high;
  raw_width  = wide;
  order = sorder;
}

<I><FONT COLOR="#B22222">/*
   Many cameras have a &quot;debug mode&quot; that writes JPEG and raw
   at the same time.  The raw file has no header, so try to
   to open the matching JPEG file and read its metadata.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_external_jpeg</FONT></B>()
{
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *file, *ext;
  <B><FONT COLOR="#228B22">char</FONT></B> *jname, *jfile, *jext;
  FILE *save=ifp;

  ext  = strrchr (ifname, <B><FONT COLOR="#BC8F8F">'.'</FONT></B>);
  file = strrchr (ifname, <B><FONT COLOR="#BC8F8F">'/'</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!file) file = strrchr (ifname, <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!file) file = ifname-1;
  file++;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!ext || strlen(ext) != 4 || ext-file != 8) <B><FONT COLOR="#A020F0">return</FONT></B>;
  jname = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (strlen(ifname) + 1);
  merror (jname, <B><FONT COLOR="#BC8F8F">&quot;parse_external_jpeg()&quot;</FONT></B>);
  strcpy (jname, ifname);
  jfile = file - ifname + jname;
  jext  = ext  - ifname + jname;
  <B><FONT COLOR="#A020F0">if</FONT></B> (strcasecmp (ext, <B><FONT COLOR="#BC8F8F">&quot;.jpg&quot;</FONT></B>)) {
    strcpy (jext, isupper(ext[1]) ? <B><FONT COLOR="#BC8F8F">&quot;.JPG&quot;</FONT></B>:<B><FONT COLOR="#BC8F8F">&quot;.jpg&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (isdigit(*file)) {
      memcpy (jfile, file+4, 4);
      memcpy (jfile+4, file, 4);
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    <B><FONT COLOR="#A020F0">while</FONT></B> (isdigit(*--jext)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (*jext != <B><FONT COLOR="#BC8F8F">'9'</FONT></B>) {
	(*jext)++;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      }
      *jext = <B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp (jname, ifname)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> ((ifp = fopen (jname, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>))) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
	fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Reading metadata from %s ...\n&quot;</FONT></B>), jname);
      parse_tiff (12);
      thumb_offset = 0;
      is_raw = 1;
      fclose (ifp);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!timestamp)
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Failed to read metadata from %s\n&quot;</FONT></B>), jname);
  free (jname);
  ifp = save;
}

<I><FONT COLOR="#B22222">/*
   CIFF block 0x1030 contains an 8x8 white sample.
   Load this into white[][] for use in scale_colors().
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">ciff_block_1030</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> ushort key[] = { 0x410, 0x45f3 };
  <B><FONT COLOR="#228B22">int</FONT></B> i, bpp, row, col, vbits=0;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> bitbuf=0;

  <B><FONT COLOR="#A020F0">if</FONT></B> ((get2(),get4()) != 0x80008 || !get4()) <B><FONT COLOR="#A020F0">return</FONT></B>;
  bpp = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> (bpp != 10 &amp;&amp; bpp != 12) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=row=0; row &lt; 8; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; 8; col++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (vbits &lt; bpp) {
	bitbuf = bitbuf &lt;&lt; 16 | (get2() ^ key[i++ &amp; 1]);
	vbits += 16;
      }
      white[row][col] = bitbuf &gt;&gt; (vbits -= bpp) &amp; ~(-1 &lt;&lt; bpp);
    }
}

<I><FONT COLOR="#B22222">/*
   Parse a CIFF file, better known as Canon CRW format.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_ciff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset, <B><FONT COLOR="#228B22">int</FONT></B> length, <B><FONT COLOR="#228B22">int</FONT></B> depth)
{
  <B><FONT COLOR="#228B22">int</FONT></B> tboff, nrecs, c, type, len, save, wbi=-1;
  ushort key[] = { 0x410, 0x45f3 };

  fseek (ifp, offset+length-4, SEEK_SET);
  tboff = get4() + offset;
  fseek (ifp, tboff, SEEK_SET);
  nrecs = get2();
  <B><FONT COLOR="#A020F0">if</FONT></B> ((nrecs | depth) &gt; 127) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">while</FONT></B> (nrecs--) {
    type = get2();
    len  = get4();
    save = ftell(ifp) + 4;
    fseek (ifp, offset+get4(), SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((((type &gt;&gt; 8) + 8) | 8) == 0x38)
      parse_ciff (ftell(ifp), len, depth+1); <I><FONT COLOR="#B22222">/* Parse a sub-table */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x0810)
      fread (artist, 64, 1, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x080a) {
      fread (make, 64, 1, ifp);
      fseek (ifp, strlen(make) - 63, SEEK_CUR);
      fread (model, 64, 1, ifp);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x1810) {
      width = get4();
      height = get4();
      pixel_aspect = int_to_float(get4());
      flip = get4();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x1835)			<I><FONT COLOR="#B22222">/* Get the decoder table */</FONT></I>
      tiff_compress = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x2007) {
      thumb_offset = ftell(ifp);
      thumb_length = len;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x1818) {
      shutter = pow (2, -int_to_float((get4(),get4())));
      aperture = pow (2, int_to_float(get4())/2);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x102a) {
      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;
      aperture  = pow (2, (get2(),(<B><FONT COLOR="#228B22">short</FONT></B>)get2())/64.0);
      shutter   = pow (2,-((<B><FONT COLOR="#228B22">short</FONT></B>)get2())/32.0);
      wbi = (get2(),get2());
      <B><FONT COLOR="#A020F0">if</FONT></B> (wbi &gt; 17) wbi = 0;
      fseek (ifp, 32, SEEK_CUR);
      <B><FONT COLOR="#A020F0">if</FONT></B> (shutter &gt; 1e6) shutter = get2()/10.0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x102c) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (get2() &gt; 512) {		<I><FONT COLOR="#B22222">/* Pro90, G1 */</FONT></I>
	fseek (ifp, 118, SEEK_CUR);
	FORC4 cam_mul[c ^ 2] = get2();
      } <B><FONT COLOR="#A020F0">else</FONT></B> {				<I><FONT COLOR="#B22222">/* G2, S30, S40 */</FONT></I>
	fseek (ifp, 98, SEEK_CUR);
	FORC4 cam_mul[c ^ (c &gt;&gt; 1) ^ 1] = get2();
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x0032) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (len == 768) {			<I><FONT COLOR="#B22222">/* EOS D30 */</FONT></I>
	fseek (ifp, 72, SEEK_CUR);
	FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = 1024.0 / get2();
	<B><FONT COLOR="#A020F0">if</FONT></B> (!wbi) cam_mul[0] = -1;	<I><FONT COLOR="#B22222">/* use my auto white balance */</FONT></I>
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!cam_mul[0]) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (get2() == key[0])		<I><FONT COLOR="#B22222">/* Pro1, G6, S60, S70 */</FONT></I>
	  c = (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;Pro1&quot;</FONT></B>) ?
	      <B><FONT COLOR="#BC8F8F">&quot;012346000000000000&quot;</FONT></B>:<B><FONT COLOR="#BC8F8F">&quot;01345:000000006008&quot;</FONT></B>)[wbi]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>+ 2;
	<B><FONT COLOR="#A020F0">else</FONT></B> {				<I><FONT COLOR="#B22222">/* G3, G5, S45, S50 */</FONT></I>
	  c = <B><FONT COLOR="#BC8F8F">&quot;023457000000006000&quot;</FONT></B>[wbi]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
	  key[0] = key[1] = 0;
	}
	fseek (ifp, 78 + c*8, SEEK_CUR);
	FORC4 cam_mul[c ^ (c &gt;&gt; 1) ^ 1] = get2() ^ key[c &amp; 1];
	<B><FONT COLOR="#A020F0">if</FONT></B> (!wbi) cam_mul[0] = -1;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x10a9) {		<I><FONT COLOR="#B22222">/* D60, 10D, 300D, and clones */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; 66) wbi = <B><FONT COLOR="#BC8F8F">&quot;0134567028&quot;</FONT></B>[wbi]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
      fseek (ifp, 2 + wbi*8, SEEK_CUR);
      FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get2();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x1030 &amp;&amp; (0x18040 &gt;&gt; wbi &amp; 1))
      ciff_block_1030();		<I><FONT COLOR="#B22222">/* all that don't have 0x10a9 */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x1031) {
      raw_width = (get2(),get2());
      raw_height = get2();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x5029) {
      focal_len = len &gt;&gt; 16;
      <B><FONT COLOR="#A020F0">if</FONT></B> ((len &amp; 0xffff) == 2) focal_len /= 32;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x5813) flash_used = int_to_float(len);
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x5814) canon_ev   = int_to_float(len);
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x5817) shot_order = len;
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x5834) unique_id  = len;
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x580e) timestamp  = len;
    <B><FONT COLOR="#A020F0">if</FONT></B> (type == 0x180e) timestamp  = get4();
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">LOCALTIME</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((type | 0x4000) == 0x580e)
      timestamp = mktime (gmtime (&amp;timestamp));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    fseek (ifp, save, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_rollei</FONT></B>()
{
  <B><FONT COLOR="#228B22">char</FONT></B> line[128], *val;
  <B><FONT COLOR="#228B22">struct</FONT></B> tm t;

  fseek (ifp, 0, SEEK_SET);
  memset (&amp;t, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> t);
  <B><FONT COLOR="#A020F0">do</FONT></B> {
    fgets (line, 128, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((val = strchr(line,<B><FONT COLOR="#BC8F8F">'='</FONT></B>)))
      *val++ = 0;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      val = line + strlen(line);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;DAT&quot;</FONT></B>))
      sscanf (val, <B><FONT COLOR="#BC8F8F">&quot;%d.%d.%d&quot;</FONT></B>, &amp;t.tm_mday, &amp;t.tm_mon, &amp;t.tm_year);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;TIM&quot;</FONT></B>))
      sscanf (val, <B><FONT COLOR="#BC8F8F">&quot;%d:%d:%d&quot;</FONT></B>, &amp;t.tm_hour, &amp;t.tm_min, &amp;t.tm_sec);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;HDR&quot;</FONT></B>))
      thumb_offset = atoi(val);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;X  &quot;</FONT></B>))
      raw_width = atoi(val);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;Y  &quot;</FONT></B>))
      raw_height = atoi(val);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;TX &quot;</FONT></B>))
      thumb_width = atoi(val);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(line,<B><FONT COLOR="#BC8F8F">&quot;TY &quot;</FONT></B>))
      thumb_height = atoi(val);
  } <B><FONT COLOR="#A020F0">while</FONT></B> (strncmp(line,<B><FONT COLOR="#BC8F8F">&quot;EOHD&quot;</FONT></B>,4));
  data_offset = thumb_offset + thumb_width * thumb_height * 2;
  t.tm_year -= 1900;
  t.tm_mon -= 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (mktime(&amp;t) &gt; 0)
    timestamp = mktime(&amp;t);
  strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Rollei&quot;</FONT></B>);
  strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;d530flex&quot;</FONT></B>);
  write_thumb = &amp;CLASS rollei_thumb;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_sinar_ia</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> entries, off;
  <B><FONT COLOR="#228B22">char</FONT></B> str[8], *cp;

  order = 0x4949;
  fseek (ifp, 4, SEEK_SET);
  entries = get4();
  fseek (ifp, get4(), SEEK_SET);
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    off = get4(); get4();
    fread (str, 8, 1, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(str,<B><FONT COLOR="#BC8F8F">&quot;META&quot;</FONT></B>))   meta_offset = off;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(str,<B><FONT COLOR="#BC8F8F">&quot;THUMB&quot;</FONT></B>)) thumb_offset = off;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(str,<B><FONT COLOR="#BC8F8F">&quot;RAW0&quot;</FONT></B>))   data_offset = off;
  }
  fseek (ifp, meta_offset+20, SEEK_SET);
  fread (make, 64, 1, ifp);
  make[63] = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> ((cp = strchr(make,<B><FONT COLOR="#BC8F8F">' '</FONT></B>))) {
    strcpy (model, cp+1);
    *cp = 0;
  }
  raw_width  = get2();
  raw_height = get2();
  load_raw = &amp;CLASS unpacked_load_raw;
  thumb_width = (get4(),get2());
  thumb_height = get2();
  write_thumb = &amp;CLASS ppm_thumb;
  maximum = 0x3fff;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_phase_one</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> base)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, type, len, data, save, i, c;
  <B><FONT COLOR="#228B22">float</FONT></B> romm_cam[3][3];
  <B><FONT COLOR="#228B22">char</FONT></B> *cp;

  memset (&amp;ph1, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> ph1);
  fseek (ifp, base, SEEK_SET);
  order = get4() &amp; 0xffff;
  <B><FONT COLOR="#A020F0">if</FONT></B> (get4() &gt;&gt; 8 != 0x526177) <B><FONT COLOR="#A020F0">return</FONT></B>;		<I><FONT COLOR="#B22222">/* &quot;Raw&quot; */</FONT></I>
  fseek (ifp, get4()+base, SEEK_SET);
  entries = get4();
  get4();
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tag  = get4();
    type = get4();
    len  = get4();
    data = get4();
    save = ftell(ifp);
    fseek (ifp, base+data, SEEK_SET);
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x100</FONT></B>:  flip = <B><FONT COLOR="#BC8F8F">&quot;0653&quot;</FONT></B>[data &amp; 3]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x106</FONT></B>:
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 9; i++)
	  ((<B><FONT COLOR="#228B22">float</FONT></B> *)romm_cam)[i] = getreal(11);
	romm_coeff (romm_cam);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x107</FONT></B>:
	FORC3 cam_mul[c] = getreal(11);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x108</FONT></B>:  raw_width     = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x109</FONT></B>:  raw_height    = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10a</FONT></B>:  left_margin   = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10b</FONT></B>:  top_margin    = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10c</FONT></B>:  width         = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10d</FONT></B>:  height        = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10e</FONT></B>:  ph1.format    = data;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x10f</FONT></B>:  data_offset   = data+base;	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x110</FONT></B>:  meta_offset   = data+base;
		   meta_length   = len;			<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x112</FONT></B>:  ph1.key_off   = save - 4;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x210</FONT></B>:  ph1.tag_210   = int_to_float(data);	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x21a</FONT></B>:  ph1.tag_21a   = data;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x21c</FONT></B>:  strip_offset  = data+base;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x21d</FONT></B>:  ph1.black     = data;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x222</FONT></B>:  ph1.split_col = data;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x223</FONT></B>:  ph1.black_col = data+base;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x224</FONT></B>:  ph1.split_row = data;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x225</FONT></B>:  ph1.black_row = data+base;		<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x301</FONT></B>:
	model[63] = 0;
	fread (model, 1, 63, ifp);
	<B><FONT COLOR="#A020F0">if</FONT></B> ((cp = strstr(model,<B><FONT COLOR="#BC8F8F">&quot; camera&quot;</FONT></B>))) *cp = 0;
    }
    fseek (ifp, save, SEEK_SET);
  }
  load_raw = ph1.format &lt; 3 ?
	&amp;CLASS phase_one_load_raw : &amp;CLASS phase_one_load_raw_c;
  maximum = 0xffff;
  strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Phase One&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (model[0]) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">switch</FONT></B> (raw_height) {
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2060</FONT></B>: strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;LightPhase&quot;</FONT></B>);	<B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2682</FONT></B>: strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;H 10&quot;</FONT></B>);		<B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">4128</FONT></B>: strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;H 20&quot;</FONT></B>);		<B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">5488</FONT></B>: strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;H 25&quot;</FONT></B>);		<B><FONT COLOR="#A020F0">break</FONT></B>;
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_fuji</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> entries, tag, len, save, c;

  fseek (ifp, offset, SEEK_SET);
  entries = get4();
  <B><FONT COLOR="#A020F0">if</FONT></B> (entries &gt; 255) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    tag = get2();
    len = get2();
    save = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x100) {
      raw_height = get2();
      raw_width  = get2();
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x121) {
      height = get2();
      <B><FONT COLOR="#A020F0">if</FONT></B> ((width = get2()) == 4284) width += 3;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x130) {
      fuji_layout = fgetc(ifp) &gt;&gt; 7;
      fuji_width = !(fgetc(ifp) &amp; 8);
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x131) {
      filters = 9;
      FORC(36) xtrans_abs[0][35-c] = fgetc(ifp) &amp; 3;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0x2ff0) {
      FORC4 cam_mul[c ^ 1] = get2();
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (tag == 0xc000 &amp;&amp; len &gt; 20000) {
      c = order;
      order = 0x4949;
      <B><FONT COLOR="#A020F0">while</FONT></B> ((tag = get4()) &gt; raw_width);
      width = tag;
      height = get4();
      order = c;
    }
    fseek (ifp, save+len, SEEK_SET);
  }
  height &lt;&lt;= fuji_layout;
  width  &gt;&gt;= fuji_layout;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_jpeg</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset)
{
  <B><FONT COLOR="#228B22">int</FONT></B> len, save, hlen, mark;

  fseek (ifp, offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <B><FONT COLOR="#A020F0">while</FONT></B> (fgetc(ifp) == 0xff &amp;&amp; (mark = fgetc(ifp)) != 0xda) {
    order = 0x4d4d;
    len   = get2() - 2;
    save  = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {
      fgetc(ifp);
      raw_height = get2();
      raw_width  = get2();
    }
    order = get2();
    hlen  = get4();
    <B><FONT COLOR="#A020F0">if</FONT></B> (get4() == 0x48454150)		<I><FONT COLOR="#B22222">/* &quot;HEAP&quot; */</FONT></I>
      parse_ciff (save+hlen, len-hlen, 0);
    <B><FONT COLOR="#A020F0">if</FONT></B> (parse_tiff (save+6)) apply_tiff();
    fseek (ifp, save+len, SEEK_SET);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_riff</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, size, end;
  <B><FONT COLOR="#228B22">char</FONT></B> tag[4], date[64], month[64];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> mon[12][4] =
  { <B><FONT COLOR="#BC8F8F">&quot;Jan&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Feb&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Mar&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Apr&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;May&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Jun&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Jul&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Aug&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Sep&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Oct&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Nov&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Dec&quot;</FONT></B> };
  <B><FONT COLOR="#228B22">struct</FONT></B> tm t;

  order = 0x4949;
  fread (tag, 4, 1, ifp);
  size = get4();
  end = ftell(ifp) + size;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;RIFF&quot;</FONT></B>,4) || !memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;LIST&quot;</FONT></B>,4)) {
    get4();
    <B><FONT COLOR="#A020F0">while</FONT></B> (ftell(ifp)+7 &lt; end &amp;&amp; !feof(ifp))
      parse_riff();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;nctg&quot;</FONT></B>,4)) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (ftell(ifp)+7 &lt; end) {
      i = get2();
      size = get2();
      <B><FONT COLOR="#A020F0">if</FONT></B> ((i+1) &gt;&gt; 1 == 10 &amp;&amp; size == 20)
	get_timestamp(0);
      <B><FONT COLOR="#A020F0">else</FONT></B> fseek (ifp, size, SEEK_CUR);
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;IDIT&quot;</FONT></B>,4) &amp;&amp; size &lt; 64) {
    fread (date, 64, 1, ifp);
    date[size] = 0;
    memset (&amp;t, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (sscanf (date, <B><FONT COLOR="#BC8F8F">&quot;%*s %s %d %d:%d:%d %d&quot;</FONT></B>, month, &amp;t.tm_mday,
	&amp;t.tm_hour, &amp;t.tm_min, &amp;t.tm_sec, &amp;t.tm_year) == 6) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 12 &amp;&amp; strcasecmp(mon[i],month); i++);
      t.tm_mon = i;
      t.tm_year -= 1900;
      <B><FONT COLOR="#A020F0">if</FONT></B> (mktime(&amp;t) &gt; 0)
	timestamp = mktime(&amp;t);
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    fseek (ifp, size, SEEK_CUR);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_crx</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> end)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, save, size, tag, base;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> index=0, wide, high, off, len;

  order = 0x4d4d;
  <B><FONT COLOR="#A020F0">while</FONT></B> (ftell(ifp)+7 &lt; end) {
    save = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((size = get4()) &lt; 8) <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag = get4()) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x6d6f6f76</FONT></B>:				<I><FONT COLOR="#B22222">/* moov */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x7472616b</FONT></B>:				<I><FONT COLOR="#B22222">/* trak */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x6d646961</FONT></B>:				<I><FONT COLOR="#B22222">/* mdia */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x6d696e66</FONT></B>:				<I><FONT COLOR="#B22222">/* minf */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x7374626c</FONT></B>:				<I><FONT COLOR="#B22222">/* stbl */</FONT></I>
	parse_crx (save+size);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x75756964</FONT></B>:				<I><FONT COLOR="#B22222">/* uuid */</FONT></I>
	<B><FONT COLOR="#A020F0">switch</FONT></B> (i=get4()) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0xeaf42b5e</FONT></B>: fseek (ifp,  8, SEEK_CUR);
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x85c0b687</FONT></B>: fseek (ifp, 12, SEEK_CUR);
	    parse_crx (save+size);
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x434d5431</FONT></B>:				<I><FONT COLOR="#B22222">/* CMT1 */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x434d5432</FONT></B>:				<I><FONT COLOR="#B22222">/* CMT2 */</FONT></I>
	base = ftell(ifp);
	order = get2();
	fseek (ifp, 6, SEEK_CUR);
	tag &amp; 1 ? parse_tiff_ifd (base) : parse_exif (base);
	order = 0x4d4d;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x746b6864</FONT></B>:				<I><FONT COLOR="#B22222">/* tkhd */</FONT></I>
	fseek (ifp, 12, SEEK_CUR);
	index = get4();
	fseek (ifp, 58, SEEK_CUR);
	wide = get4();
	high = get4();
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x7374737a</FONT></B>:				<I><FONT COLOR="#B22222">/* stsz */</FONT></I>
	len = (get4(),get4());
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x636f3634</FONT></B>:				<I><FONT COLOR="#B22222">/* co64 */</FONT></I>
	fseek (ifp, 12, SEEK_CUR);
	off = get4();
	<B><FONT COLOR="#A020F0">switch</FONT></B> (index) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:			<I><FONT COLOR="#B22222">/* 1 = full size, 2 = 27% size */</FONT></I>
	    thumb_width  = wide;
	    thumb_height = high;
	    thumb_length = len;
	    thumb_offset = off;
	    <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3</FONT></B>:
	    raw_width  = wide;
	    raw_height = high;
	    data_offset = off;
	    load_raw = &amp;CLASS canon_crx_load_raw;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x50525657</FONT></B>:				<I><FONT COLOR="#B22222">/* PRVW */</FONT></I>
	fseek (ifp, 6, SEEK_CUR);
    }
    fseek (ifp, save+size, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_qt</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> end)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> save, size;
  <B><FONT COLOR="#228B22">char</FONT></B> tag[4];

  order = 0x4d4d;
  <B><FONT COLOR="#A020F0">while</FONT></B> (ftell(ifp)+7 &lt; end) {
    save = ftell(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((size = get4()) &lt; 8) <B><FONT COLOR="#A020F0">return</FONT></B>;
    fread (tag, 4, 1, ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;moov&quot;</FONT></B>,4) ||
	!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;udta&quot;</FONT></B>,4) ||
	!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;CNTH&quot;</FONT></B>,4))
      parse_qt (save+size);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp(tag,<B><FONT COLOR="#BC8F8F">&quot;CNDA&quot;</FONT></B>,4))
      parse_jpeg (ftell(ifp));
    fseek (ifp, save+size, SEEK_SET);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_smal</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset, <B><FONT COLOR="#228B22">int</FONT></B> fsize)
{
  <B><FONT COLOR="#228B22">int</FONT></B> ver;

  fseek (ifp, offset+2, SEEK_SET);
  order = 0x4949;
  ver = fgetc(ifp);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver == 6)
    fseek (ifp, 5, SEEK_CUR);
  <B><FONT COLOR="#A020F0">if</FONT></B> (get4() != fsize) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver &gt; 6) data_offset = get4();
  raw_height = height = get2();
  raw_width  = width  = get2();
  strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;SMaL&quot;</FONT></B>);
  sprintf (model, <B><FONT COLOR="#BC8F8F">&quot;v%d %dx%d&quot;</FONT></B>, ver, width, height);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver == 6) load_raw = &amp;CLASS smal_v6_load_raw;
  <B><FONT COLOR="#A020F0">if</FONT></B> (ver == 9) load_raw = &amp;CLASS smal_v9_load_raw;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_cine</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> off_head, off_setup, off_image, i;

  order = 0x4949;
  fseek (ifp, 4, SEEK_SET);
  is_raw = get2() == 2;
  fseek (ifp, 14, SEEK_CUR);
  is_raw *= get4();
  off_head = get4();
  off_setup = get4();
  off_image = get4();
  timestamp = get4();
  <B><FONT COLOR="#A020F0">if</FONT></B> ((i = get4())) timestamp = i;
  fseek (ifp, off_head+4, SEEK_SET);
  raw_width = get4();
  raw_height = get4();
  <B><FONT COLOR="#A020F0">switch</FONT></B> (get2(),get2()) {
    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">8</FONT></B>:  load_raw = &amp;CLASS eight_bit_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">16</FONT></B>:  load_raw = &amp;CLASS  unpacked_load_raw;
  }
  fseek (ifp, off_setup+792, SEEK_SET);
  strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;CINE&quot;</FONT></B>);
  sprintf (model, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, get4());
  fseek (ifp, 12, SEEK_CUR);
  <B><FONT COLOR="#A020F0">switch</FONT></B> ((i=get4()) &amp; 0xffffff) {
    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">3</FONT></B>:  filters = 0x94949494;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">4</FONT></B>:  filters = 0x49494949;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#5F9EA0">default</FONT></B>:  is_raw = 0;
  }
  fseek (ifp, 72, SEEK_CUR);
  <B><FONT COLOR="#A020F0">switch</FONT></B> ((get4()+3600) % 360) {
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">270</FONT></B>:  flip = 4;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">180</FONT></B>:  flip = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">90</FONT></B>:  flip = 7;  <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">case</FONT></B>   <B><FONT COLOR="#5F9EA0">0</FONT></B>:  flip = 2;
  }
  cam_mul[0] = getreal(11);
  cam_mul[2] = getreal(11);
  maximum = ~(-1 &lt;&lt; get4());
  fseek (ifp, 668, SEEK_CUR);
  shutter = get4()/1000000000.0;
  fseek (ifp, off_image, SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (shot_select &lt; is_raw)
    fseek (ifp, shot_select*8, SEEK_CUR);
  data_offset  = (INT64) get4() + 8;
  data_offset += (INT64) get4() &lt;&lt; 32;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_redcine</FONT></B>()
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> i, len, rdvo;

  order = 0x4d4d;
  is_raw = 0;
  fseek (ifp, 52, SEEK_SET);
  width  = get4();
  height = get4();
  fseek (ifp, 0, SEEK_END);
  fseek (ifp, -(i = ftello(ifp) &amp; 511), SEEK_CUR);
  <B><FONT COLOR="#A020F0">if</FONT></B> (get4() != i || get4() != 0x52454f42) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: Tail is missing, parsing from head...\n&quot;</FONT></B>), ifname);
    fseek (ifp, 0, SEEK_SET);
    <B><FONT COLOR="#A020F0">while</FONT></B> ((len = get4()) != EOF) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (get4() == 0x52454456)
	<B><FONT COLOR="#A020F0">if</FONT></B> (is_raw++ == shot_select)
	  data_offset = ftello(ifp) - 8;
      fseek (ifp, len-8, SEEK_CUR);
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    rdvo = get4();
    fseek (ifp, 12, SEEK_CUR);
    is_raw = get4();
    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);
    data_offset = get4();
  }
}

<B><FONT COLOR="#228B22">char</FONT></B> * CLASS <B><FONT COLOR="#0000FF">foveon_gets</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> offset, <B><FONT COLOR="#228B22">char</FONT></B> *str, <B><FONT COLOR="#228B22">int</FONT></B> len)
{
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  fseek (ifp, offset, SEEK_SET);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; len-1; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> ((str[i] = get2()) == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
  str[i] = 0;
  <B><FONT COLOR="#A020F0">return</FONT></B> str;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">parse_foveon</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];
  <B><FONT COLOR="#228B22">char</FONT></B> name[64], value[64];

  order = 0x4949;			<I><FONT COLOR="#B22222">/* Little-endian */</FONT></I>
  fseek (ifp, 36, SEEK_SET);
  flip = get4();
  fseek (ifp, -4, SEEK_END);
  fseek (ifp, get4(), SEEK_SET);
  <B><FONT COLOR="#A020F0">if</FONT></B> (get4() != 0x64434553) <B><FONT COLOR="#A020F0">return</FONT></B>;	<I><FONT COLOR="#B22222">/* SECd */</FONT></I>
  entries = (get4(),get4());
  <B><FONT COLOR="#A020F0">while</FONT></B> (entries--) {
    off = get4();
    len = get4();
    tag = get4();
    save = ftell(ifp);
    fseek (ifp, off, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (get4() != (0x20434553 | (tag &lt;&lt; 24))) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tag) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x47414d49</FONT></B>:			<I><FONT COLOR="#B22222">/* IMAG */</FONT></I>
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x32414d49</FONT></B>:			<I><FONT COLOR="#B22222">/* IMA2 */</FONT></I>
	fseek (ifp, 8, SEEK_CUR);
	pent = get4();
	wide = get4();
	high = get4();
	<B><FONT COLOR="#A020F0">if</FONT></B> (wide &gt; raw_width &amp;&amp; high &gt; raw_height) {
	  <B><FONT COLOR="#A020F0">switch</FONT></B> (pent) {
	    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">5</FONT></B>:  load_flags = 1;
	    <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">6</FONT></B>:  load_raw = &amp;CLASS foveon_sd_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	    <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">30</FONT></B>:  load_raw = &amp;CLASS foveon_dp_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	    <B><FONT COLOR="#5F9EA0">default</FONT></B>:  load_raw = 0;
	  }
	  raw_width  = wide;
	  raw_height = high;
	  data_offset = off+28;
	  is_foveon = 1;
	}
	fseek (ifp, off+28, SEEK_SET);
	<B><FONT COLOR="#A020F0">if</FONT></B> (fgetc(ifp) == 0xff &amp;&amp; fgetc(ifp) == 0xd8
		&amp;&amp; thumb_length &lt; len-28) {
	  thumb_offset = off+28;
	  thumb_length = len-28;
	  write_thumb = &amp;CLASS jpeg_thumb;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (++img == 2 &amp;&amp; !thumb_length) {
	  thumb_offset = off+24;
	  thumb_width = wide;
	  thumb_height = high;
	  write_thumb = &amp;CLASS foveon_thumb;
	}
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x464d4143</FONT></B>:			<I><FONT COLOR="#B22222">/* CAMF */</FONT></I>
	meta_offset = off+8;
	meta_length = len-28;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0x504f5250</FONT></B>:			<I><FONT COLOR="#B22222">/* PROP */</FONT></I>
	pent = (get4(),get4());
	fseek (ifp, 12, SEEK_CUR);
	off += pent*8 + 24;
	<B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">unsigned</FONT></B>) pent &gt; 256) pent=256;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; pent*2; i++)
	  ((<B><FONT COLOR="#228B22">int</FONT></B> *)poff)[i] = off + get4()*2;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; pent; i++) {
	  foveon_gets (poff[i][0], name, 64);
	  foveon_gets (poff[i][1], value, 64);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;ISO&quot;</FONT></B>))
	    iso_speed = atoi(value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;CAMMANUF&quot;</FONT></B>))
	    strcpy (make, value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;CAMMODEL&quot;</FONT></B>))
	    strcpy (model, value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;WB_DESC&quot;</FONT></B>))
	    strcpy (model2, value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;TIME&quot;</FONT></B>))
	    timestamp = atoi(value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;EXPTIME&quot;</FONT></B>))
	    shutter = atoi(value) / 1000000.0;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;APERTURE&quot;</FONT></B>))
	    aperture = atof(value);
	  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (name, <B><FONT COLOR="#BC8F8F">&quot;FLENGTH&quot;</FONT></B>))
	    focal_len = atof(value);
	}
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">LOCALTIME</FONT>
	timestamp = mktime (gmtime (&amp;timestamp));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    }
    fseek (ifp, save, SEEK_SET);
  }
}

<I><FONT COLOR="#B22222">/*
   All matrices are from Adobe DNG Converter unless otherwise noted.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">adobe_coeff</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *make, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *model)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *prefix;
    <B><FONT COLOR="#228B22">short</FONT></B> black, maximum, trans[12];
  } table[] = {
    { <B><FONT COLOR="#BC8F8F">&quot;AgfaPhoto DC-833m&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Apple QuickTake&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS D2000&quot;</FONT></B>, 0, 0,
	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS D6000&quot;</FONT></B>, 0, 0,
	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS D30&quot;</FONT></B>, 0, 0,
	{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS D60&quot;</FONT></B>, 0, 0xfa0,
	{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 5DS&quot;</FONT></B>, 0, 0x3c96,
	{ 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 5D Mark IV&quot;</FONT></B>, 0, 0,
	{ 6446,-366,-864,-4436,12204,2513,-952,2496,6348 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 5D Mark III&quot;</FONT></B>, 0, 0x3c80,
	{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 5D Mark II&quot;</FONT></B>, 0, 0x3cf0,
	{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 5D&quot;</FONT></B>, 0, 0xe6c,
	{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 6D Mark II&quot;</FONT></B>, 0, 0,
	{ 6875,-970,-932,-4691,12459,2501,-874,1953,5809 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 6D&quot;</FONT></B>, 0, 0x3c82,
	{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 7D Mark II&quot;</FONT></B>, 0, 0x3510,
	{ 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 7D&quot;</FONT></B>, 0, 0x3510,
	{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 10D&quot;</FONT></B>, 0, 0xfa0,
	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 20Da&quot;</FONT></B>, 0, 0,
	{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 20D&quot;</FONT></B>, 0, 0xfff,
	{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 30D&quot;</FONT></B>, 0, 0,
	{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 40D&quot;</FONT></B>, 0, 0x3f60,
	{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 50D&quot;</FONT></B>, 0, 0x3d93,
	{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 60D&quot;</FONT></B>, 0, 0x2ff7,
	{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 70D&quot;</FONT></B>, 0, 0x3bc7,
	{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 77D&quot;</FONT></B>, 0, 0,
	{ 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 80D&quot;</FONT></B>, 0, 0,
	{ 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 100D&quot;</FONT></B>, 0, 0x350f,
	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 200D&quot;</FONT></B>, 0, 0,
	{ 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 300D&quot;</FONT></B>, 0, 0xfa0,
	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 350D&quot;</FONT></B>, 0, 0xfff,
	{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 400D&quot;</FONT></B>, 0, 0xe8e,
	{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 450D&quot;</FONT></B>, 0, 0x390d,
	{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 500D&quot;</FONT></B>, 0, 0x3479,
	{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 550D&quot;</FONT></B>, 0, 0x3dd7,
	{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 600D&quot;</FONT></B>, 0, 0x3510,
	{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 650D&quot;</FONT></B>, 0, 0x354d,
	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 700D&quot;</FONT></B>, 0, 0x3c00,
	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 750D&quot;</FONT></B>, 0, 0x368e,
	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 760D&quot;</FONT></B>, 0, 0x350f,
	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 800D&quot;</FONT></B>, 0, 0,
	{ 6970,-512,-968,-4425,12161,2553,-739,1982,5601 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 1000D&quot;</FONT></B>, 0, 0xe43,
	{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 1100D&quot;</FONT></B>, 0, 0x3510,
	{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 1200D&quot;</FONT></B>, 0, 0x37c2,
	{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 1300D&quot;</FONT></B>, 0, 0x3510,
	{ 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 1500D&quot;</FONT></B>, 0, 0,
	{ 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS 3000D&quot;</FONT></B>, 0, 0,
	{ 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M6&quot;</FONT></B>, 0, 0,
	{ 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M5&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also M50 */</FONT></I>
	{ 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M3&quot;</FONT></B>, 0, 0,
	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M100&quot;</FONT></B>, 0, 0,
	{ 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M10&quot;</FONT></B>, 0, 0,
	{ 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS M&quot;</FONT></B>, 0, 0,
	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1Ds Mark III&quot;</FONT></B>, 0, 0x3bb0,
	{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1Ds Mark II&quot;</FONT></B>, 0, 0xe80,
	{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D Mark IV&quot;</FONT></B>, 0, 0x3bb0,
	{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D Mark III&quot;</FONT></B>, 0, 0x3bb0,
	{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D Mark II N&quot;</FONT></B>, 0, 0xe80,
	{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D Mark II&quot;</FONT></B>, 0, 0xe80,
	{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1DS&quot;</FONT></B>, 0, 0xe20,
	{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D C&quot;</FONT></B>, 0, 0x3c4e,
	{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D X Mark II&quot;</FONT></B>, 0, 0,
	{ 7596,-978,-967,-4808,12571,2503,-1398,2567,5752 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D X&quot;</FONT></B>, 0, 0x3c4e,
	{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS-1D&quot;</FONT></B>, 0, 0xe20,
	{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon EOS C500&quot;</FONT></B>, 853, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A530&quot;</FONT></B>, 0, 0,
	{ 0 } },	<I><FONT COLOR="#B22222">/* don't want the A5 matrix */</FONT></I>
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A50&quot;</FONT></B>, 0, 0,
	{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A5&quot;</FONT></B>, 0, 0,
	{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G10&quot;</FONT></B>, 0, 0,
	{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G11&quot;</FONT></B>, 0, 0,
	{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G12&quot;</FONT></B>, 0, 0,
	{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G15&quot;</FONT></B>, 0, 0,
	{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G16&quot;</FONT></B>, 0, 0,
	{ 8020,-2687,-682,-3704,11879,2052,-965,1921,5556 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G1 X Mark III&quot;</FONT></B>, 0, 0,
	{ 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G1 X&quot;</FONT></B>, 0, 0,
	{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G1&quot;</FONT></B>, 0, 0,
	{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G2&quot;</FONT></B>, 0, 0,
	{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G3 X&quot;</FONT></B>, 0, 0,
	{ 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G3&quot;</FONT></B>, 0, 0,
	{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G5 X&quot;</FONT></B>, 0, 0,
	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G5&quot;</FONT></B>, 0, 0,
	{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G6&quot;</FONT></B>, 0, 0,
	{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G7 X&quot;</FONT></B>, 0, 0,
	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G9 X Mark II&quot;</FONT></B>, 0, 0,
	{ 10056,-4131,-944,-2576,11143,1625,-238,1294,5179 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G9 X&quot;</FONT></B>, 0, 0,
	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot G9&quot;</FONT></B>, 0, 0,
	{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot Pro1&quot;</FONT></B>, 0, 0,
	{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot Pro70&quot;</FONT></B>, 34, 0,
	{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot Pro90&quot;</FONT></B>, 0, 0,
	{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S30&quot;</FONT></B>, 0, 0,
	{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S40&quot;</FONT></B>, 0, 0,
	{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S45&quot;</FONT></B>, 0, 0,
	{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S50&quot;</FONT></B>, 0, 0,
	{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S60&quot;</FONT></B>, 0, 0,
	{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S70&quot;</FONT></B>, 0, 0,
	{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S90&quot;</FONT></B>, 0, 0,
	{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S95&quot;</FONT></B>, 0, 0,
	{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S100&quot;</FONT></B>, 0, 0,
	{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S110&quot;</FONT></B>, 0, 0,
	{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S120&quot;</FONT></B>, 0, 0,
	{ 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot SX1 IS&quot;</FONT></B>, 0, 0,
	{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot SX50 HS&quot;</FONT></B>, 0, 0,
	{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot SX60 HS&quot;</FONT></B>, 0, 0,
	{ 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A3300&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A470&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A610&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A620&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A630&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A640&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A650&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot A720&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot S3 IS&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot SX110 IS&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon PowerShot SX220&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Canon IXUS 160&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Casio EX-S20&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Casio EX-Z750&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Casio EX-Z10&quot;</FONT></B>, 128, 0xfff,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },
    { <B><FONT COLOR="#BC8F8F">&quot;CINE 650&quot;</FONT></B>, 0, 0,
	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
    { <B><FONT COLOR="#BC8F8F">&quot;CINE 660&quot;</FONT></B>, 0, 0,
	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
    { <B><FONT COLOR="#BC8F8F">&quot;CINE&quot;</FONT></B>, 0, 0,
	{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Contax N Digital&quot;</FONT></B>, 0, 0xf1e,
	{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },
    { <B><FONT COLOR="#BC8F8F">&quot;DXO ONE&quot;</FONT></B>, 0, 0,
	{ 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Epson R-D1&quot;</FONT></B>, 0, 0,
	{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm E550&quot;</FONT></B>, 0, 0,
	{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm E900&quot;</FONT></B>, 0, 0,
	{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F5&quot;</FONT></B>, 0, 0,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F6&quot;</FONT></B>, 0, 0,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F77&quot;</FONT></B>, 0, 0xfe9,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F7&quot;</FONT></B>, 0, 0,
	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F8&quot;</FONT></B>, 0, 0,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm GFX 50S&quot;</FONT></B>, 0, 0,
	{ 11756,-4754,-874,-3056,11045,2305,-381,1457,6006 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S100FS&quot;</FONT></B>, 514, 0,
	{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S1&quot;</FONT></B>, 0, 0,
	{ 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S20Pro&quot;</FONT></B>, 0, 0,
	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S20&quot;</FONT></B>, 512, 0x3fff,
	{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S2Pro&quot;</FONT></B>, 128, 0xf15,
	{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S3Pro&quot;</FONT></B>, 0, 0x3dff,
	{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5Pro&quot;</FONT></B>, 0, 0,
	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5000&quot;</FONT></B>, 0, 0,
	{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5100&quot;</FONT></B>, 0, 0,
	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5500&quot;</FONT></B>, 0, 0,
	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5200&quot;</FONT></B>, 0, 0,
	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S5600&quot;</FONT></B>, 0, 0,
	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S6&quot;</FONT></B>, 0, 0,
	{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S7000&quot;</FONT></B>, 0, 0,
	{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S9000&quot;</FONT></B>, 0, 0,
	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S9500&quot;</FONT></B>, 0, 0,
	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S9100&quot;</FONT></B>, 0, 0,
	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm S9600&quot;</FONT></B>, 0, 0,
	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm SL1000&quot;</FONT></B>, 0, 0,
	{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm IS-1&quot;</FONT></B>, 0, 0,
	{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm IS Pro&quot;</FONT></B>, 0, 0,
	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm HS10 HS11&quot;</FONT></B>, 0, 0xf68,
	{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm HS2&quot;</FONT></B>, 0, 0xfef,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm HS3&quot;</FONT></B>, 0, 0,
	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm HS50EXR&quot;</FONT></B>, 0, 0,
	{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm F900EXR&quot;</FONT></B>, 0, 0,
	{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X100F&quot;</FONT></B>, 0, 0,
	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X100S&quot;</FONT></B>, 0, 0,
	{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X100T&quot;</FONT></B>, 0, 0,
	{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X100&quot;</FONT></B>, 0, 0,
	{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X10&quot;</FONT></B>, 0, 0,
	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X20&quot;</FONT></B>, 0, 0,
	{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X30&quot;</FONT></B>, 0, 0,
	{ 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X70&quot;</FONT></B>, 0, 0,
	{ 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-Pro1&quot;</FONT></B>, 0, 0,
	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-Pro2&quot;</FONT></B>, 0, 0,
	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A10&quot;</FONT></B>, 0, 0,
	{ 11540,-4999,-991,-2949,10963,2278,-382,1049,5605 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A20&quot;</FONT></B>, 0, 0,
	{ 11540,-4999,-991,-2949,10963,2278,-382,1049,5605 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A1&quot;</FONT></B>, 0, 0,
	{ 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A2&quot;</FONT></B>, 0, 0,
	{ 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A3&quot;</FONT></B>, 0, 0,
	{ 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-A5&quot;</FONT></B>, 0, 0,
	{ 11673,-4760,-1041,-3988,12058,2166,-771,1417,5569 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-E1&quot;</FONT></B>, 0, 0,
	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-E2S&quot;</FONT></B>, 0, 0,
	{ 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-E2&quot;</FONT></B>, 0, 0,
	{ 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-E3&quot;</FONT></B>, 0, 0,
	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-H1&quot;</FONT></B>, 0, 0,
	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-M1&quot;</FONT></B>, 0, 0,
	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-S1&quot;</FONT></B>, 0, 0,
	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-T1&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also X-T10 */</FONT></I>
	{ 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm X-T2&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also X-T20 */</FONT></I>
	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm XF1&quot;</FONT></B>, 0, 0,
	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Fujifilm XQ&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* XQ1 and XQ2 */</FONT></I>
	{ 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },
    { <B><FONT COLOR="#BC8F8F">&quot;GoPro HERO5 Black&quot;</FONT></B>, 0, 0,
	{ 10344,-4210,-620,-2315,10625,1948,93,1058,5541 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Imacon Ixpress&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak NC2000&quot;</FONT></B>, 0, 0,
	{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS315C&quot;</FONT></B>, 8, 0,
	{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS330C&quot;</FONT></B>, 8, 0,
	{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS420&quot;</FONT></B>, 0, 0,
	{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS460&quot;</FONT></B>, 0, 0,
	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EOSDCS1&quot;</FONT></B>, 0, 0,
	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EOSDCS3B&quot;</FONT></B>, 0, 0,
	{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS520C&quot;</FONT></B>, 178, 0,
	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS560C&quot;</FONT></B>, 177, 0,
	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS620C&quot;</FONT></B>, 177, 0,
	{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS620X&quot;</FONT></B>, 176, 0,
	{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS660C&quot;</FONT></B>, 173, 0,
	{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS720X&quot;</FONT></B>, 0, 0,
	{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS760C&quot;</FONT></B>, 0, 0,
	{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS Pro SLR&quot;</FONT></B>, 0, 0,
	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS Pro 14nx&quot;</FONT></B>, 0, 0,
	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak DCS Pro 14&quot;</FONT></B>, 0, 0,
	{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak ProBack645&quot;</FONT></B>, 0, 0,
	{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak ProBack&quot;</FONT></B>, 0, 0,
	{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak P712&quot;</FONT></B>, 0, 0,
	{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak P850&quot;</FONT></B>, 0, 0xf7c,
	{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak P880&quot;</FONT></B>, 0, 0xfff,
	{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EasyShare Z980&quot;</FONT></B>, 0, 0,
	{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EasyShare Z981&quot;</FONT></B>, 0, 0,
	{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EasyShare Z990&quot;</FONT></B>, 0, 0xfed,
	{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Kodak EASYSHARE Z1015&quot;</FONT></B>, 0, 0xef1,
	{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf CMost&quot;</FONT></B>, 0, 0,
	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf Valeo 6&quot;</FONT></B>, 0, 0,
	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf Aptus 54S&quot;</FONT></B>, 0, 0,
	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf Aptus 65&quot;</FONT></B>, 0, 0,
	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf Aptus 75&quot;</FONT></B>, 0, 0,
	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leaf&quot;</FONT></B>, 0, 0,
	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Mamiya ZD&quot;</FONT></B>, 0, 0,
	{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Micron 2010&quot;</FONT></B>, 110, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE 5&quot;</FONT></B>, 0, 0xf7d,
	{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE 7Hi&quot;</FONT></B>, 0, 0xf7d,
	{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE 7&quot;</FONT></B>, 0, 0xf7d,
	{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE A1&quot;</FONT></B>, 0, 0xf8b,
	{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE A200&quot;</FONT></B>, 0, 0,
	{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE A2&quot;</FONT></B>, 0, 0xf8f,
	{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DiMAGE Z2&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DYNAX 5&quot;</FONT></B>, 0, 0xffb,
	{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Minolta DYNAX 7&quot;</FONT></B>, 0, 0xffb,
	{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Motorola PIXL&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D100&quot;</FONT></B>, 0, 0,
	{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D1H&quot;</FONT></B>, 0, 0,
	{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D1X&quot;</FONT></B>, 0, 0,
	{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D1&quot;</FONT></B>, 0, 0, <I><FONT COLOR="#B22222">/* multiplied by 2.218750, 1.0, 1.148438 */</FONT></I>
	{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D200&quot;</FONT></B>, 0, 0xfbc,
	{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D2H&quot;</FONT></B>, 0, 0,
	{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D2X&quot;</FONT></B>, 0, 0,
	{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3000&quot;</FONT></B>, 0, 0,
	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3100&quot;</FONT></B>, 0, 0,
	{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3200&quot;</FONT></B>, 0, 0xfb9,
	{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3300&quot;</FONT></B>, 0, 0,
	{ 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3400&quot;</FONT></B>, 0, 0,
	{ 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D300&quot;</FONT></B>, 0, 0,
	{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3X&quot;</FONT></B>, 0, 0,
	{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3S&quot;</FONT></B>, 0, 0,
	{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D3&quot;</FONT></B>, 0, 0,
	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D40X&quot;</FONT></B>, 0, 0,
	{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D40&quot;</FONT></B>, 0, 0,
	{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D4S&quot;</FONT></B>, 0, 0,
	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D4&quot;</FONT></B>, 0, 0,
	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon Df&quot;</FONT></B>, 0, 0,
	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5000&quot;</FONT></B>, 0, 0xf00,
	{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5100&quot;</FONT></B>, 0, 0x3de6,
	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5200&quot;</FONT></B>, 0, 0,
	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5300&quot;</FONT></B>, 0, 0,
	{ 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5500&quot;</FONT></B>, 0, 0,
	{ 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5600&quot;</FONT></B>, 0, 0,
	{ 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D500&quot;</FONT></B>, 0, 0,
	{ 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D50&quot;</FONT></B>, 0, 0,
	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D5&quot;</FONT></B>, 0, 0,
	{ 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D600&quot;</FONT></B>, 0, 0x3e07,
	{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D610&quot;</FONT></B>, 0, 0,
	{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D60&quot;</FONT></B>, 0, 0,
	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D7000&quot;</FONT></B>, 0, 0,
	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D7100&quot;</FONT></B>, 0, 0,
	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D7200&quot;</FONT></B>, 0, 0,
	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D7500&quot;</FONT></B>, 0, 0,
	{ 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D750&quot;</FONT></B>, 0, 0,
	{ 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D700&quot;</FONT></B>, 0, 0,
	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D70&quot;</FONT></B>, 0, 0,
	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D850&quot;</FONT></B>, 0, 0,
	{ 10405,-3755,-1270,-5461,13787,1793,-1040,2015,6785 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D810&quot;</FONT></B>, 0, 0,
	{ 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D800&quot;</FONT></B>, 0, 0,
	{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D80&quot;</FONT></B>, 0, 0,
	{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon D90&quot;</FONT></B>, 0, 0xf00,
	{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E700&quot;</FONT></B>, 0, 0x3dd,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E800&quot;</FONT></B>, 0, 0x3dd,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E950&quot;</FONT></B>, 0, 0x3dd,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E995&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* copied from E5000 */</FONT></I>
	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E2100&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* copied from Z2, new white balance */</FONT></I>
	{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E2500&quot;</FONT></B>, 0, 0,
	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E3200&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E4300&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* copied from Minolta DiMAGE Z2 */</FONT></I>
	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E4500&quot;</FONT></B>, 0, 0,
	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E5000&quot;</FONT></B>, 0, 0,
	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E5400&quot;</FONT></B>, 0, 0,
	{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E5700&quot;</FONT></B>, 0, 0,
	{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E8400&quot;</FONT></B>, 0, 0,
	{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E8700&quot;</FONT></B>, 0, 0,
	{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon E8800&quot;</FONT></B>, 0, 0,
	{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX A&quot;</FONT></B>, 0, 0,
	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX B700&quot;</FONT></B>, 200, 0,
	{ 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P330&quot;</FONT></B>, 200, 0,
	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P340&quot;</FONT></B>, 200, 0,
	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P6000&quot;</FONT></B>, 0, 0,
	{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P7000&quot;</FONT></B>, 0, 0,
	{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P7100&quot;</FONT></B>, 0, 0,
	{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P7700&quot;</FONT></B>, 200, 0,
	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon COOLPIX P7800&quot;</FONT></B>, 200, 0,
	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 V3&quot;</FONT></B>, 0, 0,
	{ 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 J4&quot;</FONT></B>, 0, 0,
	{ 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 J5&quot;</FONT></B>, 0, 0,
	{ 7520,-2518,-645,-3844,12102,1945,-913,2249,6835 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 S2&quot;</FONT></B>, 200, 0,
	{ 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 V2&quot;</FONT></B>, 0, 0,
	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 J3&quot;</FONT></B>, 0, 0,
	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 AW1&quot;</FONT></B>, 0, 0,
	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Nikon 1 &quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* J1, J2, S1, V1 */</FONT></I>
	{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus AIR A01&quot;</FONT></B>, 0, 0,
	{ 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus C5050&quot;</FONT></B>, 0, 0,
	{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus C5060&quot;</FONT></B>, 0, 0,
	{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus C7070&quot;</FONT></B>, 0, 0,
	{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus C70&quot;</FONT></B>, 0, 0,
	{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus C80&quot;</FONT></B>, 0, 0,
	{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-10&quot;</FONT></B>, 0, 0xffc,
	{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-1&quot;</FONT></B>, 0, 0,
	{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-20&quot;</FONT></B>, 0, 0xffc,
	{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-300&quot;</FONT></B>, 0, 0,
	{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-330&quot;</FONT></B>, 0, 0,
	{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-30&quot;</FONT></B>, 0, 0xfbc,
	{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-3&quot;</FONT></B>, 0, 0xf99,
	{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-400&quot;</FONT></B>, 0, 0,
	{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-410&quot;</FONT></B>, 0, 0xf6a,
	{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-420&quot;</FONT></B>, 0, 0xfd7,
	{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-450&quot;</FONT></B>, 0, 0xfd2,
	{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-500&quot;</FONT></B>, 0, 0,
	{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-510&quot;</FONT></B>, 0, 0xf6a,
	{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-520&quot;</FONT></B>, 0, 0xfd2,
	{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-5&quot;</FONT></B>, 0, 0xeec,
	{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-600&quot;</FONT></B>, 0, 0xfaf,
	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-620&quot;</FONT></B>, 0, 0xfaf,
	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-P1&quot;</FONT></B>, 0, 0xffd,
	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-P2&quot;</FONT></B>, 0, 0xffd,
	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-P3&quot;</FONT></B>, 0, 0,
	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-P5&quot;</FONT></B>, 0, 0,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL1s&quot;</FONT></B>, 0, 0,
	{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL1&quot;</FONT></B>, 0, 0,
	{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL2&quot;</FONT></B>, 0, 0xcf3,
	{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL3&quot;</FONT></B>, 0, 0,
	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL5&quot;</FONT></B>, 0, 0xfcb,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL6&quot;</FONT></B>, 0, 0,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL7&quot;</FONT></B>, 0, 0,
	{ 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL8&quot;</FONT></B>, 0, 0,
	{ 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PL9&quot;</FONT></B>, 0, 0,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PM1&quot;</FONT></B>, 0, 0,
	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-PM2&quot;</FONT></B>, 0, 0,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-M10&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also E-M10 Mark II &amp; III */</FONT></I>
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-M1Mark II&quot;</FONT></B>, 0, 0,
	{ 9383,-3170,-763,-2457,10702,2020,-384,1236,5552 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-M1&quot;</FONT></B>, 0, 0,
	{ 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-M5MarkII&quot;</FONT></B>, 0, 0,
	{ 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus E-M5&quot;</FONT></B>, 0, 0xfe1,
	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus PEN-F&quot;</FONT></B>, 0, 0,
	{ 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SH-2&quot;</FONT></B>, 0, 0,
	{ 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP350&quot;</FONT></B>, 0, 0,
	{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP3&quot;</FONT></B>, 0, 0,
	{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP500UZ&quot;</FONT></B>, 0, 0xfff,
	{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP510UZ&quot;</FONT></B>, 0, 0xffe,
	{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP550UZ&quot;</FONT></B>, 0, 0xffe,
	{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP560UZ&quot;</FONT></B>, 0, 0xff9,
	{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus SP570UZ&quot;</FONT></B>, 0, 0,
	{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus STYLUS1&quot;</FONT></B>, 0, 0,
	{ 8360,-2420,-880,-3928,12353,1739,-1381,2416,5173 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus TG-4&quot;</FONT></B>, 0, 0,
	{ 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus TG-5&quot;</FONT></B>, 0, 0,
	{ 10899,-3833,-1082,-2112,10736,1575,-267,1452,5269 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus XZ-10&quot;</FONT></B>, 0, 0,
	{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus XZ-1&quot;</FONT></B>, 0, 0,
	{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Olympus XZ-2&quot;</FONT></B>, 0, 0,
	{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
    { <B><FONT COLOR="#BC8F8F">&quot;OmniVision&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax *ist DL2&quot;</FONT></B>, 0, 0,
	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax *ist DL&quot;</FONT></B>, 0, 0,
	{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax *ist DS2&quot;</FONT></B>, 0, 0,
	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax *ist DS&quot;</FONT></B>, 0, 0,
	{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax *ist D&quot;</FONT></B>, 0, 0,
	{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K10D&quot;</FONT></B>, 0, 0,
	{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K1&quot;</FONT></B>, 0, 0,
	{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K20D&quot;</FONT></B>, 0, 0,
	{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K200D&quot;</FONT></B>, 0, 0,
	{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K2000&quot;</FONT></B>, 0, 0,
	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-m&quot;</FONT></B>, 0, 0,
	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-x&quot;</FONT></B>, 0, 0,
	{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-r&quot;</FONT></B>, 0, 0,
	{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-1&quot;</FONT></B>, 0, 0,
	{ 8596,-2981,-639,-4202,12046,2431,-685,1424,6122 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-30&quot;</FONT></B>, 0, 0,
	{ 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-3 II&quot;</FONT></B>, 0, 0,
	{ 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-3&quot;</FONT></B>, 0, 0,
	{ 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-5 II&quot;</FONT></B>, 0, 0,
	{ 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-5&quot;</FONT></B>, 0, 0,
	{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-70&quot;</FONT></B>, 0, 0,
	{ 8270,-2117,-1299,-4359,12953,1515,-1078,1933,5975 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-7&quot;</FONT></B>, 0, 0,
	{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-S1&quot;</FONT></B>, 0, 0,
	{ 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax K-S2&quot;</FONT></B>, 0, 0,
	{ 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax KP&quot;</FONT></B>, 0, 0,
	{ 8617,-3228,-1034,-4674,12821,2044,-803,1577,5728 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax Q-S1&quot;</FONT></B>, 0, 0,
	{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Pentax 645D&quot;</FONT></B>, 0, 0x3e00,
	{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-CM1&quot;</FONT></B>, 15, 0,
	{ 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-FZ80&quot;</FONT></B>, 0, 0,
	{ 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ8&quot;</FONT></B>, 0, 0xf7f,
	{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ18&quot;</FONT></B>, 0, 0,
	{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ28&quot;</FONT></B>, 15, 0xf96,
	{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ2500&quot;</FONT></B>, 15, 0,
	{ 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ330&quot;</FONT></B>, 15, 0,
	{ 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ300&quot;</FONT></B>, 15, 0,
	{ 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ30&quot;</FONT></B>, 0, 0xf94,
	{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ3&quot;</FONT></B>, 15, 0,	<I><FONT COLOR="#B22222">/* FZ35, FZ38 */</FONT></I>
	{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ4&quot;</FONT></B>, 15, 0,	<I><FONT COLOR="#B22222">/* FZ40, FZ45 */</FONT></I>
	{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ50&quot;</FONT></B>, 0, 0,
	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ7&quot;</FONT></B>, 15, 0,	<I><FONT COLOR="#B22222">/* FZ70, FZ72 */</FONT></I>
	{ 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica V-LUX1&quot;</FONT></B>, 0, 0,
	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-L10&quot;</FONT></B>, 15, 0xf96,
	{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-L1&quot;</FONT></B>, 0, 0xf7f,
	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica DIGILUX 3&quot;</FONT></B>, 0, 0xf7f,
	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LC1&quot;</FONT></B>, 0, 0,
	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica DIGILUX 2&quot;</FONT></B>, 0, 0,
	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX100&quot;</FONT></B>, 15, 0,
	{ 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX (Typ 109)&quot;</FONT></B>, 15, 0,
	{ 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LF1&quot;</FONT></B>, 15, 0,
	{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica C (Typ 112)&quot;</FONT></B>, 15, 0,
	{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX1&quot;</FONT></B>, 0, 0xf7f,
	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX2&quot;</FONT></B>, 0, 0xf7f,
	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX2&quot;</FONT></B>, 0, 0,
	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX3&quot;</FONT></B>, 0, 0,
	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX3&quot;</FONT></B>, 15, 0,
	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX 4&quot;</FONT></B>, 15, 0,
	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX5&quot;</FONT></B>, 15, 0,
	{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX 5&quot;</FONT></B>, 15, 0,
	{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX7&quot;</FONT></B>, 15, 0,
	{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica D-LUX 6&quot;</FONT></B>, 15, 0,
	{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-LX9&quot;</FONT></B>, 15, 0,
	{ 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ1000&quot;</FONT></B>, 15, 0,
	{ 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica V-LUX (Typ 114)&quot;</FONT></B>, 15, 0,
	{ 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ100&quot;</FONT></B>, 15, 0xfff,
	{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica V-LUX 2&quot;</FONT></B>, 15, 0xfff,
	{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ150&quot;</FONT></B>, 15, 0xfff,
	{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica V-LUX 3&quot;</FONT></B>, 15, 0xfff,
	{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FZ200&quot;</FONT></B>, 15, 0xfff,
	{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica V-LUX 4&quot;</FONT></B>, 15, 0xfff,
	{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-FX150&quot;</FONT></B>, 15, 0xfff,
	{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G10&quot;</FONT></B>, 0, 0,
	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G1&quot;</FONT></B>, 15, 0xf94,
	{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G2&quot;</FONT></B>, 15, 0xf3c,
	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G3&quot;</FONT></B>, 15, 0xfff,
	{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G5&quot;</FONT></B>, 15, 0xfff,
	{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G6&quot;</FONT></B>, 15, 0xfff,
	{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G7&quot;</FONT></B>, 15, 0xfff,
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-G8&quot;</FONT></B>, 15, 0xfff,	<I><FONT COLOR="#B22222">/* G8, G80, G81, G85 */</FONT></I>
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-G9&quot;</FONT></B>, 15, 0xfff,
	{ 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF1&quot;</FONT></B>, 15, 0xf92,
	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF2&quot;</FONT></B>, 15, 0xfff,
	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF3&quot;</FONT></B>, 15, 0xfff,
	{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF5&quot;</FONT></B>, 15, 0xfff,
	{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF6&quot;</FONT></B>, 15, 0,
	{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF7&quot;</FONT></B>, 15, 0,
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GF8&quot;</FONT></B>, 15, 0,
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-GF9&quot;</FONT></B>, 15, 0,
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GH1&quot;</FONT></B>, 15, 0xf92,
	{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GH2&quot;</FONT></B>, 15, 0xf95,
	{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GH3&quot;</FONT></B>, 15, 0,
	{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GH4&quot;</FONT></B>, 15, 0,
	{ 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-GH5S&quot;</FONT></B>, 15, 0,
	{ 6929,-2355,-708,-4192,12534,1828,-1097,1989,5195 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-GH5&quot;</FONT></B>, 15, 0,
	{ 7641,-2336,-605,-3218,11299,2187,-485,1338,5121 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GM1&quot;</FONT></B>, 15, 0,
	{ 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GM5&quot;</FONT></B>, 15, 0,
	{ 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GX1&quot;</FONT></B>, 15, 0,
	{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GX7&quot;</FONT></B>, 15, 0,
	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GX85&quot;</FONT></B>, 15, 0,
	{ 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-GX8&quot;</FONT></B>, 15, 0,
	{ 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-GX9&quot;</FONT></B>, 15, 0,
	{ 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-ZS100&quot;</FONT></B>, 15, 0,
	{ 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DC-ZS200&quot;</FONT></B>, 15, 0,
	{ 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-ZS40&quot;</FONT></B>, 15, 0,
	{ 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-ZS50&quot;</FONT></B>, 15, 0,
	{ 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-TZ82&quot;</FONT></B>, 15, 0,
	{ 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-ZS6&quot;</FONT></B>, 15, 0,
	{ 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Panasonic DMC-ZS70&quot;</FONT></B>, 15, 0,
	{ 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica S (Typ 007)&quot;</FONT></B>, 0, 0,
	{ 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica X&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* X and X-U, both (Typ 113) */</FONT></I>
	{ 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica Q (Typ 116)&quot;</FONT></B>, 0, 0,
	{ 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica M (Typ 262)&quot;</FONT></B>, 0, 0,
	{ 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica SL (Typ 601)&quot;</FONT></B>, 0, 0,
	{ 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica TL2&quot;</FONT></B>, 0, 0,
	{ 5836,-1626,-647,-5384,13326,2261,-1207,2129,5861 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica TL&quot;</FONT></B>, 0, 0,
	{ 5463,-988,-364,-4634,12036,2946,-766,1389,6522 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica CL&quot;</FONT></B>, 0, 0,
	{ 7414,-2393,-840,-5127,13180,2138,-1585,2468,5064 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Leica M10&quot;</FONT></B>, 0, 0,
	{ 8249,-2849,-620,-5415,14756,565,-957,3074,6517 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One H 20&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One H 25&quot;</FONT></B>, 0, 0,
	{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One P 2&quot;</FONT></B>, 0, 0,
	{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One P 30&quot;</FONT></B>, 0, 0,
	{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One P 45&quot;</FONT></B>, 0, 0,
	{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One P40&quot;</FONT></B>, 0, 0,
	{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Phase One P65&quot;</FONT></B>, 0, 0,
	{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Photron BC2-HD&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Red One&quot;</FONT></B>, 704, 0xffff,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Ricoh GR II&quot;</FONT></B>, 0, 0,
	{ 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Ricoh GR&quot;</FONT></B>, 0, 0,
	{ 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung EX1&quot;</FONT></B>, 0, 0x3e00,
	{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung EX2F&quot;</FONT></B>, 0, 0x7ff,
	{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung EK-GN120&quot;</FONT></B>, 0, 0,
	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX mini&quot;</FONT></B>, 0, 0,
	{ 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX3300&quot;</FONT></B>, 0, 0,
	{ 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX3000&quot;</FONT></B>, 0, 0,
	{ 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX30&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* NX30, NX300, NX300M */</FONT></I>
	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX2000&quot;</FONT></B>, 0, 0,
	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX2&quot;</FONT></B>, 0, 0xfff,	<I><FONT COLOR="#B22222">/* NX20, NX200, NX210 */</FONT></I>
	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX1000&quot;</FONT></B>, 0, 0,
	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX1100&quot;</FONT></B>, 0, 0,
	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX11&quot;</FONT></B>, 0, 0,
	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX10&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also NX100 */</FONT></I>
	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX500&quot;</FONT></B>, 0, 0,
	{ 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX5&quot;</FONT></B>, 0, 0,
	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung NX1&quot;</FONT></B>, 0, 0,
	{ 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung WB2000&quot;</FONT></B>, 0, 0xfff,
	{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung GX-1&quot;</FONT></B>, 0, 0,
	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung GX20&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* copied from Pentax K20D */</FONT></I>
	{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Samsung S85&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>, 0, 0,			<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-F828&quot;</FONT></B>, 0, 0,
	{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-R1&quot;</FONT></B>, 0, 0,
	{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-V3&quot;</FONT></B>, 0, 0,
	{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX100M&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* M2, M3, M4, and M5 */</FONT></I>
	{ 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX100&quot;</FONT></B>, 0, 0,
	{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX10M4&quot;</FONT></B>, 0, 0,
	{ 7699,-2566,-629,-2967,11270,1928,-378,1286,4807 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX10&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* also RX10M2, RX10M3 */</FONT></I>
	{ 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX1RM2&quot;</FONT></B>, 0, 0,
	{ 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX1&quot;</FONT></B>, 0, 0,
	{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSC-RX0&quot;</FONT></B>, 200, 0,
	{ 9396,-3507,-843,-2497,11111,1572,-343,1355,5089 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A100&quot;</FONT></B>, 0, 0xfeb,
	{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A290&quot;</FONT></B>, 0, 0,
	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A2&quot;</FONT></B>, 0, 0,
	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A300&quot;</FONT></B>, 0, 0,
	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A330&quot;</FONT></B>, 0, 0,
	{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A350&quot;</FONT></B>, 0, 0xffc,
	{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A380&quot;</FONT></B>, 0, 0,
	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A390&quot;</FONT></B>, 0, 0,
	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A450&quot;</FONT></B>, 0, 0xfeb,
	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A580&quot;</FONT></B>, 0, 0xfeb,
	{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A500&quot;</FONT></B>, 0, 0xfeb,
	{ 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A5&quot;</FONT></B>, 0, 0xfeb,
	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A700&quot;</FONT></B>, 0, 0,
	{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A850&quot;</FONT></B>, 0, 0,
	{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony DSLR-A900&quot;</FONT></B>, 0, 0,
	{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCA-68&quot;</FONT></B>, 0, 0,
	{ 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCA-77M2&quot;</FONT></B>, 0, 0,
	{ 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCA-99M2&quot;</FONT></B>, 0, 0,
	{ 6660,-1918,-471,-4613,12398,2485,-649,1433,6447 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-6&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* 6300, 6500 */</FONT></I>
	{ 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7M2&quot;</FONT></B>, 0, 0,
	{ 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7M3&quot;</FONT></B>, 0, 0,
	{ 7374,-2389,-551,-5435,13162,2519,-1006,1795,6552 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7S&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* also ILCE-7SM2 */</FONT></I>
	{ 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7RM3&quot;</FONT></B>, 0, 0,
	{ 6640,-1847,-503,-5238,13010,2474,-993,1673,6527 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7RM2&quot;</FONT></B>, 0, 0,
	{ 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7R&quot;</FONT></B>, 0, 0,
	{ 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-7&quot;</FONT></B>, 0, 0,
	{ 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE-9&quot;</FONT></B>, 0, 0,
	{ 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony ILCE&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* 3000, 5000, 5100, 6000, and QX1 */</FONT></I>
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-5N&quot;</FONT></B>, 0, 0,
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-5R&quot;</FONT></B>, 0, 0,
	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-5T&quot;</FONT></B>, 0, 0,
	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-3N&quot;</FONT></B>, 0, 0,
	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-3&quot;</FONT></B>, 138, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 6907,-1256,-645,-4940,12621,2320,-1710,2581,6230 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-5&quot;</FONT></B>, 116, 0,		<I><FONT COLOR="#B22222">/* DJC */</FONT></I>
	{ 6807,-1350,-342,-4216,11649,2567,-1089,2001,6420 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-3&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* Adobe */</FONT></I>
	{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-5&quot;</FONT></B>, 0, 0,		<I><FONT COLOR="#B22222">/* Adobe */</FONT></I>
	{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-6&quot;</FONT></B>, 0, 0,
	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX-7&quot;</FONT></B>, 0, 0,
	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony NEX&quot;</FONT></B>, 0, 0,	<I><FONT COLOR="#B22222">/* NEX-C3, NEX-F3 */</FONT></I>
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A33&quot;</FONT></B>, 0, 0,
	{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A35&quot;</FONT></B>, 0, 0,
	{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A37&quot;</FONT></B>, 0, 0,
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A55&quot;</FONT></B>, 0, 0,
	{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A57&quot;</FONT></B>, 0, 0,
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A58&quot;</FONT></B>, 0, 0,
	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A65&quot;</FONT></B>, 0, 0,
	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A77&quot;</FONT></B>, 0, 0,
	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
    { <B><FONT COLOR="#BC8F8F">&quot;Sony SLT-A99&quot;</FONT></B>, 0, 0,
	{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
    { <B><FONT COLOR="#BC8F8F">&quot;YI M1&quot;</FONT></B>, 0, 0,
	{ 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },
  };
  <B><FONT COLOR="#228B22">double</FONT></B> cam_xyz[4][3];
  <B><FONT COLOR="#228B22">char</FONT></B> name[130];
  <B><FONT COLOR="#228B22">int</FONT></B> i, j;

  sprintf (name, <B><FONT COLOR="#BC8F8F">&quot;%s %s&quot;</FONT></B>, make, model);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> table / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *table; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (table[i].black)   black   = (ushort) table[i].black;
      <B><FONT COLOR="#A020F0">if</FONT></B> (table[i].maximum) maximum = (ushort) table[i].maximum;
      <B><FONT COLOR="#A020F0">if</FONT></B> (table[i].trans[0]) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = j=0; j &lt; 12; j++)
	  ((<B><FONT COLOR="#228B22">double</FONT></B> *)cam_xyz)[j] = table[i].trans[j] / 10000.0;
	cam_xyz_coeff (rgb_cam, cam_xyz);
      }
      <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">simple_coeff</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> index)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">float</FONT></B> table[][12] = {
  <I><FONT COLOR="#B22222">/* index 0 -- all Foveon cameras */</FONT></I>
  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },
  <I><FONT COLOR="#B22222">/* index 1 -- Kodak DC20 and DC25 */</FONT></I>
  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },
  <I><FONT COLOR="#B22222">/* index 2 -- Logitech Fotoman Pixtura */</FONT></I>
  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },
  <I><FONT COLOR="#B22222">/* index 3 -- Nikon E880, E900, and E990 */</FONT></I>
  { -1.936280,  1.800443, -1.448486,  2.584324,
     1.405365, -0.524955, -0.289090,  0.408680,
    -1.204965,  1.082304,  2.941367, -1.818705 }
  };
  <B><FONT COLOR="#228B22">int</FONT></B> i, c;

  <B><FONT COLOR="#A020F0">for</FONT></B> (raw_color = i=0; i &lt; 3; i++)
    FORCC rgb_cam[i][c] = table[index][i*colors+c];
}

<B><FONT COLOR="#228B22">short</FONT></B> CLASS <B><FONT COLOR="#0000FF">guess_byte_order</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> words)
{
  uchar test[4][2];
  <B><FONT COLOR="#228B22">int</FONT></B> t=2, msb;
  <B><FONT COLOR="#228B22">double</FONT></B> diff, sum[2] = {0,0};

  fread (test[0], 2, 2, ifp);
  <B><FONT COLOR="#A020F0">for</FONT></B> (words-=2; words--; ) {
    fread (test[t], 2, 1, ifp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (msb=0; msb &lt; 2; msb++) {
      diff = (test[t^2][msb] &lt;&lt; 8 | test[t^2][!msb])
	   - (test[t  ][msb] &lt;&lt; 8 | test[t  ][!msb]);
      sum[msb] += diff*diff;
    }
    t = (t+1) &amp; 3;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> sum[0] &lt; sum[1] ? 0x4d4d : 0x4949;
}

<B><FONT COLOR="#228B22">float</FONT></B> CLASS <B><FONT COLOR="#0000FF">find_green</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> bps, <B><FONT COLOR="#228B22">int</FONT></B> bite, <B><FONT COLOR="#228B22">int</FONT></B> off0, <B><FONT COLOR="#228B22">int</FONT></B> off1)
{
  UINT64 bitbuf=0;
  <B><FONT COLOR="#228B22">int</FONT></B> vbits, col, i, c;
  ushort img[2][2064];
  <B><FONT COLOR="#228B22">double</FONT></B> sum[]={0,0};

  FORC(2) {
    fseek (ifp, c ? off1:off0, SEEK_SET);
    <B><FONT COLOR="#A020F0">for</FONT></B> (vbits=col=0; col &lt; width; col++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (vbits -= bps; vbits &lt; 0; vbits += bite) {
	bitbuf &lt;&lt;= bite;
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; bite; i+=8)
	  bitbuf |= (<B><FONT COLOR="#228B22">unsigned</FONT></B>) (fgetc(ifp) &lt;&lt; i);
      }
      img[c][col] = bitbuf &lt;&lt; (64-bps-vbits) &gt;&gt; (64-bps);
    }
  }
  FORC(width-1) {
    sum[ c &amp; 1] += ABS(img[0][c]-img[1][c+1]);
    sum[~c &amp; 1] += ABS(img[1][c]-img[0][c+1]);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 100 * log(sum[0]/sum[1]);
}

<I><FONT COLOR="#B22222">/*
   Identify which camera created this file, and set global variables
   accordingly.
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">identify</FONT></B>()
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> pana[][6] = {
    { 3130, 1743,  4,  0, -6,  0 },
    { 3130, 2055,  4,  0, -6,  0 },
    { 3130, 2319,  4,  0, -6,  0 },
    { 3170, 2103, 18,  0,-42, 20 },
    { 3170, 2367, 18, 13,-42,-21 },
    { 3177, 2367,  0,  0, -1,  0 },
    { 3304, 2458,  0,  0, -1,  0 },
    { 3330, 2463,  9,  0, -5,  0 },
    { 3330, 2479,  9,  0,-17,  4 },
    { 3370, 1899, 15,  0,-44, 20 },
    { 3370, 2235, 15,  0,-44, 20 },
    { 3370, 2511, 15, 10,-44,-21 },
    { 3690, 2751,  3,  0, -8, -3 },
    { 3710, 2751,  0,  0, -3,  0 },
    { 3724, 2450,  0,  0,  0, -2 },
    { 3770, 2487, 17,  0,-44, 19 },
    { 3770, 2799, 17, 15,-44,-19 },
    { 3880, 2170,  6,  0, -6,  0 },
    { 4060, 3018,  0,  0,  0, -2 },
    { 4290, 2391,  3,  0, -8, -1 },
    { 4330, 2439, 17, 15,-44,-19 },
    { 4508, 2962,  0,  0, -3, -4 },
    { 4508, 3330,  0,  0, -3, -6 },
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> ushort canon[][11] = {
    { 1944, 1416,   0,  0, 48,  0 },
    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },
    { 2224, 1456,  48,  6,  0,  2 },
    { 2376, 1728,  12,  6, 52,  2 },
    { 2672, 1968,  12,  6, 44,  2 },
    { 3152, 2068,  64, 12,  0,  0, 16 },
    { 3160, 2344,  44, 12,  4,  4 },
    { 3344, 2484,   4,  6, 52,  6 },
    { 3516, 2328,  42, 14,  0,  0 },
    { 3596, 2360,  74, 12,  0,  0 },
    { 3744, 2784,  52, 12,  8, 12 },
    { 3944, 2622,  30, 18,  6,  2 },
    { 3948, 2622,  42, 18,  0,  2 },
    { 3984, 2622,  76, 20,  0,  2, 14 },
    { 4104, 3048,  48, 12, 24, 12 },
    { 4116, 2178,   4,  2,  0,  0 },
    { 4152, 2772, 192, 12,  0,  0 },
    { 4160, 3124, 104, 11,  8, 65 },
    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },
    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },
    { 4312, 2876,  22, 18,  0,  2 },
    { 4352, 2874,  62, 18,  0,  0 },
    { 4476, 2954,  90, 34,  0,  0 },
    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },
    { 4480, 3366,  80, 50,  0,  0 },
    { 4496, 3366,  80, 50, 12,  0 },
    { 4768, 3516,  96, 16,  0,  0, 0, 16 },
    { 4832, 3204,  62, 26,  0,  0 },
    { 4832, 3228,  62, 51,  0,  0 },
    { 5108, 3349,  98, 13,  0,  0 },
    { 5120, 3318, 142, 45, 62,  0 },
    { 5280, 3528,  72, 52,  0,  0 },
    { 5344, 3516, 142, 51,  0,  0 },
    { 5344, 3584, 126,100,  0,  2 },
    { 5360, 3516, 158, 51,  0,  0 },
    { 5568, 3708,  72, 38,  0,  0 },
    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },
    { 5712, 3774,  62, 20, 10,  2 },
    { 5792, 3804, 158, 51,  0,  0 },
    { 5920, 3950, 122, 80,  2,  0 },
    { 6096, 4051,  76, 35,  0,  0 },
    { 6096, 4056,  72, 34,  0,  0 },
    { 6288, 4056, 264, 36,  0,  0 },
    { 6384, 4224, 120, 44,  0,  0 },
    { 6880, 4544, 136, 42,  0,  0 },
    { 8896, 5920, 160, 64,  0,  0 },
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> {
    ushort id;
    <B><FONT COLOR="#228B22">char</FONT></B> model[20];
  } unique[] = {
    { 0x168, <B><FONT COLOR="#BC8F8F">&quot;EOS 10D&quot;</FONT></B> },    { 0x001, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D&quot;</FONT></B> },
    { 0x175, <B><FONT COLOR="#BC8F8F">&quot;EOS 20D&quot;</FONT></B> },    { 0x174, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D Mark II&quot;</FONT></B> },
    { 0x234, <B><FONT COLOR="#BC8F8F">&quot;EOS 30D&quot;</FONT></B> },    { 0x232, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D Mark II N&quot;</FONT></B> },
    { 0x190, <B><FONT COLOR="#BC8F8F">&quot;EOS 40D&quot;</FONT></B> },    { 0x169, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D Mark III&quot;</FONT></B> },
    { 0x261, <B><FONT COLOR="#BC8F8F">&quot;EOS 50D&quot;</FONT></B> },    { 0x281, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D Mark IV&quot;</FONT></B> },
    { 0x287, <B><FONT COLOR="#BC8F8F">&quot;EOS 60D&quot;</FONT></B> },    { 0x167, <B><FONT COLOR="#BC8F8F">&quot;EOS-1DS&quot;</FONT></B> },
    { 0x325, <B><FONT COLOR="#BC8F8F">&quot;EOS 70D&quot;</FONT></B> },
    { 0x408, <B><FONT COLOR="#BC8F8F">&quot;EOS 77D&quot;</FONT></B> },    { 0x331, <B><FONT COLOR="#BC8F8F">&quot;EOS M&quot;</FONT></B> },
    { 0x350, <B><FONT COLOR="#BC8F8F">&quot;EOS 80D&quot;</FONT></B> },    { 0x328, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D X Mark II&quot;</FONT></B> },
    { 0x346, <B><FONT COLOR="#BC8F8F">&quot;EOS 100D&quot;</FONT></B> },
    { 0x417, <B><FONT COLOR="#BC8F8F">&quot;EOS 200D&quot;</FONT></B> },
    { 0x170, <B><FONT COLOR="#BC8F8F">&quot;EOS 300D&quot;</FONT></B> },   { 0x188, <B><FONT COLOR="#BC8F8F">&quot;EOS-1Ds Mark II&quot;</FONT></B> },
    { 0x176, <B><FONT COLOR="#BC8F8F">&quot;EOS 450D&quot;</FONT></B> },   { 0x215, <B><FONT COLOR="#BC8F8F">&quot;EOS-1Ds Mark III&quot;</FONT></B> },
    { 0x189, <B><FONT COLOR="#BC8F8F">&quot;EOS 350D&quot;</FONT></B> },   { 0x324, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D C&quot;</FONT></B> },
    { 0x236, <B><FONT COLOR="#BC8F8F">&quot;EOS 400D&quot;</FONT></B> },   { 0x269, <B><FONT COLOR="#BC8F8F">&quot;EOS-1D X&quot;</FONT></B> },
    { 0x252, <B><FONT COLOR="#BC8F8F">&quot;EOS 500D&quot;</FONT></B> },   { 0x213, <B><FONT COLOR="#BC8F8F">&quot;EOS 5D&quot;</FONT></B> },
    { 0x270, <B><FONT COLOR="#BC8F8F">&quot;EOS 550D&quot;</FONT></B> },   { 0x218, <B><FONT COLOR="#BC8F8F">&quot;EOS 5D Mark II&quot;</FONT></B> },
    { 0x286, <B><FONT COLOR="#BC8F8F">&quot;EOS 600D&quot;</FONT></B> },   { 0x285, <B><FONT COLOR="#BC8F8F">&quot;EOS 5D Mark III&quot;</FONT></B> },
    { 0x301, <B><FONT COLOR="#BC8F8F">&quot;EOS 650D&quot;</FONT></B> },   { 0x302, <B><FONT COLOR="#BC8F8F">&quot;EOS 6D&quot;</FONT></B> },
    { 0x326, <B><FONT COLOR="#BC8F8F">&quot;EOS 700D&quot;</FONT></B> },   { 0x250, <B><FONT COLOR="#BC8F8F">&quot;EOS 7D&quot;</FONT></B> },
    { 0x393, <B><FONT COLOR="#BC8F8F">&quot;EOS 750D&quot;</FONT></B> },   { 0x289, <B><FONT COLOR="#BC8F8F">&quot;EOS 7D Mark II&quot;</FONT></B> },
    { 0x347, <B><FONT COLOR="#BC8F8F">&quot;EOS 760D&quot;</FONT></B> },   { 0x406, <B><FONT COLOR="#BC8F8F">&quot;EOS 6D Mark II&quot;</FONT></B> },
    { 0x405, <B><FONT COLOR="#BC8F8F">&quot;EOS 800D&quot;</FONT></B> },   { 0x349, <B><FONT COLOR="#BC8F8F">&quot;EOS 5D Mark IV&quot;</FONT></B> },
    { 0x254, <B><FONT COLOR="#BC8F8F">&quot;EOS 1000D&quot;</FONT></B> },
    { 0x288, <B><FONT COLOR="#BC8F8F">&quot;EOS 1100D&quot;</FONT></B> },
    { 0x327, <B><FONT COLOR="#BC8F8F">&quot;EOS 1200D&quot;</FONT></B> },  { 0x382, <B><FONT COLOR="#BC8F8F">&quot;EOS 5DS&quot;</FONT></B> },
    { 0x404, <B><FONT COLOR="#BC8F8F">&quot;EOS 1300D&quot;</FONT></B> },  { 0x401, <B><FONT COLOR="#BC8F8F">&quot;EOS 5DS R&quot;</FONT></B> },
    { 0x422, <B><FONT COLOR="#BC8F8F">&quot;EOS 1500D&quot;</FONT></B> },
    { 0x432, <B><FONT COLOR="#BC8F8F">&quot;EOS 3000D&quot;</FONT></B> },
  }, sonique[] = {
    { 0x002, <B><FONT COLOR="#BC8F8F">&quot;DSC-R1&quot;</FONT></B> },     { 0x100, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A100&quot;</FONT></B> },
    { 0x101, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A900&quot;</FONT></B> },  { 0x102, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A700&quot;</FONT></B> },
    { 0x103, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A200&quot;</FONT></B> },  { 0x104, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A350&quot;</FONT></B> },
    { 0x105, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A300&quot;</FONT></B> },  { 0x108, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A330&quot;</FONT></B> },
    { 0x109, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A230&quot;</FONT></B> },  { 0x10a, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A290&quot;</FONT></B> },
    { 0x10d, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A850&quot;</FONT></B> },  { 0x111, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A550&quot;</FONT></B> },
    { 0x112, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A500&quot;</FONT></B> },  { 0x113, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A450&quot;</FONT></B> },
    { 0x116, <B><FONT COLOR="#BC8F8F">&quot;NEX-5&quot;</FONT></B> },      { 0x117, <B><FONT COLOR="#BC8F8F">&quot;NEX-3&quot;</FONT></B> },
    { 0x118, <B><FONT COLOR="#BC8F8F">&quot;SLT-A33&quot;</FONT></B> },    { 0x119, <B><FONT COLOR="#BC8F8F">&quot;SLT-A55V&quot;</FONT></B> },
    { 0x11a, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A560&quot;</FONT></B> },  { 0x11b, <B><FONT COLOR="#BC8F8F">&quot;DSLR-A580&quot;</FONT></B> },
    { 0x11c, <B><FONT COLOR="#BC8F8F">&quot;NEX-C3&quot;</FONT></B> },     { 0x11d, <B><FONT COLOR="#BC8F8F">&quot;SLT-A35&quot;</FONT></B> },
    { 0x11e, <B><FONT COLOR="#BC8F8F">&quot;SLT-A65V&quot;</FONT></B> },   { 0x11f, <B><FONT COLOR="#BC8F8F">&quot;SLT-A77V&quot;</FONT></B> },
    { 0x120, <B><FONT COLOR="#BC8F8F">&quot;NEX-5N&quot;</FONT></B> },     { 0x121, <B><FONT COLOR="#BC8F8F">&quot;NEX-7&quot;</FONT></B> },
    { 0x123, <B><FONT COLOR="#BC8F8F">&quot;SLT-A37&quot;</FONT></B> },    { 0x124, <B><FONT COLOR="#BC8F8F">&quot;SLT-A57&quot;</FONT></B> },
    { 0x125, <B><FONT COLOR="#BC8F8F">&quot;NEX-F3&quot;</FONT></B> },     { 0x126, <B><FONT COLOR="#BC8F8F">&quot;SLT-A99V&quot;</FONT></B> },
    { 0x127, <B><FONT COLOR="#BC8F8F">&quot;NEX-6&quot;</FONT></B> },      { 0x128, <B><FONT COLOR="#BC8F8F">&quot;NEX-5R&quot;</FONT></B> },
    { 0x129, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX100&quot;</FONT></B> },  { 0x12a, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX1&quot;</FONT></B> },
    { 0x12e, <B><FONT COLOR="#BC8F8F">&quot;ILCE-3000&quot;</FONT></B> },  { 0x12f, <B><FONT COLOR="#BC8F8F">&quot;SLT-A58&quot;</FONT></B> },
    { 0x131, <B><FONT COLOR="#BC8F8F">&quot;NEX-3N&quot;</FONT></B> },     { 0x132, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7&quot;</FONT></B> },
    { 0x133, <B><FONT COLOR="#BC8F8F">&quot;NEX-5T&quot;</FONT></B> },     { 0x134, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX100M2&quot;</FONT></B> },
    { 0x135, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX10&quot;</FONT></B> },   { 0x136, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX1R&quot;</FONT></B> },
    { 0x137, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7R&quot;</FONT></B> },    { 0x138, <B><FONT COLOR="#BC8F8F">&quot;ILCE-6000&quot;</FONT></B> },
    { 0x139, <B><FONT COLOR="#BC8F8F">&quot;ILCE-5000&quot;</FONT></B> },  { 0x13d, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX100M3&quot;</FONT></B> },
    { 0x13e, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7S&quot;</FONT></B> },    { 0x13f, <B><FONT COLOR="#BC8F8F">&quot;ILCA-77M2&quot;</FONT></B> },
    { 0x153, <B><FONT COLOR="#BC8F8F">&quot;ILCE-5100&quot;</FONT></B> },  { 0x154, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7M2&quot;</FONT></B> },
    { 0x155, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX100M4&quot;</FONT></B> },{ 0x156, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX10M2&quot;</FONT></B> },
    { 0x158, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX1RM2&quot;</FONT></B> }, { 0x15a, <B><FONT COLOR="#BC8F8F">&quot;ILCE-QX1&quot;</FONT></B> },
    { 0x15b, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7RM2&quot;</FONT></B> },  { 0x15e, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7SM2&quot;</FONT></B> },
    { 0x161, <B><FONT COLOR="#BC8F8F">&quot;ILCA-68&quot;</FONT></B> },    { 0x162, <B><FONT COLOR="#BC8F8F">&quot;ILCA-99M2&quot;</FONT></B> },
    { 0x163, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX10M3&quot;</FONT></B> }, { 0x164, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX100M5&quot;</FONT></B> },
    { 0x165, <B><FONT COLOR="#BC8F8F">&quot;ILCE-6300&quot;</FONT></B> },  { 0x166, <B><FONT COLOR="#BC8F8F">&quot;ILCE-9&quot;</FONT></B> },
    { 0x168, <B><FONT COLOR="#BC8F8F">&quot;ILCE-6500&quot;</FONT></B> },  { 0x16a, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7RM3&quot;</FONT></B> },
    { 0x16b, <B><FONT COLOR="#BC8F8F">&quot;ILCE-7M3&quot;</FONT></B> },   { 0x16c, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX0&quot;</FONT></B> },
    { 0x16d, <B><FONT COLOR="#BC8F8F">&quot;DSC-RX10M4&quot;</FONT></B> },
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *orig, panalias[][12] = {
    <B><FONT COLOR="#BC8F8F">&quot;@DC-FZ80&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-FZ82&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-FZ85&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-FZ81&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-FZ83&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-GF9&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-GX800&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-GX850&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-GF10&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-GF90&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-GX9&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-GX7MK3&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-ZS70&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ90&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ91&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ92&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ93&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-FZ40&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-FZ45&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-FZ2500&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-FZ2000&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-FZH1&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-G8&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-G80&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-G81&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-G85&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-GX85&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-GX80&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-GX7MK2&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-LX9&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-LX10&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-LX15&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-ZS40&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ60&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ61&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-ZS50&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ70&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ71&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-ZS60&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ80&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ81&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ85&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DMC-ZS100&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-ZS110&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ100&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ101&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TZ110&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DMC-TX1&quot;</FONT></B>,
    <B><FONT COLOR="#BC8F8F">&quot;@DC-ZS200&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TX2&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ200&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ202&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-TZ220&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;DC-ZS220&quot;</FONT></B>,
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> {
    <B><FONT COLOR="#228B22">unsigned</FONT></B> fsize;
    ushort rw, rh;
    uchar lm, tm, rm, bm, lf, cf, max, flags;
    <B><FONT COLOR="#228B22">char</FONT></B> make[10], model[20];
    ushort offset;
  } table[] = {
    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-080C&quot;</FONT></B> },
    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-145C&quot;</FONT></B> },
    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-201C&quot;</FONT></B> },
    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-510C&quot;</FONT></B> },
    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-510C&quot;</FONT></B>,12 },
    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-510C&quot;</FONT></B> },
    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-510C&quot;</FONT></B>,12 },
    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;AVT&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;F-810C&quot;</FONT></B> },
    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,<B><FONT COLOR="#BC8F8F">&quot;AgfaPhoto&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;DC-833m&quot;</FONT></B> },
    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Alcatel&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;5035D&quot;</FONT></B> },
    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,<B><FONT COLOR="#BC8F8F">&quot;Baumer&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;TXG14&quot;</FONT></B>,1078 },
    {  5298000,2400,1766,12,12,44, 2, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SD300&quot;</FONT></B> },
    {  6553440,2664,1968, 4, 4,44, 4, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A460&quot;</FONT></B> },
    {  6573120,2672,1968,12, 8,44, 0, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A610&quot;</FONT></B> },
    {  6653280,2672,1992,10, 6,42, 2, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A530&quot;</FONT></B> },
    {  7710960,2888,2136,44, 8, 4, 0, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot S3 IS&quot;</FONT></B> },
    {  9219600,3152,2340,36,12, 4, 0, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A620&quot;</FONT></B> },
    {  9243240,3152,2346,12, 7,44,13, 8,0x49,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A470&quot;</FONT></B> },
    { 10341600,3336,2480, 6, 5,32, 3, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A720 IS&quot;</FONT></B> },
    { 10383120,3344,2484,12, 6,44, 6, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A630&quot;</FONT></B> },
    { 12945240,3736,2772,12, 6,52, 6, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A640&quot;</FONT></B> },
    { 15636240,4104,3048,48,12,24,12, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A650&quot;</FONT></B> },
    { 15467760,3720,2772, 6,12,30, 0, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX110 IS&quot;</FONT></B> },
    { 15534576,3728,2778,12, 9,44, 9, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX120 IS&quot;</FONT></B> },
    { 18653760,4080,3048,24,12,24,12, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX20 IS&quot;</FONT></B> },
    { 19131120,4168,3060,92,16, 4, 1, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX220 HS&quot;</FONT></B> },
    { 21936096,4464,3276,25,10,73,12, 8,0x16,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX30 IS&quot;</FONT></B> },
    { 24724224,4704,3504, 8,16,56, 8, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A3300 IS&quot;</FONT></B> },
    { 30858240,5248,3920, 8,16,56,16, 8,0x94,0,2,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;IXUS 160&quot;</FONT></B> },
    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-2000UX&quot;</FONT></B> },
    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-3*00EX&quot;</FONT></B> },
    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-5700&quot;</FONT></B> },
    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z60&quot;</FONT></B> },
    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-S20&quot;</FONT></B> },
    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-S100&quot;</FONT></B> },
    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-R41&quot;</FONT></B> },
    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-P505&quot;</FONT></B> },
    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-R51&quot;</FONT></B> },
    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z50&quot;</FONT></B> },
    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z500&quot;</FONT></B> },
    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z55&quot;</FONT></B> },
    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-P600&quot;</FONT></B> },
    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z750&quot;</FONT></B> },
    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z75&quot;</FONT></B> },
    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-P700&quot;</FONT></B> },
    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z850&quot;</FONT></B> },
    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z8&quot;</FONT></B> },
    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-Z1050&quot;</FONT></B> },
    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;EX-ZR100&quot;</FONT></B> },
    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;QV-4000&quot;</FONT></B> },
    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Creative&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;PC-CAM 600&quot;</FONT></B> },
    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;DJI&quot;</FONT></B> },
    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Matrix&quot;</FONT></B> },
    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Foculus&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;531C&quot;</FONT></B> },
    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Generic&quot;</FONT></B> },
    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;DC20&quot;</FONT></B> },
    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;DC20&quot;</FONT></B> },
    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;DCS200&quot;</FONT></B> },
    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B> },
    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B>,3160 },
    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B> },
    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B> },
    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B> },
    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B>,3160 },
    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B> },
    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B> },
    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;12MP&quot;</FONT></B> },
    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;12MP&quot;</FONT></B>,31556 },
    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;12MP&quot;</FONT></B> },
    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;KAI-0340&quot;</FONT></B> },
    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,<B><FONT COLOR="#BC8F8F">&quot;Lenovo&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;A820&quot;</FONT></B> },
    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,<B><FONT COLOR="#BC8F8F">&quot;Micron&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;2010&quot;</FONT></B>,3212 },
    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Minolta&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;RD175&quot;</FONT></B>,513 },
    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E900&quot;</FONT></B> },
    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E950&quot;</FONT></B> },
    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E2100&quot;</FONT></B> },
    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E990&quot;</FONT></B> },
    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E3700&quot;</FONT></B> },
    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E4500&quot;</FONT></B> },
    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E4300&quot;</FONT></B> },
    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;E5000&quot;</FONT></B> },
    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;COOLPIX S6&quot;</FONT></B> },
    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,<B><FONT COLOR="#BC8F8F">&quot;Olympus&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;C770UZ&quot;</FONT></B> },
    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Optio S&quot;</FONT></B> },
    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Optio S&quot;</FONT></B> },
    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,<B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Optio S4&quot;</FONT></B> },
    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Optio 750Z&quot;</FONT></B> },
    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Photron&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;BC2-HD&quot;</FONT></B> },
    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Photron&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;BC2-HD&quot;</FONT></B>,8 },
    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Pixelink&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;A782&quot;</FONT></B> },
    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;RoverShot&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;3320AF&quot;</FONT></B> },
    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,<B><FONT COLOR="#BC8F8F">&quot;ST Micro&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;STV680 VGA&quot;</FONT></B> },
    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;S85&quot;</FONT></B> },
    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;S85&quot;</FONT></B> },
    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;WB550&quot;</FONT></B> },
    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;WB550&quot;</FONT></B> },
    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,68 },
    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,68 },
    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,<B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,68 },
    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;XCD-SX910CR&quot;</FONT></B> },
    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;XCD-SX910CR&quot;</FONT></B> },
    { 17496000,4320,3240, 0, 0, 0,0,224,0x94,0,0,<B><FONT COLOR="#BC8F8F">&quot;Xiro&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Xplorer V&quot;</FONT></B> },
  };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *corp[] =
    { <B><FONT COLOR="#BC8F8F">&quot;AgfaPhoto&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Casio&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Epson&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Fujifilm&quot;</FONT></B>,
      <B><FONT COLOR="#BC8F8F">&quot;Mamiya&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Minolta&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Motorola&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Konica&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Leica&quot;</FONT></B>,
      <B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Nokia&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Olympus&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Ricoh&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Phase One&quot;</FONT></B>,
      <B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sigma&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;YI&quot;</FONT></B> };
  <B><FONT COLOR="#228B22">char</FONT></B> head[32], *cp;
  <B><FONT COLOR="#228B22">int</FONT></B> hlen, flen, fsize, zero_fsize=1, i, c;
  <B><FONT COLOR="#228B22">struct</FONT></B> jhead jh;

  tiff_flip = flip = filters = UINT_MAX;	<I><FONT COLOR="#B22222">/* unknown */</FONT></I>
  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;
  maximum = height = width = top_margin = left_margin = 0;
  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;
  iso_speed = shutter = aperture = focal_len = unique_id = 0;
  tiff_nifds = 0;
  memset (tiff_ifd, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> tiff_ifd);
  memset (gpsdata, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> gpsdata);
  memset (cblack, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cblack);
  memset (white, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> white);
  memset (mask, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> mask);
  thumb_offset = thumb_length = thumb_width = thumb_height = 0;
  load_raw = thumb_load_raw = 0;
  write_thumb = &amp;CLASS jpeg_thumb;
  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;
  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
  timestamp = shot_order = tiff_samples = black = is_foveon = 0;
  mix_green = profile_length = data_error = zero_is_bad = 0;
  pixel_aspect = is_raw = raw_color = 1;
  tile_width = tile_length = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 4; i++) {
    cam_mul[i] = i == 1;
    pre_mul[i] = i &lt; 3;
    FORC3 cmatrix[c][i] = 0;
    FORC3 rgb_cam[c][i] = c == i;
  }
  colors = 3;
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 0x10000; i++) curve[i] = i;

  order = get2();
  hlen = get4();
  fseek (ifp, 0, SEEK_SET);
  fread (head, 1, 32, ifp);
  fseek (ifp, 0, SEEK_END);
  flen = fsize = ftell(ifp);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((cp = (<B><FONT COLOR="#228B22">char</FONT></B> *) memmem (head, 32, <B><FONT COLOR="#BC8F8F">&quot;MMMM&quot;</FONT></B>, 4)) ||
      (cp = (<B><FONT COLOR="#228B22">char</FONT></B> *) memmem (head, 32, <B><FONT COLOR="#BC8F8F">&quot;IIII&quot;</FONT></B>, 4))) {
    parse_phase_one (cp-head);
    <B><FONT COLOR="#A020F0">if</FONT></B> (cp-head &amp;&amp; parse_tiff(0)) apply_tiff();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (order == 0x4949 || order == 0x4d4d) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head+6,<B><FONT COLOR="#BC8F8F">&quot;HEAPCCDR&quot;</FONT></B>,8)) {
      data_offset = hlen;
      parse_ciff (hlen, flen-hlen, 0);
      load_raw = &amp;CLASS canon_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (parse_tiff(0)) apply_tiff();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;\xff\xd8\xff\xe1&quot;</FONT></B>,4) &amp;&amp;
	     !memcmp (head+6,<B><FONT COLOR="#BC8F8F">&quot;Exif&quot;</FONT></B>,4)) {
    fseek (ifp, 4, SEEK_SET);
    data_offset = 4 + get2();
    fseek (ifp, data_offset, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (fgetc(ifp) != 0xff)
      parse_tiff(12);
    thumb_offset = 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head+25,<B><FONT COLOR="#BC8F8F">&quot;ARECOYK&quot;</FONT></B>,7)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Contax&quot;</FONT></B>);
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;N Digital&quot;</FONT></B>);
    fseek (ifp, 33, SEEK_SET);
    get_timestamp(1);
    fseek (ifp, 60, SEEK_SET);
    FORC4 cam_mul[c ^ (c &gt;&gt; 1)] = get4();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (head, <B><FONT COLOR="#BC8F8F">&quot;PXN&quot;</FONT></B>)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Logitech&quot;</FONT></B>);
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;Fotoman Pixtura&quot;</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (head, <B><FONT COLOR="#BC8F8F">&quot;qktk&quot;</FONT></B>)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Apple&quot;</FONT></B>);
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;QuickTake 100&quot;</FONT></B>);
    load_raw = &amp;CLASS quicktake_100_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp (head, <B><FONT COLOR="#BC8F8F">&quot;qktn&quot;</FONT></B>)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Apple&quot;</FONT></B>);
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;QuickTake 150&quot;</FONT></B>);
    load_raw = &amp;CLASS kodak_radc_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;FUJIFILM&quot;</FONT></B>,8)) {
    fseek (ifp, 84, SEEK_SET);
    thumb_offset = get4();
    thumb_length = get4();
    fseek (ifp, 92, SEEK_SET);
    parse_fuji (get4());
    <B><FONT COLOR="#A020F0">if</FONT></B> (thumb_offset &gt; 120) {
      fseek (ifp, 120, SEEK_SET);
      is_raw += (i = get4()) &amp;&amp; 1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (is_raw == 2 &amp;&amp; shot_select)
	parse_fuji (i);
    }
    fseek (ifp, 100+28*(shot_select &gt; 0), SEEK_SET);
    parse_tiff (data_offset = get4());
    parse_tiff (thumb_offset+12);
    apply_tiff();
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw) {
      load_raw = &amp;CLASS unpacked_load_raw;
      tiff_bps = 14;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;RIFF&quot;</FONT></B>,4)) {
    fseek (ifp, 0, SEEK_SET);
    parse_riff();
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head+4,<B><FONT COLOR="#BC8F8F">&quot;ftypcrx &quot;</FONT></B>,8)) {
    fseek (ifp, 0, SEEK_SET);
    parse_crx (fsize);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head+4,<B><FONT COLOR="#BC8F8F">&quot;ftypqt   &quot;</FONT></B>,9)) {
    fseek (ifp, 0, SEEK_SET);
    parse_qt (fsize);
    is_raw = 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;\0\001\0\001\0@&quot;</FONT></B>,6)) {
    fseek (ifp, 6, SEEK_SET);
    fread (make, 1, 8, ifp);
    fread (model, 1, 8, ifp);
    fread (model2, 1, 16, ifp);
    data_offset = get2();
    get2();
    raw_width = get2();
    raw_height = get2();
    load_raw = &amp;CLASS nokia_load_raw;
    filters = 0x61616161;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;NOKIARAW&quot;</FONT></B>,8)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;NOKIA&quot;</FONT></B>);
    order = 0x4949;
    fseek (ifp, 300, SEEK_SET);
    data_offset = get4();
    i = get4();
    width = get2();
    height = get2();
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_bps = i*8 / (width * height)) {
      <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">8</FONT></B>: load_raw = &amp;CLASS eight_bit_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">10</FONT></B>: load_raw = &amp;CLASS nokia_load_raw;
    }
    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);
    mask[0][3] = 1;
    filters = 0x61616161;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;ARRI&quot;</FONT></B>,4)) {
    order = 0x4949;
    fseek (ifp, 20, SEEK_SET);
    width = get4();
    height = get4();
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;ARRI&quot;</FONT></B>);
    fseek (ifp, 668, SEEK_SET);
    fread (model, 1, 64, ifp);
    data_offset = 4096;
    load_raw = &amp;CLASS packed_load_raw;
    load_flags = 88;
    filters = 0x61616161;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;XPDS&quot;</FONT></B>,4)) {
    order = 0x4949;
    fseek (ifp, 0x800, SEEK_SET);
    fread (make, 1, 41, ifp);
    raw_height = get2();
    raw_width  = get2();
    fseek (ifp, 56, SEEK_CUR);
    fread (model, 1, 30, ifp);
    data_offset = 0x10000;
    load_raw = &amp;CLASS canon_rmf_load_raw;
    gamma_curve (0, 12.25, 1, 1023);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head+4,<B><FONT COLOR="#BC8F8F">&quot;RED1&quot;</FONT></B>,4)) {
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Red&quot;</FONT></B>);
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;One&quot;</FONT></B>);
    parse_redcine();
    load_raw = &amp;CLASS redcine_load_raw;
    gamma_curve (1/2.4, 12.92, 1, 4095);
    filters = 0x49494949;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;DSC-Image&quot;</FONT></B>,9))
    parse_rollei();
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;PWAD&quot;</FONT></B>,4))
    parse_sinar_ia();
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;\0MRM&quot;</FONT></B>,4))
    parse_minolta(0);
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;FOVb&quot;</FONT></B>,4))
    parse_foveon();
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!memcmp (head,<B><FONT COLOR="#BC8F8F">&quot;CI&quot;</FONT></B>,2))
    parse_cine();
  <B><FONT COLOR="#A020F0">if</FONT></B> (make[0] == 0)
    <B><FONT COLOR="#A020F0">for</FONT></B> (zero_fsize=i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> table / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *table; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == table[i].fsize) {
	strcpy (make,  table[i].make );
	strcpy (model, table[i].model);
	flip = table[i].flags &gt;&gt; 2;
	zero_is_bad = table[i].flags &amp; 2;
	<B><FONT COLOR="#A020F0">if</FONT></B> (table[i].flags &amp; 1)
	  parse_external_jpeg();
	data_offset = table[i].offset;
	raw_width   = table[i].rw;
	raw_height  = table[i].rh;
	left_margin = table[i].lm;
	 top_margin = table[i].tm;
	width  = raw_width - left_margin - table[i].rm;
	height = raw_height - top_margin - table[i].bm;
	filters = 0x1010101 * table[i].cf;
	colors = 4 - !((filters &amp; filters &gt;&gt; 1) &amp; 0x5555);
	load_flags = table[i].lf;
	<B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">6</FONT></B>:
	    load_raw = &amp;CLASS minolta_rd175_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">8</FONT></B>:
	    load_raw = &amp;CLASS eight_bit_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">10</FONT></B>: <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">12</FONT></B>:
	    load_flags |= 512;
	    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>)) load_flags |= 256;
	    load_raw = &amp;CLASS packed_load_raw;     <B><FONT COLOR="#A020F0">break</FONT></B>;
	  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">16</FONT></B>:
	    order = 0x4949 | 0x404 * (load_flags &amp; 1);
	    tiff_bps -= load_flags &gt;&gt; 4;
	    tiff_bps -= load_flags = load_flags &gt;&gt; 1 &amp; 7;
	    load_raw = &amp;CLASS unpacked_load_raw;
	}
	maximum = (1 &lt;&lt; tiff_bps) - (1 &lt;&lt; table[i].max);
      }
  <B><FONT COLOR="#A020F0">if</FONT></B> (zero_fsize) fsize = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (make[0] == 0) parse_smal (0, flen);
  <B><FONT COLOR="#A020F0">if</FONT></B> (make[0] == 0) {
    parse_jpeg(0);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;ov&quot;</FONT></B>,2) &amp;&amp; strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;RP_OV&quot;</FONT></B>,5)) &amp;&amp;
	!fseek (ifp, -6404096, SEEK_END) &amp;&amp;
	fread (head, 1, 32, ifp) &amp;&amp; !strcmp(head,<B><FONT COLOR="#BC8F8F">&quot;BRCMn&quot;</FONT></B>)) {
      strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;OmniVision&quot;</FONT></B>);
      data_offset = ftell(ifp) + 0x8000-32;
      width = raw_width;
      raw_width = 2611;
      load_raw = &amp;CLASS nokia_load_raw;
      filters = 0x16161616;
    } <B><FONT COLOR="#A020F0">else</FONT></B> is_raw = 0;
  }

  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> corp / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *corp; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (strcasestr (make, corp[i]))	<I><FONT COLOR="#B22222">/* Simplify company names */</FONT></I>
	    strcpy (make, corp[i]);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>) || !strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Leica&quot;</FONT></B>)) &amp;&amp;
	((cp = strcasestr(model,<B><FONT COLOR="#BC8F8F">&quot; DIGITAL CAMERA&quot;</FONT></B>)) ||
	 (cp = strstr(model,<B><FONT COLOR="#BC8F8F">&quot;FILE VERSION&quot;</FONT></B>))))
     *cp = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncasecmp(model,<B><FONT COLOR="#BC8F8F">&quot;PENTAX&quot;</FONT></B>,6))
    strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Pentax&quot;</FONT></B>);
  cp = make + strlen(make);		<I><FONT COLOR="#B22222">/* Remove trailing spaces */</FONT></I>
  <B><FONT COLOR="#A020F0">while</FONT></B> (*--cp == <B><FONT COLOR="#BC8F8F">' '</FONT></B>) *cp = 0;
  cp = model + strlen(model);
  <B><FONT COLOR="#A020F0">while</FONT></B> (*--cp == <B><FONT COLOR="#BC8F8F">' '</FONT></B>) *cp = 0;
  i = strlen(make);			<I><FONT COLOR="#B22222">/* Remove make from model */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncasecmp (model, make, i) &amp;&amp; model[i++] == <B><FONT COLOR="#BC8F8F">' '</FONT></B>)
    memmove (model, model+i, 64-i);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (model,<B><FONT COLOR="#BC8F8F">&quot;FinePix &quot;</FONT></B>,8))
    strcpy (model, model+8);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp (model,<B><FONT COLOR="#BC8F8F">&quot;Digital Camera &quot;</FONT></B>,15))
    strcpy (model, model+15);
  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!is_raw) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">notraw</FONT></B>;

  <B><FONT COLOR="#A020F0">if</FONT></B> (!height) height = raw_height;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!width)  width  = raw_width;
  <B><FONT COLOR="#A020F0">if</FONT></B> (height == 2624 &amp;&amp; width == 3936)	<I><FONT COLOR="#B22222">/* Pentax K10D and Samsung GX10 */</FONT></I>
    { height  = 2616;   width  = 3896; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (height == 3136 &amp;&amp; width == 4864)  <I><FONT COLOR="#B22222">/* Pentax K20D and Samsung GX20 */</FONT></I>
    { height  = 3124;   width  = 4688; filters = 0x16161616; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 2868 &amp;&amp; (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-r&quot;</FONT></B>) || !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-x&quot;</FONT></B>)))
    {			width  = 4309; filters = 0x16161616; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 3136 &amp;&amp; !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-7&quot;</FONT></B>))
    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 3284 &amp;&amp; !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-5&quot;</FONT></B>,3))
    { left_margin = 10; width  = 4950; filters = 0x16161616; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 3300 &amp;&amp; !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-50&quot;</FONT></B>,4))
    { height  = 3288,   width  = 4952;  left_margin = 0;  top_margin = 12; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 3664 &amp;&amp; !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-S&quot;</FONT></B>,3))
    {			width  = 5492;  left_margin = 0; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 4032 &amp;&amp; !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-3&quot;</FONT></B>))
    { height  = 4032;   width  = 6040;  left_margin = 4; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 4060 &amp;&amp; !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;KP&quot;</FONT></B>))
    { height  = 4032;   width  = 6032;  left_margin = 52; top_margin = 28; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 4950 &amp;&amp; !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;K-1&quot;</FONT></B>))
    { height  = 4932;   width  = 7380;  left_margin = 4;  top_margin = 18; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height == 5552 &amp;&amp; !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;645D&quot;</FONT></B>))
    { height  = 5502;   width  = 7328;  left_margin = 48; top_margin = 29;
      filters = 0x61616161; }
  <B><FONT COLOR="#A020F0">if</FONT></B> (height == 3014 &amp;&amp; width == 4096)	<I><FONT COLOR="#B22222">/* Ricoh GX200 */</FONT></I>
			width  = 4014;
  <B><FONT COLOR="#A020F0">if</FONT></B> (dng_version) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters == UINT_MAX) filters = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters) is_raw *= tiff_samples;
    <B><FONT COLOR="#A020F0">else</FONT></B>	 colors  = tiff_samples;
    <B><FONT COLOR="#A020F0">switch</FONT></B> (tiff_compress) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>:
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:     load_raw = &amp;CLASS   packed_dng_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">7</FONT></B>:     load_raw = &amp;CLASS lossless_dng_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">34892</FONT></B>: load_raw = &amp;CLASS    lossy_dng_load_raw;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#5F9EA0">default</FONT></B>:    load_raw = 0;
    }
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">dng_skip</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>) &amp;&amp; !fsize &amp;&amp; tiff_bps != 15) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw)
      load_raw = &amp;CLASS lossless_jpeg_load_raw;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> canon / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *canon; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == canon[i][0] &amp;&amp; raw_height == canon[i][1]) {
	width  = raw_width - (left_margin = canon[i][2]);
	height = raw_height - (top_margin = canon[i][3]);
	width  -= canon[i][4];
	height -= canon[i][5];
	mask[0][1] =  canon[i][6];
	mask[0][3] = -canon[i][7];
	mask[1][1] =  canon[i][8];
	mask[1][3] = -canon[i][9];
	<B><FONT COLOR="#A020F0">if</FONT></B> (canon[i][10]) filters = canon[i][10] * 0x01010101;
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((unique_id | 0x20000) == 0x2720000) {
      left_margin = 8;
      top_margin = 16;
    }
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> unique / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *unique; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (unique_id == 0x80000000 + unique[i].id) {
      adobe_coeff (<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>, unique[i].model);
      <B><FONT COLOR="#A020F0">if</FONT></B> (model[4] == <B><FONT COLOR="#BC8F8F">'K'</FONT></B> &amp;&amp; strlen(model) == 8)
	strcpy (model, unique[i].model);
    }
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> sonique / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *sonique; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (unique_id == sonique[i].id)
      strcpy (model, sonique[i].model);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> panalias / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *panalias; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (panalias[i][0] == <B><FONT COLOR="#BC8F8F">'@'</FONT></B>) orig = panalias[i]+1;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,panalias[i]))
      adobe_coeff (<B><FONT COLOR="#BC8F8F">&quot;Panasonic&quot;</FONT></B>, orig);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Nikon&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw)
      load_raw = &amp;CLASS packed_load_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (model[0] == <B><FONT COLOR="#BC8F8F">'E'</FONT></B>)
      load_flags |= !data_offset &lt;&lt; 2 | 2;
  }

<I><FONT COLOR="#B22222">/* Set parameters based on camera name (for non-DNG files). */</FONT></I>

  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;KAI-0340&quot;</FONT></B>)
	&amp;&amp; find_green (16, 16, 3840, 5120) &lt; 25) {
    height = 480;
    top_margin = filters = 0;
    strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B>);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width &gt; 3888)
    black = 128 &lt;&lt; (tiff_bps - 12);
  <B><FONT COLOR="#A020F0">if</FONT></B> (is_foveon) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (height*2 &lt; width) pixel_aspect = 0.5;
    <B><FONT COLOR="#A020F0">if</FONT></B> (height   &gt; width) pixel_aspect = 2;
    filters = 0;
    simple_coeff(0);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Canon&quot;</FONT></B>) &amp;&amp; tiff_bps == 15) {
    <B><FONT COLOR="#A020F0">switch</FONT></B> (width) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3344</FONT></B>: width -= 66;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">3872</FONT></B>: width -= 6;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (height &gt; width) {
      SWAP(height,width);
      SWAP(raw_height,raw_width);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 7200 &amp;&amp; height == 3888) {
      raw_width  = width  = 6480;
      raw_height = height = 4320;
    }
    filters = 0;
    tiff_samples = colors = 3;
    load_raw = &amp;CLASS canon_sraw_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot 600&quot;</FONT></B>)) {
    height = 613;
    width  = 854;
    raw_width = 896;
    colors = 4;
    filters = 0xe1e4e1e4;
    load_raw = &amp;CLASS canon_600_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A5&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A5 Zoom&quot;</FONT></B>)) {
    height = 773;
    width  = 960;
    raw_width = 992;
    pixel_aspect = 256/235.0;
    filters = 0x1e4e1e4e;
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">canon_a5</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A50&quot;</FONT></B>)) {
    height =  968;
    width  = 1290;
    raw_width = 1320;
    filters = 0x1b4e4b1e;
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">canon_a5</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot Pro70&quot;</FONT></B>)) {
    height = 1024;
    width  = 1552;
    filters = 0x1e4b4e1b;
<B><FONT COLOR="#5F9EA0">canon_a5</FONT></B>:
    colors = 4;
    tiff_bps = 10;
    load_raw = &amp;CLASS packed_load_raw;
    load_flags = 264;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot Pro90 IS&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot G1&quot;</FONT></B>)) {
    colors = 4;
    filters = 0xb4b4b4b4;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot A610&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (canon_s2is()) strcpy (model+10, <B><FONT COLOR="#BC8F8F">&quot;S2 IS&quot;</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PowerShot SX220 HS&quot;</FONT></B>)) {
    mask[1][3] = -4;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;EOS D2000C&quot;</FONT></B>)) {
    filters = 0x61616161;
    black = curve[200];
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;EOS 80D&quot;</FONT></B>)) {
    top_margin -= 2;
    height += 2;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D1&quot;</FONT></B>)) {
    cam_mul[0] *= 256/527.0;
    cam_mul[2] *= 256/317.0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D1X&quot;</FONT></B>)) {
    width -= 4;
    pixel_aspect = 0.5;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D40X&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D60&quot;</FONT></B>)  ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D80&quot;</FONT></B>)  ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D3000&quot;</FONT></B>)) {
    height -= 3;
    width  -= 4;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D3&quot;</FONT></B>)   ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D3S&quot;</FONT></B>)  ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D700&quot;</FONT></B>)) {
    width -= 4;
    left_margin = 2;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D3100&quot;</FONT></B>)) {
    width -= 28;
    left_margin = 6;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D5000&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D90&quot;</FONT></B>)) {
    width -= 42;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D5100&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D7000&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;COOLPIX A&quot;</FONT></B>)) {
    width -= 44;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D3200&quot;</FONT></B>) ||
	    !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D6&quot;</FONT></B>,2)  ||
	    !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D800&quot;</FONT></B>,4)) {
    width -= 46;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D4&quot;</FONT></B>) ||
	     !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;Df&quot;</FONT></B>)) {
    width -= 52;
    left_margin = 2;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D40&quot;</FONT></B>,3) ||
	     !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D50&quot;</FONT></B>,3) ||
	     !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D70&quot;</FONT></B>,3)) {
    width--;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D100&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_flags)
      raw_width = (width += 3) + 3;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;D200&quot;</FONT></B>)) {
    left_margin = 1;
    width -= 4;
    filters = 0x94949494;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D2H&quot;</FONT></B>,3)) {
    left_margin = 6;
    width -= 14;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D2X&quot;</FONT></B>,3)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 3264) width -= 32;
    <B><FONT COLOR="#A020F0">else</FONT></B> width -= 8;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;D300&quot;</FONT></B>,4)) {
    width -= 32;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;COOLPIX B&quot;</FONT></B>,9)) {
    load_flags = 24;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;COOLPIX P&quot;</FONT></B>,9) &amp;&amp; raw_width != 4032) {
    load_flags = 24;
    filters = 0x94949494;
    <B><FONT COLOR="#A020F0">if</FONT></B> (model[9] == <B><FONT COLOR="#BC8F8F">'7'</FONT></B> &amp;&amp; iso_speed &gt;= 400)
      black = 255;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;1 &quot;</FONT></B>,2)) {
    height -= 2;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 1581060) {
    simple_coeff(3);
    pre_mul[0] = 1.2085;
    pre_mul[1] = 1.0943;
    pre_mul[3] = 1.1103;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 3178560) {
    cam_mul[0] *= 4;
    cam_mul[2] *= 4;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 4771840) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!timestamp &amp;&amp; nikon_e995())
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;E995&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;E995&quot;</FONT></B>)) {
      filters = 0xb4b4b4b4;
      simple_coeff(3);
      pre_mul[0] = 1.196;
      pre_mul[1] = 1.246;
      pre_mul[2] = 1.018;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 2940928) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!timestamp &amp;&amp; !nikon_e2100())
      strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;E2500&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;E2500&quot;</FONT></B>)) {
      height -= 2;
      load_flags = 6;
      colors = 4;
      filters = 0x4b4b4b4b;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 4775936) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!timestamp) nikon_3700();
    <B><FONT COLOR="#A020F0">if</FONT></B> (model[0] == <B><FONT COLOR="#BC8F8F">'E'</FONT></B> &amp;&amp; atoi(model+1) &lt; 3700)
      filters = 0x49494949;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;Optio 33WR&quot;</FONT></B>)) {
      flip = 1;
      filters = 0x16161616;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (make[0] == <B><FONT COLOR="#BC8F8F">'O'</FONT></B>) {
      i = find_green (12, 32, 1188864, 3576832);
      c = find_green (12, 32, 2383920, 2387016);
      <B><FONT COLOR="#A020F0">if</FONT></B> (abs(i) &lt; abs(c)) {
	SWAP(i,c);
	load_flags = 24;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (i &lt; 0) filters = 0x61616161;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 5869568) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!timestamp &amp;&amp; minolta_z2()) {
      strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;Minolta&quot;</FONT></B>);
      strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;DiMAGE Z2&quot;</FONT></B>);
    }
    load_flags = 6 + 24*(make[0] == <B><FONT COLOR="#BC8F8F">'M'</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fsize == 6291456) {
    fseek (ifp, 0x300000, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((order = guess_byte_order(0x10000)) == 0x4d4d) {
      height -= (top_margin = 16);
      width -= (left_margin = 28);
      maximum = 0xf5c0;
      strcpy (make, <B><FONT COLOR="#BC8F8F">&quot;ISG&quot;</FONT></B>);
      model[0] = 0;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Fujifilm&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model+7,<B><FONT COLOR="#BC8F8F">&quot;S2Pro&quot;</FONT></B>)) {
      strcpy (model,<B><FONT COLOR="#BC8F8F">&quot;S2Pro&quot;</FONT></B>);
      height = 2144;
      width  = 2880;
      flip = 6;
    }
    top_margin = (raw_height - height) &gt;&gt; 2 &lt;&lt; 1;
    left_margin = (raw_width - width ) &gt;&gt; 2 &lt;&lt; 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 2848 || width == 3664) filters = 0x16161616;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 4032 || width == 4952 || width == 6032 || width == 8280) left_margin = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 3328 &amp;&amp; (width -= 66)) left_margin = 34;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 4936) left_margin = 4;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;HS50EXR&quot;</FONT></B>) ||
	!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;F900EXR&quot;</FONT></B>)) {
      width += 2;
      left_margin = 0;
      filters = 0x16161616;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (fuji_layout) raw_width *= is_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9)
      FORC(36) ((<B><FONT COLOR="#228B22">char</FONT></B> *)xtrans)[c] =
	xtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;KD-400Z&quot;</FONT></B>)) {
    height = 1712;
    width  = 2312;
    raw_width = 2336;
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">konica_400z</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;KD-510Z&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">konica_510z</FONT></B>;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcasecmp(make,<B><FONT COLOR="#BC8F8F">&quot;Minolta&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw &amp;&amp; (maximum = 0xfff))
      load_raw = &amp;CLASS unpacked_load_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DiMAGE A&quot;</FONT></B>,8)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DiMAGE A200&quot;</FONT></B>))
	filters = 0x49494949;
      tiff_bps = 12;
      load_raw = &amp;CLASS packed_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;ALPHA&quot;</FONT></B>,5) ||
	       !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DYNAX&quot;</FONT></B>,5) ||
	       !strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;MAXXUM&quot;</FONT></B>,6)) {
      sprintf (model+20, <B><FONT COLOR="#BC8F8F">&quot;DYNAX %-10s&quot;</FONT></B>, model+6+(model[0]==<B><FONT COLOR="#BC8F8F">'M'</FONT></B>));
      adobe_coeff (make, model+20);
      load_raw = &amp;CLASS packed_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DiMAGE G&quot;</FONT></B>,8)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (model[8] == <B><FONT COLOR="#BC8F8F">'4'</FONT></B>) {
	height = 1716;
	width  = 2304;
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (model[8] == <B><FONT COLOR="#BC8F8F">'5'</FONT></B>) {
<B><FONT COLOR="#5F9EA0">konica_510z</FONT></B>:
	height = 1956;
	width  = 2607;
	raw_width = 2624;
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (model[8] == <B><FONT COLOR="#BC8F8F">'6'</FONT></B>) {
	height = 2136;
	width  = 2848;
      }
      data_offset += 14;
      filters = 0x61616161;
<B><FONT COLOR="#5F9EA0">konica_400z</FONT></B>:
      load_raw = &amp;CLASS unpacked_load_raw;
      maximum = 0x3df;
      order = 0x4d4d;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;*ist D&quot;</FONT></B>)) {
    load_raw = &amp;CLASS unpacked_load_raw;
    data_error = -1;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;*ist DS&quot;</FONT></B>)) {
    height -= 2;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>) &amp;&amp; raw_width == 4704) {
    height -= top_margin = 8;
    width -= 2 * (left_margin = 8);
    load_flags = 256;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>) &amp;&amp; raw_height == 3714) {
    height -= top_margin = 18;
    left_margin = raw_width - (width = 5536);
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width != 5600)
      left_margin = top_margin = 0;
    filters = 0x61616161;
    colors = 3;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>) &amp;&amp; raw_width == 5632) {
    order = 0x4949;
    height = 3694;
    top_margin = 2;
    width  = 5574 - (left_margin = 32 + tiff_bps);
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_bps == 12) load_flags = 80;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>) &amp;&amp; raw_width == 5664) {
    height -= top_margin = 17;
    left_margin = 96;
    width = 5544;
    filters = 0x49494949;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Samsung&quot;</FONT></B>) &amp;&amp; raw_width == 6496) {
    filters = 0x61616161;
    black = 1 &lt;&lt; (tiff_bps - 7);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;EX1&quot;</FONT></B>)) {
    order = 0x4949;
    height -= 20;
    top_margin = 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((width -= 6) &gt; 3682) {
      height -= 10;
      width  -= 46;
      top_margin = 8;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;WB2000&quot;</FONT></B>)) {
    order = 0x4949;
    height -= 3;
    top_margin = 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((width -= 10) &gt; 3718) {
      height -= 28;
      width  -= 56;
      top_margin = 8;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;WB550&quot;</FONT></B>)) {
    strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;WB550&quot;</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;EX2F&quot;</FONT></B>)) {
    height = 3045;
    width  = 4070;
    top_margin = 3;
    order = 0x4949;
    filters = 0x49494949;
    load_raw = &amp;CLASS unpacked_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;STV680 VGA&quot;</FONT></B>)) {
    black = 16;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;N95&quot;</FONT></B>)) {
    height = raw_height - (top_margin = 2);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;640x480&quot;</FONT></B>)) {
    gamma_curve (0.45, 4.5, 1, 255);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Hasselblad&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS lossless_jpeg_load_raw)
      load_raw = &amp;CLASS hasselblad_load_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 7262) {
      height = 5444;
      width  = 7248;
      top_margin  = 4;
      left_margin = 7;
      filters = 0x61616161;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 7410 || raw_width == 8282) {
      height -= 84;
      width  -= 82;
      top_margin  = 4;
      left_margin = 41;
      filters = 0x61616161;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 8384) {
      height = 6208;
      width  = 8280;
      top_margin  = 96;
      left_margin = 46;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 9044) {
      height = 6716;
      width  = 8964;
      top_margin  = 8;
      left_margin = 40;
      black += load_flags = 256;
      maximum = 0x8101;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == 4090) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;V96C&quot;</FONT></B>);
      height -= (top_margin = 6);
      width -= (left_margin = 3) + 7;
      filters = 0x61616161;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples &gt; 1) {
      is_raw = tiff_samples+1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (!shot_select &amp;&amp; !half_size) filters = 0;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sinar&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw) load_raw = &amp;CLASS unpacked_load_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (is_raw &gt; 1 &amp;&amp; !shot_select &amp;&amp; !half_size) filters = 0;
    maximum = 0x3fff;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Leaf&quot;</FONT></B>)) {
    maximum = 0x3fff;
    fseek (ifp, data_offset, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ljpeg_start (&amp;jh, 1) &amp;&amp; jh.bits == 15)
      maximum = 0x1fff;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples &gt; 1) filters = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples &gt; 1 || tile_length &lt; raw_height) {
      load_raw = &amp;CLASS leaf_hdr_load_raw;
      raw_width = tile_width;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((width | height) == 2048) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (tiff_samples == 1) {
	filters = 1;
	strcpy (cdesc, <B><FONT COLOR="#BC8F8F">&quot;RBTG&quot;</FONT></B>);
	strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;CatchLight&quot;</FONT></B>);
	top_margin =  8; left_margin = 18; height = 2032; width = 2016;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
	strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;DCB2&quot;</FONT></B>);
	top_margin = 10; left_margin = 16; height = 2028; width = 2022;
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (width+height == 3144+2060) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!model[0]) strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;Cantare&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">if</FONT></B> (width &gt; height) {
	 top_margin = 6; left_margin = 32; height = 2048;  width = 3072;
	filters = 0x61616161;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
	left_margin = 6;  top_margin = 32;  width = 2048; height = 3072;
	filters = 0x16161616;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (!cam_mul[0] || model[0] == <B><FONT COLOR="#BC8F8F">'V'</FONT></B>) filters = 0;
      <B><FONT COLOR="#A020F0">else</FONT></B> is_raw = tiff_samples;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (width == 2116) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;Valeo 6&quot;</FONT></B>);
      height -= 2 * (top_margin = 30);
      width -= 2 * (left_margin = 55);
      filters = 0x49494949;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (width == 3171) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;Valeo 6&quot;</FONT></B>);
      height -= 2 * (top_margin = 24);
      width -= 2 * (left_margin = 24);
      filters = 0x16161616;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Leica&quot;</FONT></B>) || !strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Panasonic&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> ((flen - data_offset) / (raw_width*8/7) == raw_height)
      load_raw = &amp;CLASS panasonic_load_raw;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw) {
      load_raw = &amp;CLASS unpacked_load_raw;
      load_flags = 4;
    }
    zero_is_bad = 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((height += 12) &gt; raw_height) height = raw_height;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B> pana / <B><FONT COLOR="#A020F0">sizeof</FONT></B> *pana; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width == pana[i][0] &amp;&amp; raw_height == pana[i][1]) {
	left_margin = pana[i][2];
	 top_margin = pana[i][3];
	     width += pana[i][4];
	    height += pana[i][5];
      }
    filters = 0x01010101 * (uchar) <B><FONT COLOR="#BC8F8F">&quot;\x94\x61\x49\x16&quot;</FONT></B>
	[((filters-1) ^ (left_margin &amp; 1) ^ (top_margin &lt;&lt; 1)) &amp; 3];
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;C770UZ&quot;</FONT></B>)) {
    height = 1718;
    width  = 2304;
    filters = 0x16161616;
    load_raw = &amp;CLASS packed_load_raw;
    load_flags = 30;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Olympus&quot;</FONT></B>)) {
    height += height &amp; 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (exif_cfa) filters = exif_cfa;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 4100) width -= 4;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 4080) width -= 24;
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 9280) { width -= 6; height -= 6; }
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS unpacked_load_raw)
      load_flags = 4;
    tiff_bps = 12;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;E-300&quot;</FONT></B>) ||
	!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;E-500&quot;</FONT></B>)) {
      width -= 20;
      <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS unpacked_load_raw) {
	maximum = 0xfc3;
	memset (cblack, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cblack);
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;E-330&quot;</FONT></B>)) {
      width -= 30;
      <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS unpacked_load_raw)
	maximum = 0xf79;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;SP550UZ&quot;</FONT></B>)) {
      thumb_length = flen - (thumb_offset = 0xa39800);
      thumb_height = 480;
      thumb_width  = 640;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;TG-4&quot;</FONT></B>)) {
      width -= 16;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;TG-5&quot;</FONT></B>)) {
      width -= 6;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;N Digital&quot;</FONT></B>)) {
    height = 2047;
    width  = 3072;
    filters = 0x61616161;
    data_offset = 0x1a00;
    load_raw = &amp;CLASS packed_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSC-F828&quot;</FONT></B>)) {
    width = 3288;
    left_margin = 5;
    mask[1][3] = -17;
    data_offset = 862144;
    load_raw = &amp;CLASS sony_load_raw;
    filters = 0x9c9c9c9c;
    colors = 4;
    strcpy (cdesc, <B><FONT COLOR="#BC8F8F">&quot;RGBE&quot;</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSC-V3&quot;</FONT></B>)) {
    width = 3109;
    left_margin = 59;
    mask[0][1] = 9;
    data_offset = 787392;
    load_raw = &amp;CLASS sony_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 3984) {
    width = 3925;
    order = 0x4d4d;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 4288) {
    width -= 32;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 4600) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSLR-A350&quot;</FONT></B>))
      height -= 4;
    black = 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 4928) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (height &lt; 3280) width -= 8;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 5504) {
    width -= height &gt; 3664 ? 8 : 32;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSC&quot;</FONT></B>,3))
      black = 200 &lt;&lt; (tiff_bps - 12);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 6048) {
    width -= 24;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;RX1&quot;</FONT></B>) || strstr(model,<B><FONT COLOR="#BC8F8F">&quot;A99&quot;</FONT></B>))
      width -= 6;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 7392) {
    width -= 30;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Sony&quot;</FONT></B>) &amp;&amp; raw_width == 8000) {
    width -= 32;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DSLR-A100&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (width == 3880) {
      height--;
      width = ++raw_width;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      height -= 4;
      width  -= 4;
      order = 0x4d4d;
      load_flags = 2;
    }
    filters = 0x61616161;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;PIXL&quot;</FONT></B>)) {
    height -= top_margin = 4;
    width -= left_margin = 32;
    gamma_curve (0, 7, 1, 255);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;C603&quot;</FONT></B>) || !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B>)
	|| !strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;12MP&quot;</FONT></B>)) {
    order = 0x4949;
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters &amp;&amp; data_offset) {
      fseek (ifp, data_offset &lt; 4096 ? 168 : 5252, SEEK_SET);
      read_shorts (curve, 256);
    } <B><FONT COLOR="#A020F0">else</FONT></B> gamma_curve (0, 3.875, 1, 255);
    load_raw  =  filters   ? &amp;CLASS eight_bit_load_raw :
      strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;C330&quot;</FONT></B>) ? &amp;CLASS kodak_c603_load_raw :
			     &amp;CLASS kodak_c330_load_raw;
    load_flags = tiff_bps &gt; 16;
    tiff_bps = 8;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncasecmp(model,<B><FONT COLOR="#BC8F8F">&quot;EasyShare&quot;</FONT></B>,9)) {
    data_offset = data_offset &lt; 0x15000 ? 0x15000 : 0x17000;
    load_raw = &amp;CLASS packed_load_raw;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcasecmp(make,<B><FONT COLOR="#BC8F8F">&quot;Kodak&quot;</FONT></B>)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters == UINT_MAX) filters = 0x61616161;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;NC2000&quot;</FONT></B>,6) ||
	!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;EOSDCS&quot;</FONT></B>,6) ||
	!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DCS4&quot;</FONT></B>,4)) {
      width -= 4;
      left_margin = 2;
      <B><FONT COLOR="#A020F0">if</FONT></B> (model[6] == <B><FONT COLOR="#BC8F8F">' '</FONT></B>) model[6] = 0;
      <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DCS460A&quot;</FONT></B>)) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">bw</FONT></B>;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DCS660M&quot;</FONT></B>)) {
      black = 214;
      <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">bw</FONT></B>;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DCS760M&quot;</FONT></B>)) {
<B><FONT COLOR="#5F9EA0">bw</FONT></B>:   colors = 1;
      filters = 0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model+4,<B><FONT COLOR="#BC8F8F">&quot;20X&quot;</FONT></B>))
      strcpy (cdesc, <B><FONT COLOR="#BC8F8F">&quot;MYCY&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;DC25&quot;</FONT></B>)) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;DC25&quot;</FONT></B>);
      data_offset = 15424;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;DC2&quot;</FONT></B>,3)) {
      raw_height = 2 + (height = 242);
      <B><FONT COLOR="#A020F0">if</FONT></B> (flen &lt; 100000) {
	raw_width = 256; width = 249;
	pixel_aspect = (4.0*height) / (3.0*width);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
	raw_width = 512; width = 501;
	pixel_aspect = (493.0*height) / (373.0*width);
      }
      top_margin = left_margin = 1;
      colors = 4;
      filters = 0x8d8d8d8d;
      simple_coeff(1);
      pre_mul[1] = 1.179;
      pre_mul[2] = 1.209;
      pre_mul[3] = 1.036;
      load_raw = &amp;CLASS eight_bit_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;40&quot;</FONT></B>)) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;DC40&quot;</FONT></B>);
      height = 512;
      width  = 768;
      data_offset = 1152;
      load_raw = &amp;CLASS kodak_radc_load_raw;
      tiff_bps = 12;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;DC50&quot;</FONT></B>)) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;DC50&quot;</FONT></B>);
      height = 512;
      width  = 768;
      data_offset = 19712;
      load_raw = &amp;CLASS kodak_radc_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(model,<B><FONT COLOR="#BC8F8F">&quot;DC120&quot;</FONT></B>)) {
      strcpy (model, <B><FONT COLOR="#BC8F8F">&quot;DC120&quot;</FONT></B>);
      height = 976;
      width  = 848;
      pixel_aspect = height/0.75/width;
      load_raw = tiff_compress == 7 ?
	&amp;CLASS kodak_jpeg_load_raw : &amp;CLASS kodak_dc120_load_raw;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;DCS200&quot;</FONT></B>)) {
      thumb_height = 128;
      thumb_width  = 192;
      thumb_offset = 6144;
      thumb_misc   = 360;
      write_thumb = &amp;CLASS layer_thumb;
      black = 17;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(model,<B><FONT COLOR="#BC8F8F">&quot;Fotoman Pixtura&quot;</FONT></B>)) {
    height = 512;
    width  = 768;
    data_offset = 3632;
    load_raw = &amp;CLASS kodak_radc_load_raw;
    filters = 0x61616161;
    simple_coeff(2);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strncmp(model,<B><FONT COLOR="#BC8F8F">&quot;QuickTake&quot;</FONT></B>,9)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (head[5]) strcpy (model+10, <B><FONT COLOR="#BC8F8F">&quot;200&quot;</FONT></B>);
    fseek (ifp, 544, SEEK_SET);
    height = get2();
    width  = get2();
    data_offset = (get4(),get2()) == 30 ? 738:736;
    <B><FONT COLOR="#A020F0">if</FONT></B> (height &gt; width) {
      SWAP(height,width);
      fseek (ifp, data_offset-6, SEEK_SET);
      flip = ~get2() &amp; 3 ? 5:6;
    }
    filters = 0x61616161;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!strcmp(make,<B><FONT COLOR="#BC8F8F">&quot;Rollei&quot;</FONT></B>) &amp;&amp; !load_raw) {
    <B><FONT COLOR="#A020F0">switch</FONT></B> (raw_width) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1316</FONT></B>:
	height = 1030;
	width  = 1300;
	top_margin  = 1;
	left_margin = 6;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2568</FONT></B>:
	height = 1960;
	width  = 2560;
	top_margin  = 2;
	left_margin = 8;
    }
    filters = 0x16161616;
    load_raw = &amp;CLASS rollei_load_raw;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!model[0])
    sprintf (model, <B><FONT COLOR="#BC8F8F">&quot;%dx%d&quot;</FONT></B>, width, height);
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == UINT_MAX) filters = 0x94949494;
  <B><FONT COLOR="#A020F0">if</FONT></B> (thumb_offset &amp;&amp; !thumb_height) {
    fseek (ifp, thumb_offset, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ljpeg_start (&amp;jh, 1)) {
      thumb_width  = jh.wide;
      thumb_height = jh.high;
    }
  }
<B><FONT COLOR="#5F9EA0">dng_skip</FONT></B>:
  <B><FONT COLOR="#A020F0">if</FONT></B> ((use_camera_matrix &amp; (use_camera_wb || dng_version))
	&amp;&amp; cmatrix[0][0] &gt; 0.125) {
    memcpy (rgb_cam, cmatrix, <B><FONT COLOR="#A020F0">sizeof</FONT></B> cmatrix);
    raw_color = 0;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (raw_color) adobe_coeff (make, model);
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS kodak_radc_load_raw)
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_color) adobe_coeff (<B><FONT COLOR="#BC8F8F">&quot;Apple&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;Quicktake&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fuji_width) {
    fuji_width = width &gt;&gt; !fuji_layout;
    filters = fuji_width &amp; 1 ? 0x94949494 : 0x49494949;
    width = (height &gt;&gt; fuji_layout) + fuji_width;
    height = width - 1;
    pixel_aspect = 1;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_height &lt; height) raw_height = height;
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_width  &lt; width ) raw_width  = width;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!tiff_bps) tiff_bps = 12;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!maximum) maximum = (1 &lt;&lt; tiff_bps) - 1;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!load_raw || height &lt; 22 || width &lt; 22 ||
	tiff_bps &gt; 16 || tiff_samples &gt; 6 || colors &gt; 4)
    is_raw = 0;
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NO_JASPER</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS redcine_load_raw) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: You must link dcraw with %s!!\n&quot;</FONT></B>),
	ifname, <B><FONT COLOR="#BC8F8F">&quot;libjasper&quot;</FONT></B>);
    is_raw = 0;
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NO_JPEG</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS kodak_jpeg_load_raw ||
      load_raw == &amp;CLASS lossy_dng_load_raw) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: You must link dcraw with %s!!\n&quot;</FONT></B>),
	ifname, <B><FONT COLOR="#BC8F8F">&quot;libjpeg&quot;</FONT></B>);
    is_raw = 0;
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <B><FONT COLOR="#A020F0">if</FONT></B> (!cdesc[0])
    strcpy (cdesc, colors == 3 ? <B><FONT COLOR="#BC8F8F">&quot;RGBG&quot;</FONT></B>:<B><FONT COLOR="#BC8F8F">&quot;GMCY&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!raw_height) raw_height = height;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!raw_width ) raw_width  = width;
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters &gt; 999 &amp;&amp; colors == 3)
    filters |= ((filters &gt;&gt; 2 &amp; 0x22222222) |
		(filters &lt;&lt; 2 &amp; 0x88888888)) &amp; filters &lt;&lt; 1;
<B><FONT COLOR="#5F9EA0">notraw</FONT></B>:
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip == UINT_MAX) flip = tiff_flip;
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip == UINT_MAX) flip = 0;
}

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">apply_profile</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *input, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *output)
{
  <B><FONT COLOR="#228B22">char</FONT></B> *prof;
  cmsHPROFILE hInProfile=0, hOutProfile=0;
  cmsHTRANSFORM hTransform;
  FILE *fp;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> size;

  <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp (input, <B><FONT COLOR="#BC8F8F">&quot;embed&quot;</FONT></B>))
    hInProfile = cmsOpenProfileFromFile (input, <B><FONT COLOR="#BC8F8F">&quot;r&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (profile_length) {
    prof = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (profile_length);
    merror (prof, <B><FONT COLOR="#BC8F8F">&quot;apply_profile()&quot;</FONT></B>);
    fseek (ifp, profile_offset, SEEK_SET);
    fread (prof, 1, profile_length, ifp);
    hInProfile = cmsOpenProfileFromMem (prof, profile_length);
    free (prof);
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s has no embedded profile.\n&quot;</FONT></B>), ifname);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!hInProfile) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!output)
    hOutProfile = cmsCreate_sRGBProfile();
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = fopen (output, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>))) {
    fread (&amp;size, 4, 1, fp);
    fseek (fp, 0, SEEK_SET);
    oprof = (<B><FONT COLOR="#228B22">unsigned</FONT></B> *) malloc (size = ntohl(size));
    merror (oprof, <B><FONT COLOR="#BC8F8F">&quot;apply_profile()&quot;</FONT></B>);
    fread (oprof, 1, size, fp);
    fclose (fp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {
      free (oprof);
      oprof = 0;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Cannot open file %s!\n&quot;</FONT></B>), output);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!hOutProfile) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">quit</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Applying color profile...\n&quot;</FONT></B>));
  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,
	hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);
  cmsDoTransform (hTransform, image, image, width*height);
  raw_color = 1;		<I><FONT COLOR="#B22222">/* Don't use rgb_cam with a profile */</FONT></I>
  cmsDeleteTransform (hTransform);
  cmsCloseProfile (hOutProfile);
<B><FONT COLOR="#5F9EA0">quit</FONT></B>:
  cmsCloseProfile (hInProfile);
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">convert_to_rgb</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, c, i, j, k;
  ushort *img;
  <B><FONT COLOR="#228B22">float</FONT></B> out[3], out_cam[3][4];
  <B><FONT COLOR="#228B22">double</FONT></B> num, inverse[3][3];
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> xyzd50_srgb[3][3] =
  { { 0.436083, 0.385083, 0.143055 },
    { 0.222507, 0.716888, 0.060608 },
    { 0.013930, 0.097097, 0.714022 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> rgb_rgb[3][3] =
  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> adobe_rgb[3][3] =
  { { 0.715146, 0.284856, 0.000000 },
    { 0.000000, 1.000000, 0.000000 },
    { 0.000000, 0.041166, 0.958839 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> wide_rgb[3][3] =
  { { 0.593087, 0.404710, 0.002206 },
    { 0.095413, 0.843149, 0.061439 },
    { 0.011621, 0.069091, 0.919288 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> prophoto_rgb[3][3] =
  { { 0.529317, 0.330092, 0.140588 },
    { 0.098368, 0.873465, 0.028169 },
    { 0.016879, 0.117663, 0.865457 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> aces_rgb[3][3] =
  { { 0.432996, 0.375380, 0.189317 },
    { 0.089427, 0.816523, 0.102989 },
    { 0.019165, 0.118150, 0.941914 } };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> (*out_rgb[])[3] =
  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *name[] =
  { <B><FONT COLOR="#BC8F8F">&quot;sRGB&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Adobe RGB (1998)&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;WideGamut D65&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;ProPhoto D65&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;XYZ&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;ACES&quot;</FONT></B> };
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> phead[] =
  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,
    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> pbody[] =
  { 10, 0x63707274, 0, 36,	<I><FONT COLOR="#B22222">/* cprt */</FONT></I>
	0x64657363, 0, 40,	<I><FONT COLOR="#B22222">/* desc */</FONT></I>
	0x77747074, 0, 20,	<I><FONT COLOR="#B22222">/* wtpt */</FONT></I>
	0x626b7074, 0, 20,	<I><FONT COLOR="#B22222">/* bkpt */</FONT></I>
	0x72545243, 0, 14,	<I><FONT COLOR="#B22222">/* rTRC */</FONT></I>
	0x67545243, 0, 14,	<I><FONT COLOR="#B22222">/* gTRC */</FONT></I>
	0x62545243, 0, 14,	<I><FONT COLOR="#B22222">/* bTRC */</FONT></I>
	0x7258595a, 0, 20,	<I><FONT COLOR="#B22222">/* rXYZ */</FONT></I>
	0x6758595a, 0, 20,	<I><FONT COLOR="#B22222">/* gXYZ */</FONT></I>
	0x6258595a, 0, 20 };	<I><FONT COLOR="#B22222">/* bXYZ */</FONT></I>
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> pwhite[] = { 0xf351, 0x10000, 0x116cc };
  <B><FONT COLOR="#228B22">unsigned</FONT></B> pcurve[] = { 0x63757276, 0, 1, 0x1000000 };

  gamma_curve (gamm[0], gamm[1], 0, 0);
  memcpy (out_cam, rgb_cam, <B><FONT COLOR="#A020F0">sizeof</FONT></B> out_cam);
  raw_color |= colors == 1 || document_mode ||
		output_color &lt; 1 || output_color &gt; 6;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!raw_color) {
    oprof = (<B><FONT COLOR="#228B22">unsigned</FONT></B> *) calloc (phead[0], 1);
    merror (oprof, <B><FONT COLOR="#BC8F8F">&quot;convert_to_rgb()&quot;</FONT></B>);
    memcpy (oprof, phead, <B><FONT COLOR="#A020F0">sizeof</FONT></B> phead);
    <B><FONT COLOR="#A020F0">if</FONT></B> (output_color == 5) oprof[4] = oprof[5];
    oprof[0] = 132 + 12*pbody[0];
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; pbody[0]; i++) {
      oprof[oprof[0]/4] = i ? (i &gt; 1 ? 0x58595a20 : 0x64657363) : 0x74657874;
      pbody[i*3+2] = oprof[0];
      oprof[0] += (pbody[i*3+3] + 3) &amp; -4;
    }
    memcpy (oprof+32, pbody, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pbody);
    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;
    memcpy ((<B><FONT COLOR="#228B22">char</FONT></B> *)oprof+pbody[8]+8, pwhite, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pwhite);
    pcurve[3] = (<B><FONT COLOR="#228B22">short</FONT></B>)(256/gamm[5]+0.5) &lt;&lt; 16;
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=4; i &lt; 7; i++)
      memcpy ((<B><FONT COLOR="#228B22">char</FONT></B> *)oprof+pbody[i*3+2], pcurve, <B><FONT COLOR="#A020F0">sizeof</FONT></B> pcurve);
    pseudoinverse ((<B><FONT COLOR="#228B22">double</FONT></B> (*)[3]) out_rgb[output_color-1], inverse, 3);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; 3; j++) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (num = k=0; k &lt; 3; k++)
	  num += xyzd50_srgb[i][k] * inverse[j][k];
	oprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;
      }
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; phead[0]/4; i++)
      oprof[i] = htonl(oprof[i]);
    strcpy ((<B><FONT COLOR="#228B22">char</FONT></B> *)oprof+pbody[2]+8, <B><FONT COLOR="#BC8F8F">&quot;auto-generated by dcraw&quot;</FONT></B>);
    strcpy ((<B><FONT COLOR="#228B22">char</FONT></B> *)oprof+pbody[5]+12, name[output_color-1]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; 3; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (j=0; j &lt; colors; j++)
	<B><FONT COLOR="#A020F0">for</FONT></B> (out_cam[i][j] = k=0; k &lt; 3; k++)
	  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
    fprintf (stderr, raw_color ? _(<B><FONT COLOR="#BC8F8F">&quot;Building histograms...\n&quot;</FONT></B>) :
	_(<B><FONT COLOR="#BC8F8F">&quot;Converting to %s colorspace...\n&quot;</FONT></B>), name[output_color-1]);

  memset (histogram, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> histogram);
  <B><FONT COLOR="#A020F0">for</FONT></B> (img=image[0], row=0; row &lt; height; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++, img+=4) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!raw_color) {
	out[0] = out[1] = out[2] = 0;
	FORCC {
	  out[0] += out_cam[0][c] * img[c];
	  out[1] += out_cam[1][c] * img[c];
	  out[2] += out_cam[2][c] * img[c];
	}
	FORC3 img[c] = CLIP((<B><FONT COLOR="#228B22">int</FONT></B>) out[c]);
      }
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (document_mode)
	img[0] = img[fcol(row,col)];
      FORCC histogram[c][img[c] &gt;&gt; 3]++;
    }
  <B><FONT COLOR="#A020F0">if</FONT></B> (colors == 4 &amp;&amp; output_color) colors = 3;
  <B><FONT COLOR="#A020F0">if</FONT></B> (document_mode &amp;&amp; filters) colors = 1;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">fuji_rotate</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> i, row, col;
  <B><FONT COLOR="#228B22">double</FONT></B> step;
  <B><FONT COLOR="#228B22">float</FONT></B> r, c, fr, fc;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> ur, uc;
  ushort wide, high, (*img)[4], (*pix)[4];

  <B><FONT COLOR="#A020F0">if</FONT></B> (!fuji_width) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Rotating image 45 degrees...\n&quot;</FONT></B>));
  fuji_width = (fuji_width - 1 + shrink) &gt;&gt; shrink;
  step = sqrt(0.5);
  wide = fuji_width / step;
  high = (height - fuji_width) / step;
  img = (ushort (*)[4]) calloc (high, wide*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *img);
  merror (img, <B><FONT COLOR="#BC8F8F">&quot;fuji_rotate()&quot;</FONT></B>);

  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; high; row++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; wide; col++) {
      ur = r = fuji_width + (row-col)*step;
      uc = c = (row+col)*step;
      <B><FONT COLOR="#A020F0">if</FONT></B> (ur &gt; height-2 || uc &gt; width-2) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      fr = r - ur;
      fc = c - uc;
      pix = image + ur*width + uc;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; colors; i++)
	img[row*wide+col][i] =
	  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +
	  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;
    }
  free (image);
  width  = wide;
  height = high;
  image  = img;
  fuji_width = 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">stretch</FONT></B>()
{
  ushort newdim, (*img)[4], *pix0, *pix1;
  <B><FONT COLOR="#228B22">int</FONT></B> row, col, c;
  <B><FONT COLOR="#228B22">double</FONT></B> rc, frac;

  <B><FONT COLOR="#A020F0">if</FONT></B> (pixel_aspect == 1) <B><FONT COLOR="#A020F0">return</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Stretching the image...\n&quot;</FONT></B>));
  <B><FONT COLOR="#A020F0">if</FONT></B> (pixel_aspect &lt; 1) {
    newdim = height / pixel_aspect + 0.5;
    img = (ushort (*)[4]) calloc (width, newdim*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *img);
    merror (img, <B><FONT COLOR="#BC8F8F">&quot;stretch()&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (rc=row=0; row &lt; newdim; row++, rc+=pixel_aspect) {
      frac = rc - (c = rc);
      pix0 = pix1 = image[c*width];
      <B><FONT COLOR="#A020F0">if</FONT></B> (c+1 &lt; height) pix1 += width*4;
      <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++, pix0+=4, pix1+=4)
	FORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;
    }
    height = newdim;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    newdim = width * pixel_aspect + 0.5;
    img = (ushort (*)[4]) calloc (height, newdim*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *img);
    merror (img, <B><FONT COLOR="#BC8F8F">&quot;stretch()&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">for</FONT></B> (rc=col=0; col &lt; newdim; col++, rc+=1/pixel_aspect) {
      frac = rc - (c = rc);
      pix0 = pix1 = image[c];
      <B><FONT COLOR="#A020F0">if</FONT></B> (c+1 &lt; width) pix1 += 4;
      <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++, pix0+=width*4, pix1+=width*4)
	FORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;
    }
    width = newdim;
  }
  free (image);
  image = img;
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">flip_index</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> row, <B><FONT COLOR="#228B22">int</FONT></B> col)
{
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip &amp; 4) SWAP(row,col);
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip &amp; 2) row = iheight - 1 - row;
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip &amp; 1) col = iwidth  - 1 - col;
  <B><FONT COLOR="#A020F0">return</FONT></B> row * iwidth + col;
}

<B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag {
  ushort tag, type;
  <B><FONT COLOR="#228B22">int</FONT></B> count;
  <B><FONT COLOR="#228B22">union</FONT></B> { <B><FONT COLOR="#228B22">char</FONT></B> c[4]; <B><FONT COLOR="#228B22">short</FONT></B> s[2]; <B><FONT COLOR="#228B22">int</FONT></B> i; } val;
};

<B><FONT COLOR="#228B22">struct</FONT></B> tiff_hdr {
  ushort order, magic;
  <B><FONT COLOR="#228B22">int</FONT></B> ifd;
  ushort pad, ntag;
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag tag[23];
  <B><FONT COLOR="#228B22">int</FONT></B> nextifd;
  ushort pad2, nexif;
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag exif[4];
  ushort pad3, ngps;
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag gpst[10];
  <B><FONT COLOR="#228B22">short</FONT></B> bps[4];
  <B><FONT COLOR="#228B22">int</FONT></B> rat[10];
  <B><FONT COLOR="#228B22">unsigned</FONT></B> gps[26];
  <B><FONT COLOR="#228B22">char</FONT></B> desc[512], make[64], model[64], soft[32], date[20], artist[64];
};

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">tiff_set</FONT></B> (<B><FONT COLOR="#228B22">struct</FONT></B> tiff_hdr *th, ushort *ntag,
	ushort tag, ushort type, <B><FONT COLOR="#228B22">int</FONT></B> count, <B><FONT COLOR="#228B22">int</FONT></B> val)
{
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag *tt;
  <B><FONT COLOR="#228B22">int</FONT></B> c;

  tt = (<B><FONT COLOR="#228B22">struct</FONT></B> tiff_tag *)(ntag+1) + (*ntag)++;
  tt-&gt;val.i = val;
  <B><FONT COLOR="#A020F0">if</FONT></B> (type == 1 &amp;&amp; count &lt;= 4)
    FORC(4) tt-&gt;val.c[c] = val &gt;&gt; (c &lt;&lt; 3);
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (type == 2) {
    count = strnlen((<B><FONT COLOR="#228B22">char</FONT></B> *)th + val, count-1) + 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (count &lt;= 4)
      FORC(4) tt-&gt;val.c[c] = ((<B><FONT COLOR="#228B22">char</FONT></B> *)th)[val+c];
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (type == 3 &amp;&amp; count &lt;= 2)
    FORC(2) tt-&gt;val.s[c] = val &gt;&gt; (c &lt;&lt; 4);
  tt-&gt;count = count;
  tt-&gt;type = type;
  tt-&gt;tag = tag;
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">TOFF</FONT></B>(ptr) ((char *)(&amp;(ptr)) - (char *)th)

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">tiff_head</FONT></B> (<B><FONT COLOR="#228B22">struct</FONT></B> tiff_hdr *th, <B><FONT COLOR="#228B22">int</FONT></B> full)
{
  <B><FONT COLOR="#228B22">int</FONT></B> c, psize=0;
  <B><FONT COLOR="#228B22">struct</FONT></B> tm *t;

  memset (th, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *th);
  th-&gt;order = htonl(0x4d4d4949) &gt;&gt; 16;
  th-&gt;magic = 42;
  th-&gt;ifd = 10;
  th-&gt;rat[0] = th-&gt;rat[2] = 300;
  th-&gt;rat[1] = th-&gt;rat[3] = 1;
  FORC(6) th-&gt;rat[4+c] = 1000000;
  th-&gt;rat[4] *= shutter;
  th-&gt;rat[6] *= aperture;
  th-&gt;rat[8] *= focal_len;
  strncpy (th-&gt;desc, desc, 512);
  strncpy (th-&gt;make, make, 64);
  strncpy (th-&gt;model, model, 64);
  strcpy (th-&gt;soft, <B><FONT COLOR="#BC8F8F">&quot;dcraw v&quot;</FONT></B>DCRAW_VERSION);
  t = localtime (&amp;timestamp);
  sprintf (th-&gt;date, <B><FONT COLOR="#BC8F8F">&quot;%04d:%02d:%02d %02d:%02d:%02d&quot;</FONT></B>,
      t-&gt;tm_year+1900,t-&gt;tm_mon+1,t-&gt;tm_mday,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec);
  strncpy (th-&gt;artist, artist, 64);
  <B><FONT COLOR="#A020F0">if</FONT></B> (full) {
    tiff_set (th, &amp;th-&gt;ntag, 254, 4, 1, 0);
    tiff_set (th, &amp;th-&gt;ntag, 256, 4, 1, width);
    tiff_set (th, &amp;th-&gt;ntag, 257, 4, 1, height);
    tiff_set (th, &amp;th-&gt;ntag, 258, 3, colors, output_bps);
    <B><FONT COLOR="#A020F0">if</FONT></B> (colors &gt; 2)
      th-&gt;tag[th-&gt;ntag-1].val.i = TOFF(th-&gt;bps);
    FORC4 th-&gt;bps[c] = output_bps;
    tiff_set (th, &amp;th-&gt;ntag, 259, 3, 1, 1);
    tiff_set (th, &amp;th-&gt;ntag, 262, 3, 1, 1 + (colors &gt; 1));
  }
  tiff_set (th, &amp;th-&gt;ntag, 270, 2, 512, TOFF(th-&gt;desc));
  tiff_set (th, &amp;th-&gt;ntag, 271, 2, 64, TOFF(th-&gt;make));
  tiff_set (th, &amp;th-&gt;ntag, 272, 2, 64, TOFF(th-&gt;model));
  <B><FONT COLOR="#A020F0">if</FONT></B> (full) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (oprof) psize = ntohl(oprof[0]);
    tiff_set (th, &amp;th-&gt;ntag, 273, 4, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *th + psize);
    tiff_set (th, &amp;th-&gt;ntag, 277, 3, 1, colors);
    tiff_set (th, &amp;th-&gt;ntag, 278, 4, 1, height);
    tiff_set (th, &amp;th-&gt;ntag, 279, 4, 1, height*width*colors*output_bps/8);
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    tiff_set (th, &amp;th-&gt;ntag, 274, 3, 1, <B><FONT COLOR="#BC8F8F">&quot;12435867&quot;</FONT></B>[flip]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>);
  tiff_set (th, &amp;th-&gt;ntag, 282, 5, 1, TOFF(th-&gt;rat[0]));
  tiff_set (th, &amp;th-&gt;ntag, 283, 5, 1, TOFF(th-&gt;rat[2]));
  tiff_set (th, &amp;th-&gt;ntag, 284, 3, 1, 1);
  tiff_set (th, &amp;th-&gt;ntag, 296, 3, 1, 2);
  tiff_set (th, &amp;th-&gt;ntag, 305, 2, 32, TOFF(th-&gt;soft));
  tiff_set (th, &amp;th-&gt;ntag, 306, 2, 20, TOFF(th-&gt;date));
  tiff_set (th, &amp;th-&gt;ntag, 315, 2, 64, TOFF(th-&gt;artist));
  tiff_set (th, &amp;th-&gt;ntag, 34665, 4, 1, TOFF(th-&gt;nexif));
  <B><FONT COLOR="#A020F0">if</FONT></B> (psize) tiff_set (th, &amp;th-&gt;ntag, 34675, 7, psize, <B><FONT COLOR="#A020F0">sizeof</FONT></B> *th);
  tiff_set (th, &amp;th-&gt;nexif, 33434, 5, 1, TOFF(th-&gt;rat[4]));
  tiff_set (th, &amp;th-&gt;nexif, 33437, 5, 1, TOFF(th-&gt;rat[6]));
  tiff_set (th, &amp;th-&gt;nexif, 34855, 3, 1, iso_speed);
  tiff_set (th, &amp;th-&gt;nexif, 37386, 5, 1, TOFF(th-&gt;rat[8]));
  <B><FONT COLOR="#A020F0">if</FONT></B> (gpsdata[1]) {
    tiff_set (th, &amp;th-&gt;ntag, 34853, 4, 1, TOFF(th-&gt;ngps));
    tiff_set (th, &amp;th-&gt;ngps,  0, 1,  4, 0x202);
    tiff_set (th, &amp;th-&gt;ngps,  1, 2,  2, gpsdata[29]);
    tiff_set (th, &amp;th-&gt;ngps,  2, 5,  3, TOFF(th-&gt;gps[0]));
    tiff_set (th, &amp;th-&gt;ngps,  3, 2,  2, gpsdata[30]);
    tiff_set (th, &amp;th-&gt;ngps,  4, 5,  3, TOFF(th-&gt;gps[6]));
    tiff_set (th, &amp;th-&gt;ngps,  5, 1,  1, gpsdata[31]);
    tiff_set (th, &amp;th-&gt;ngps,  6, 5,  1, TOFF(th-&gt;gps[18]));
    tiff_set (th, &amp;th-&gt;ngps,  7, 5,  3, TOFF(th-&gt;gps[12]));
    tiff_set (th, &amp;th-&gt;ngps, 18, 2, 12, TOFF(th-&gt;gps[20]));
    tiff_set (th, &amp;th-&gt;ngps, 29, 2, 12, TOFF(th-&gt;gps[23]));
    memcpy (th-&gt;gps, gpsdata, <B><FONT COLOR="#A020F0">sizeof</FONT></B> th-&gt;gps);
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">jpeg_thumb</FONT></B>()
{
  <B><FONT COLOR="#228B22">char</FONT></B> *thumb;
  ushort exif[5];
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_hdr th;

  thumb = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (thumb_length);
  merror (thumb, <B><FONT COLOR="#BC8F8F">&quot;jpeg_thumb()&quot;</FONT></B>);
  fread (thumb, 1, thumb_length, ifp);
  fputc (0xff, ofp);
  fputc (0xd8, ofp);
  <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp (thumb+6, <B><FONT COLOR="#BC8F8F">&quot;Exif&quot;</FONT></B>)) {
    memcpy (exif, <B><FONT COLOR="#BC8F8F">&quot;\xff\xe1  Exif\0\0&quot;</FONT></B>, 10);
    exif[1] = htons (8 + <B><FONT COLOR="#A020F0">sizeof</FONT></B> th);
    fwrite (exif, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> exif, ofp);
    tiff_head (&amp;th, 0);
    fwrite (&amp;th, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B> th, ofp);
  }
  fwrite (thumb+2, 1, thumb_length-2, ofp);
  free (thumb);
}

<B><FONT COLOR="#228B22">void</FONT></B> CLASS <B><FONT COLOR="#0000FF">write_ppm_tiff</FONT></B>()
{
  <B><FONT COLOR="#228B22">struct</FONT></B> tiff_hdr th;
  uchar *ppm;
  ushort *ppm2;
  <B><FONT COLOR="#228B22">int</FONT></B> c, row, col, soff, rstep, cstep;
  <B><FONT COLOR="#228B22">int</FONT></B> perc, val, total, white=0x2000;

  perc = width * height * 0.01;		<I><FONT COLOR="#B22222">/* 99th percentile white level */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (fuji_width) perc /= 2;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!((highlight &amp; ~2) || no_auto_bright))
    <B><FONT COLOR="#A020F0">for</FONT></B> (white=c=0; c &lt; colors; c++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (val=0x2000, total=0; --val &gt; 32; )
	<B><FONT COLOR="#A020F0">if</FONT></B> ((total += histogram[c][val]) &gt; perc) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (white &lt; val) white = val;
    }
  gamma_curve (gamm[0], gamm[1], 2, (white &lt;&lt; 3)/bright);
  iheight = height;
  iwidth  = width;
  <B><FONT COLOR="#A020F0">if</FONT></B> (flip &amp; 4) SWAP(height,width);
  ppm = (uchar *) calloc (width, colors*output_bps/8);
  ppm2 = (ushort *) ppm;
  merror (ppm, <B><FONT COLOR="#BC8F8F">&quot;write_ppm_tiff()&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (output_tiff) {
    tiff_head (&amp;th, 1);
    fwrite (&amp;th, <B><FONT COLOR="#A020F0">sizeof</FONT></B> th, 1, ofp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (oprof)
      fwrite (oprof, ntohl(oprof[0]), 1, ofp);
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (colors &gt; 3)
    fprintf (ofp,
      <B><FONT COLOR="#BC8F8F">&quot;P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n&quot;</FONT></B>,
	width, height, colors, (1 &lt;&lt; output_bps)-1, cdesc);
  <B><FONT COLOR="#A020F0">else</FONT></B>
    fprintf (ofp, <B><FONT COLOR="#BC8F8F">&quot;P%d\n%d %d\n%d\n&quot;</FONT></B>,
	colors/2+5, width, height, (1 &lt;&lt; output_bps)-1);
  soff  = flip_index (0, 0);
  cstep = flip_index (0, 1) - soff;
  rstep = flip_index (1, 0) - flip_index (0, width);
  <B><FONT COLOR="#A020F0">for</FONT></B> (row=0; row &lt; height; row++, soff += rstep) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (col=0; col &lt; width; col++, soff += cstep)
      <B><FONT COLOR="#A020F0">if</FONT></B> (output_bps == 8)
	   FORCC ppm [col*colors+c] = curve[image[soff][c]] &gt;&gt; 8;
      <B><FONT COLOR="#A020F0">else</FONT></B> FORCC ppm2[col*colors+c] = curve[image[soff][c]];
    <B><FONT COLOR="#A020F0">if</FONT></B> (output_bps == 16 &amp;&amp; !output_tiff &amp;&amp; htons(0x55aa) != 0x55aa)
      swab (ppm2, ppm2, width*colors*2);
    fwrite (ppm, colors*output_bps/8, width, ofp);
  }
  free (ppm);
}

<B><FONT COLOR="#228B22">int</FONT></B> CLASS <B><FONT COLOR="#0000FF">main</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> **argv)
{
  <B><FONT COLOR="#228B22">int</FONT></B> arg, status=0, quality, i, c;
  <B><FONT COLOR="#228B22">int</FONT></B> timestamp_only=0, thumbnail_only=0, identify_only=0;
  <B><FONT COLOR="#228B22">int</FONT></B> user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;
  <B><FONT COLOR="#228B22">int</FONT></B> use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sp, *bpfile=0, *dark_frame=0, *write_ext;
  <B><FONT COLOR="#228B22">char</FONT></B> opm, opt, *ofname, *cp;
  <B><FONT COLOR="#228B22">struct</FONT></B> utimbuf ut;
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *cam_profile=0, *out_profile=0;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">LOCALTIME</FONT>
  putenv ((<B><FONT COLOR="#228B22">char</FONT></B> *) <B><FONT COLOR="#BC8F8F">&quot;TZ=UTC&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">LOCALEDIR</FONT>
  setlocale (LC_CTYPE, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
  setlocale (LC_MESSAGES, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
  bindtextdomain (<B><FONT COLOR="#BC8F8F">&quot;dcraw&quot;</FONT></B>, LOCALEDIR);
  textdomain (<B><FONT COLOR="#BC8F8F">&quot;dcraw&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <B><FONT COLOR="#A020F0">if</FONT></B> (argc == 1) {
    printf(_(<B><FONT COLOR="#BC8F8F">&quot;\nRaw photo decoder \&quot;dcraw\&quot; v%s&quot;</FONT></B>), DCRAW_VERSION);
    printf(_(<B><FONT COLOR="#BC8F8F">&quot;\nby Dave Coffin, dcoffin a cybercom o net\n&quot;</FONT></B>));
    printf(_(<B><FONT COLOR="#BC8F8F">&quot;\nUsage:  %s [OPTION]... [FILE]...\n\n&quot;</FONT></B>), argv[0]);
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-v        Print verbose messages&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-c        Write image data to standard output&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-e        Extract embedded thumbnail image&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-i        Identify files without decoding them&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-i -v     Identify files and show metadata&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-z        Change file dates to camera timestamp&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-w        Use camera white balance, if possible&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-a        Average the whole image for white balance&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-A &lt;x y w h&gt; Average a grey box for white balance&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-r &lt;r g b g&gt; Set custom white balance&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;+M/-M     Use/don't use an embedded color matrix&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-C &lt;r b&gt;  Correct chromatic aberration&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-P &lt;file&gt; Fix the dead pixels listed in this file&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-K &lt;file&gt; Subtract dark frame (16-bit raw PGM)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-k &lt;num&gt;  Set the darkness level&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-S &lt;num&gt;  Set the saturation level&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-n &lt;num&gt;  Set threshold for wavelet denoising&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-o [0-6]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ,ACES)&quot;</FONT></B>));
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-o &lt;file&gt; Apply output ICC profile from file&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-p &lt;file&gt; Apply camera ICC profile from file or \&quot;embed\&quot;&quot;</FONT></B>));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-d        Document mode (no color, no interpolation)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-D        Document mode without scaling (totally raw)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-j        Don't stretch or rotate raw pixels&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-W        Don't automatically brighten the image&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-b &lt;num&gt;  Adjust brightness (default = 1.0)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-g &lt;p ts&gt; Set custom gamma curve (default = 2.222 4.5)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-q [0-3]  Set the interpolation quality&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-h        Half-size color image (twice as fast as \&quot;-q 0\&quot;)&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-f        Interpolate RGGB as four colors&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-m &lt;num&gt;  Apply a 3x3 median filter to R-G and B-G&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-s [0..N-1] Select one raw image or \&quot;all\&quot; from each file&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-6        Write 16-bit instead of 8-bit&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-4        Linear 16-bit, same as \&quot;-6 -W -g 1 1\&quot;&quot;</FONT></B>));
    puts(_(<B><FONT COLOR="#BC8F8F">&quot;-T        Write TIFF instead of PPM&quot;</FONT></B>));
    puts(<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  argv[argc] = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;
  <B><FONT COLOR="#A020F0">for</FONT></B> (arg=1; (((opm = argv[arg][0]) - 2) | 2) == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>; ) {
    opt = argv[arg++][1];
    <B><FONT COLOR="#A020F0">if</FONT></B> ((cp = (<B><FONT COLOR="#228B22">char</FONT></B> *) strchr (sp=<B><FONT COLOR="#BC8F8F">&quot;nbrkStqmHACg&quot;</FONT></B>, opt)))
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; <B><FONT COLOR="#BC8F8F">&quot;114111111422&quot;</FONT></B>[cp-sp]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>; i++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (!isdigit(argv[arg+i][0])) {
	  fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Non-numeric argument to \&quot;-%c\&quot;\n&quot;</FONT></B>), opt);
	  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
	}
    <B><FONT COLOR="#A020F0">switch</FONT></B> (opt) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'n'</FONT></B>:  threshold   = atof(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'b'</FONT></B>:  bright      = atof(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'r'</FONT></B>:
	   FORC4 user_mul[c] = atof(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'C'</FONT></B>:  aber[0] = 1 / atof(argv[arg++]);
		 aber[2] = 1 / atof(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'g'</FONT></B>:  gamm[0] =     atof(argv[arg++]);
		 gamm[1] =     atof(argv[arg++]);
		 <B><FONT COLOR="#A020F0">if</FONT></B> (gamm[0]) gamm[0] = 1/gamm[0]; <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'k'</FONT></B>:  user_black  = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'S'</FONT></B>:  user_sat    = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'t'</FONT></B>:  user_flip   = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'q'</FONT></B>:  user_qual   = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'m'</FONT></B>:  med_passes  = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'H'</FONT></B>:  highlight   = atoi(argv[arg++]);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'s'</FONT></B>:
	shot_select = abs(atoi(argv[arg]));
	multi_out = !strcmp(argv[arg++],<B><FONT COLOR="#BC8F8F">&quot;all&quot;</FONT></B>);
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'o'</FONT></B>:
	<B><FONT COLOR="#A020F0">if</FONT></B> (isdigit(argv[arg][0]) &amp;&amp; !argv[arg][1])
	  output_color = atoi(argv[arg++]);
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
	<B><FONT COLOR="#A020F0">else</FONT></B>     out_profile = argv[arg++];
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'p'</FONT></B>:  cam_profile = argv[arg++];
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'P'</FONT></B>:  bpfile     = argv[arg++];  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'K'</FONT></B>:  dark_frame = argv[arg++];  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'z'</FONT></B>:  timestamp_only    = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'e'</FONT></B>:  thumbnail_only    = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'i'</FONT></B>:  identify_only     = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'c'</FONT></B>:  write_to_stdout   = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'v'</FONT></B>:  verbose           = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'h'</FONT></B>:  half_size         = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'f'</FONT></B>:  four_color_rgb    = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'A'</FONT></B>:  FORC4 greybox[c]  = atoi(argv[arg++]);
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'a'</FONT></B>:  use_auto_wb       = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'w'</FONT></B>:  use_camera_wb     = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'M'</FONT></B>:  use_camera_matrix = 3 * (opm == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>);  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'I'</FONT></B>:  read_from_stdin   = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'E'</FONT></B>:  document_mode++;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'D'</FONT></B>:  document_mode++;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'d'</FONT></B>:  document_mode++;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'j'</FONT></B>:  use_fuji_rotate   = 0;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'W'</FONT></B>:  no_auto_bright    = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'T'</FONT></B>:  output_tiff       = 1;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'4'</FONT></B>:  gamm[0] = gamm[1] =
		 no_auto_bright    = 1;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#BC8F8F">'6'</FONT></B>:  output_bps       = 16;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#5F9EA0">default</FONT></B>:
	fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Unknown option \&quot;-%c\&quot;.\n&quot;</FONT></B>), opt);
	<B><FONT COLOR="#A020F0">return</FONT></B> 1;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (arg == argc) {
    fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;No files to process.\n&quot;</FONT></B>));
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (write_to_stdout) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (isatty(1)) {
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Will not write an image to the terminal!\n&quot;</FONT></B>));
      <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">WIN32</FONT>) || <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">DJGPP</FONT>) || <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">__CYGWIN__</FONT>)
    <B><FONT COLOR="#A020F0">if</FONT></B> (setmode(1,O_BINARY) &lt; 0) {
      perror (<B><FONT COLOR="#BC8F8F">&quot;setmode()&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> ( ; arg &lt; argc; arg++) {
    status = 1;
    raw_image = 0;
    image = 0;
    oprof = 0;
    meta_data = ofname = 0;
    ofp = stdout;
    <B><FONT COLOR="#A020F0">if</FONT></B> (setjmp (failure)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (fileno(ifp) &gt; 2) fclose(ifp);
      <B><FONT COLOR="#A020F0">if</FONT></B> (fileno(ofp) &gt; 2) fclose(ofp);
      status = 1;
      <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">cleanup</FONT></B>;
    }
    ifname = argv[arg];
    <B><FONT COLOR="#A020F0">if</FONT></B> (!(ifp = fopen (ifname, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>))) {
      perror (ifname);
      <B><FONT COLOR="#A020F0">continue</FONT></B>;
    }
    status = (identify(),!is_raw);
    <B><FONT COLOR="#A020F0">if</FONT></B> (user_flip &gt;= 0)
      flip = user_flip;
    <B><FONT COLOR="#A020F0">switch</FONT></B> ((flip+3600) % 360) {
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">270</FONT></B>:  flip = 5;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">180</FONT></B>:  flip = 3;  <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">case</FONT></B>  <B><FONT COLOR="#5F9EA0">90</FONT></B>:  flip = 6;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (timestamp_only) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((status = !timestamp))
	fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s has no timestamp.\n&quot;</FONT></B>), ifname);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (identify_only)
	printf (<B><FONT COLOR="#BC8F8F">&quot;%10ld%10d %s\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">long</FONT></B>) timestamp, shot_order, ifname);
      <B><FONT COLOR="#A020F0">else</FONT></B> {
	<B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
	  fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s time set to %d.\n&quot;</FONT></B>), ifname, (<B><FONT COLOR="#228B22">int</FONT></B>) timestamp);
	ut.actime = ut.modtime = timestamp;
	utime (ifname, &amp;ut);
      }
      <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
    }
    write_fun = &amp;CLASS write_ppm_tiff;
    <B><FONT COLOR="#A020F0">if</FONT></B> (thumbnail_only) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((status = !thumb_offset)) {
	fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s has no thumbnail.\n&quot;</FONT></B>), ifname);
	<B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (thumb_load_raw) {
	load_raw = thumb_load_raw;
	data_offset = thumb_offset;
	height = thumb_height;
	width  = thumb_width;
	filters = 0;
	colors = 3;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
	fseek (ifp, thumb_offset, SEEK_SET);
	write_fun = write_thumb;
	<B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">thumbnail</FONT></B>;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (load_raw == &amp;CLASS kodak_ycbcr_load_raw) {
      height += height &amp; 1;
      width  += width  &amp; 1;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (identify_only &amp;&amp; verbose &amp;&amp; make[0]) {
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;\nFilename: %s\n&quot;</FONT></B>), ifname);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Timestamp: %s&quot;</FONT></B>), ctime(&amp;timestamp));
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Camera: %s %s\n&quot;</FONT></B>), make, model);
      <B><FONT COLOR="#A020F0">if</FONT></B> (artist[0])
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Owner: %s\n&quot;</FONT></B>), artist);
      <B><FONT COLOR="#A020F0">if</FONT></B> (dng_version) {
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;DNG Version: &quot;</FONT></B>));
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=24; i &gt;= 0; i -= 8)
	  printf (<B><FONT COLOR="#BC8F8F">&quot;%d%c&quot;</FONT></B>, dng_version &gt;&gt; i &amp; 255, i ? <B><FONT COLOR="#BC8F8F">'.'</FONT></B>:<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>);
      }
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;ISO speed: %d\n&quot;</FONT></B>), (<B><FONT COLOR="#228B22">int</FONT></B>) iso_speed);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Shutter: &quot;</FONT></B>));
      <B><FONT COLOR="#A020F0">if</FONT></B> (shutter &gt; 0 &amp;&amp; shutter &lt; 1)
	shutter = (printf (<B><FONT COLOR="#BC8F8F">&quot;1/&quot;</FONT></B>), 1 / shutter);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;%0.1f sec\n&quot;</FONT></B>), shutter);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Aperture: f/%0.1f\n&quot;</FONT></B>), aperture);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Focal length: %0.1f mm\n&quot;</FONT></B>), focal_len);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Embedded ICC profile: %s\n&quot;</FONT></B>), profile_length ? _(<B><FONT COLOR="#BC8F8F">&quot;yes&quot;</FONT></B>):_(<B><FONT COLOR="#BC8F8F">&quot;no&quot;</FONT></B>));
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Number of raw images: %d\n&quot;</FONT></B>), is_raw);
      <B><FONT COLOR="#A020F0">if</FONT></B> (pixel_aspect != 1)
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Pixel Aspect Ratio: %0.6f\n&quot;</FONT></B>), pixel_aspect);
      <B><FONT COLOR="#A020F0">if</FONT></B> (thumb_offset)
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Thumb size:  %4d x %d\n&quot;</FONT></B>), thumb_width, thumb_height);
      printf (_(<B><FONT COLOR="#BC8F8F">&quot;Full size:   %4d x %d\n&quot;</FONT></B>), raw_width, raw_height);
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!is_raw)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Cannot decode file %s\n&quot;</FONT></B>), ifname);
    <B><FONT COLOR="#A020F0">if</FONT></B> (!is_raw) <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">next</FONT></B>;
    shrink = filters &amp;&amp; (half_size || (!identify_only &amp;&amp;
	(threshold || aber[0] != 1 || aber[2] != 1)));
    iheight = (height + shrink) &gt;&gt; shrink;
    iwidth  = (width  + shrink) &gt;&gt; shrink;
    <B><FONT COLOR="#A020F0">if</FONT></B> (identify_only) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (verbose) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (document_mode == 3) {
	  top_margin = left_margin = fuji_width = 0;
	  height = raw_height;
	  width  = raw_width;
	}
	iheight = (height + shrink) &gt;&gt; shrink;
	iwidth  = (width  + shrink) &gt;&gt; shrink;
	<B><FONT COLOR="#A020F0">if</FONT></B> (use_fuji_rotate) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (fuji_width) {
	    fuji_width = (fuji_width - 1 + shrink) &gt;&gt; shrink;
	    iwidth = fuji_width / sqrt(0.5);
	    iheight = (iheight - fuji_width) / sqrt(0.5);
	  } <B><FONT COLOR="#A020F0">else</FONT></B> {
	    <B><FONT COLOR="#A020F0">if</FONT></B> (pixel_aspect &lt; 1) iheight = iheight / pixel_aspect + 0.5;
	    <B><FONT COLOR="#A020F0">if</FONT></B> (pixel_aspect &gt; 1) iwidth  = iwidth  * pixel_aspect + 0.5;
	  }
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (flip &amp; 4)
	  SWAP(iheight,iwidth);
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Image size:  %4d x %d\n&quot;</FONT></B>), width, height);
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Output size: %4d x %d\n&quot;</FONT></B>), iwidth, iheight);
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;Raw colors: %d&quot;</FONT></B>), colors);
	<B><FONT COLOR="#A020F0">if</FONT></B> (filters) {
	  <B><FONT COLOR="#228B22">int</FONT></B> fhigh = 2, fwide = 2;
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((filters ^ (filters &gt;&gt;  8)) &amp; 0xff)   fhigh = 4;
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((filters ^ (filters &gt;&gt; 16)) &amp; 0xffff) fhigh = 8;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 1) fhigh = fwide = 16;
	  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9) fhigh = fwide = 6;
	  printf (_(<B><FONT COLOR="#BC8F8F">&quot;\nFilter pattern: &quot;</FONT></B>));
	  <B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; fhigh; i++)
	    <B><FONT COLOR="#A020F0">for</FONT></B> (c = i &amp;&amp; putchar(<B><FONT COLOR="#BC8F8F">'/'</FONT></B>) &amp;&amp; 0; c &lt; fwide; c++)
	      putchar (cdesc[fcol(i,c)]);
	}
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;\nDaylight multipliers:&quot;</FONT></B>));
	FORCC printf (<B><FONT COLOR="#BC8F8F">&quot; %f&quot;</FONT></B>, pre_mul[c]);
	<B><FONT COLOR="#A020F0">if</FONT></B> (cam_mul[0] &gt; 0) {
	  printf (_(<B><FONT COLOR="#BC8F8F">&quot;\nCamera multipliers:&quot;</FONT></B>));
	  FORC4 printf (<B><FONT COLOR="#BC8F8F">&quot; %f&quot;</FONT></B>, cam_mul[c]);
	}
	putchar (<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>);
      } <B><FONT COLOR="#A020F0">else</FONT></B>
	printf (_(<B><FONT COLOR="#BC8F8F">&quot;%s is a %s %s image.\n&quot;</FONT></B>), ifname, make, model);
<B><FONT COLOR="#5F9EA0">next</FONT></B>:
      fclose(ifp);
      <B><FONT COLOR="#A020F0">continue</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (meta_length) {
      meta_data = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (meta_length);
      merror (meta_data, <B><FONT COLOR="#BC8F8F">&quot;main()&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters || colors == 1) {
      raw_image = (ushort *) calloc ((raw_height+7), raw_width*2);
      merror (raw_image, <B><FONT COLOR="#BC8F8F">&quot;main()&quot;</FONT></B>);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      image = (ushort (*)[4]) calloc (iheight, iwidth*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
      merror (image, <B><FONT COLOR="#BC8F8F">&quot;main()&quot;</FONT></B>);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Loading %s %s image from %s ...\n&quot;</FONT></B>),
	make, model, ifname);
    <B><FONT COLOR="#A020F0">if</FONT></B> (shot_select &gt;= is_raw)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;%s: \&quot;-s %d\&quot; requests a nonexistent image!\n&quot;</FONT></B>),
	ifname, shot_select);
    fseeko (ifp, data_offset, SEEK_SET);
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_image &amp;&amp; read_from_stdin)
      fread (raw_image, 2, raw_height*raw_width, stdin);
    <B><FONT COLOR="#A020F0">else</FONT></B> (*load_raw)();
    <B><FONT COLOR="#A020F0">if</FONT></B> (document_mode == 3) {
      top_margin = left_margin = fuji_width = 0;
      height = raw_height;
      width  = raw_width;
    }
    iheight = (height + shrink) &gt;&gt; shrink;
    iwidth  = (width  + shrink) &gt;&gt; shrink;
    <B><FONT COLOR="#A020F0">if</FONT></B> (raw_image) {
      image = (ushort (*)[4]) calloc (iheight, iwidth*<B><FONT COLOR="#A020F0">sizeof</FONT></B> *image);
      merror (image, <B><FONT COLOR="#BC8F8F">&quot;main()&quot;</FONT></B>);
      crop_masked_pixels();
      free (raw_image);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (zero_is_bad) remove_zeroes();
    bad_pixels (bpfile);
    <B><FONT COLOR="#A020F0">if</FONT></B> (dark_frame) subtract (dark_frame);
    quality = 2 + !fuji_width;
    <B><FONT COLOR="#A020F0">if</FONT></B> (user_qual &gt;= 0) quality = user_qual;
    i = cblack[3];
    FORC3 <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; cblack[c]) i = cblack[c];
    FORC4 cblack[c] -= i;
    black += i;
    i = cblack[6];
    FORC (cblack[4] * cblack[5])
      <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; cblack[6+c]) i = cblack[6+c];
    FORC (cblack[4] * cblack[5])
      cblack[6+c] -= i;
    black += i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (user_black &gt;= 0) black = user_black;
    FORC4 cblack[c] += black;
    <B><FONT COLOR="#A020F0">if</FONT></B> (user_sat &gt; 0) maximum = user_sat;
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">COLORCHECK</FONT>
    colorcheck();
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> (is_foveon) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (document_mode || load_raw == &amp;CLASS foveon_dp_load_raw) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (i=0; i &lt; height*width*4; i++)
	  <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">short</FONT></B>) image[0][i] &lt; 0) image[0][i] = 0;
      } <B><FONT COLOR="#A020F0">else</FONT></B> foveon_interpolate();
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (document_mode &lt; 2)
      scale_colors();
    pre_interpolate();
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters &amp;&amp; !document_mode) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (quality == 0)
	lin_interpolate();
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (quality == 1 || colors &gt; 3)
	vng_interpolate();
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (quality == 2 &amp;&amp; filters &gt; 1000)
	ppg_interpolate();
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (filters == 9)
	xtrans_interpolate (quality*2-3);
      <B><FONT COLOR="#A020F0">else</FONT></B>
	ahd_interpolate();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (mix_green)
      <B><FONT COLOR="#A020F0">for</FONT></B> (colors=3, i=0; i &lt; height*width; i++)
	image[i][1] = (image[i][1] + image[i][3]) &gt;&gt; 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (!is_foveon &amp;&amp; colors == 3) median_filter();
    <B><FONT COLOR="#A020F0">if</FONT></B> (!is_foveon &amp;&amp; highlight == 2) blend_highlights();
    <B><FONT COLOR="#A020F0">if</FONT></B> (!is_foveon &amp;&amp; highlight &gt; 2) recover_highlights();
    <B><FONT COLOR="#A020F0">if</FONT></B> (use_fuji_rotate) fuji_rotate();
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_LCMS</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (cam_profile) apply_profile (cam_profile, out_profile);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    convert_to_rgb();
    <B><FONT COLOR="#A020F0">if</FONT></B> (use_fuji_rotate) stretch();
<B><FONT COLOR="#5F9EA0">thumbnail</FONT></B>:
    <B><FONT COLOR="#A020F0">if</FONT></B> (write_fun == &amp;CLASS jpeg_thumb)
      write_ext = <B><FONT COLOR="#BC8F8F">&quot;.jpg&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (output_tiff &amp;&amp; write_fun == &amp;CLASS write_ppm_tiff)
      write_ext = <B><FONT COLOR="#BC8F8F">&quot;.tiff&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      write_ext = <B><FONT COLOR="#BC8F8F">&quot;.pgm\0.ppm\0.ppm\0.pam&quot;</FONT></B> + colors*5-5;
    ofname = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloc (strlen(ifname) + 64);
    merror (ofname, <B><FONT COLOR="#BC8F8F">&quot;main()&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (write_to_stdout)
      strcpy (ofname,_(<B><FONT COLOR="#BC8F8F">&quot;standard output&quot;</FONT></B>));
    <B><FONT COLOR="#A020F0">else</FONT></B> {
      strcpy (ofname, ifname);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((cp = strrchr (ofname, <B><FONT COLOR="#BC8F8F">'.'</FONT></B>))) *cp = 0;
      <B><FONT COLOR="#A020F0">if</FONT></B> (multi_out)
	sprintf (ofname+strlen(ofname), <B><FONT COLOR="#BC8F8F">&quot;_%0*d&quot;</FONT></B>,
		snprintf(0,0,<B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>,is_raw-1), shot_select);
      <B><FONT COLOR="#A020F0">if</FONT></B> (thumbnail_only)
	strcat (ofname, <B><FONT COLOR="#BC8F8F">&quot;.thumb&quot;</FONT></B>);
      strcat (ofname, write_ext);
      ofp = fopen (ofname, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!ofp) {
	status = 1;
	perror (ofname);
	<B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">cleanup</FONT></B>;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (verbose)
      fprintf (stderr,_(<B><FONT COLOR="#BC8F8F">&quot;Writing data to %s ...\n&quot;</FONT></B>), ofname);
    (*write_fun)();
    fclose(ifp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ofp != stdout) fclose(ofp);
<B><FONT COLOR="#5F9EA0">cleanup</FONT></B>:
    <B><FONT COLOR="#A020F0">if</FONT></B> (meta_data) free (meta_data);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ofname) free (ofname);
    <B><FONT COLOR="#A020F0">if</FONT></B> (oprof) free (oprof);
    <B><FONT COLOR="#A020F0">if</FONT></B> (image) free (image);
    <B><FONT COLOR="#A020F0">if</FONT></B> (multi_out) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (++shot_select &lt; is_raw) arg--;
      <B><FONT COLOR="#A020F0">else</FONT></B> shot_select = 0;
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> status;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML>
